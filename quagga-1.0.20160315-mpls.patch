diff --git a/Makefile.am b/Makefile.am
index d2efb20..cdd275c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,10 +1,10 @@
 ## Process this file with automake to produce Makefile.in.
 
-SUBDIRS = lib @ZEBRA@ @BGPD@ @RIPD@ @RIPNGD@ @OSPFD@ @OSPF6D@ \
+SUBDIRS = lib @ZEBRA@ @BGPD@ @RIPD@ @RIPNGD@ @OSPFD@ @OSPF6D@ @LDPD@ \
          @ISISD@ @PIMD@ @WATCHQUAGGA@ @VTYSH@ @OSPFCLIENT@ @DOC@ m4 @pkgsrcdir@ \
          redhat @SOLARIS@ tests
 
-DIST_SUBDIRS = lib zebra bgpd ripd ripngd ospfd ospf6d \
+DIST_SUBDIRS = lib zebra bgpd ripd ripngd ospfd ospf6d ldpd \
 	  isisd watchquagga vtysh ospfclient doc m4 pkgsrc redhat tests \
 	  solaris pimd
 
diff --git a/configure.ac b/configure.ac
index 6206510..a779cd7 100755
--- a/configure.ac
+++ b/configure.ac
@@ -241,6 +241,8 @@ AC_ARG_ENABLE(ospfd,
   AS_HELP_STRING([--disable-ospfd], [do not build ospfd]))
 AC_ARG_ENABLE(ospf6d,
   AS_HELP_STRING([--disable-ospf6d], [do not build ospf6d]))
+AC_ARG_ENABLE(ldpd,
+  AS_HELP_STRING([--enable-ldpd], [build ldpd]))
 AC_ARG_ENABLE(watchquagga,
   AS_HELP_STRING([--disable-watchquagga], [do not build watchquagga]))
 AC_ARG_ENABLE(isisd,
@@ -297,6 +299,8 @@ AC_ARG_ENABLE(pcreposix,
   AS_HELP_STRING([--enable-pcreposix], [enable using PCRE Posix libs for regex functions]))
 AC_ARG_ENABLE(fpm,
   AS_HELP_STRING([--enable-fpm], [enable Forwarding Plane Manager support]))
+AC_ARG_ENABLE(mpls,
+  AS_HELP_STRING([--enable-mpls], [enable MPLS support - requires compatible kernel]))
 AC_ARG_ENABLE(werror,
   AS_HELP_STRING([--enable-werror], [enable -Werror (recommended for developers only)]))
 
@@ -318,6 +322,25 @@ if test "${enable_fpm}" = "yes"; then
    AC_DEFINE(HAVE_FPM,,Forwarding Plane Manager support)
 fi
 
+dnl ----------
+dnl MPLS check
+dnl ----------
+MPLS_METHOD=""
+AC_MSG_CHECKING(whether this OS has MPLS stack)
+if test "x${enable_mpls}" = "xyes"; then
+  case "$host" in
+    *-linux*)
+        AC_DEFINE(HAVE_MPLS,,Enable MPLS)
+        MPLS_METHOD="zebra_mpls_netlink.o"
+        AC_MSG_RESULT(Linux MPLS)
+    ;;
+  esac
+else
+  AC_MSG_RESULT(disabled)
+  MPLS_METHOD="zebra_mpls_null.o"
+fi
+AC_SUBST(MPLS_METHOD)
+
 if test "${enable_tcp_zebra}" = "yes"; then
   AC_DEFINE(HAVE_TCP_ZEBRA,,Use TCP for zebra communication)
 fi
@@ -783,7 +806,7 @@ AC_CHECK_FUNCS([dup2 ftruncate getcwd gethostbyname getpagesize gettimeofday \
 	strtol strtoul strlcat strlcpy \
 	daemon snprintf vsnprintf \
 	if_nametoindex if_indextoname getifaddrs \
-	uname fcntl getgrouplist])
+	uname fcntl getgrouplist pledge])
 
 AC_CHECK_FUNCS(setproctitle, ,
   [AC_CHECK_LIB(util, setproctitle, 
@@ -1138,6 +1161,13 @@ else
 fi
 AM_CONDITIONAL(OSPFD, test "x$OSPFD" = "xospfd")
 
+if test "${enable_ldpd}" = "yes";then
+  LDPD="ldpd"
+else
+  LDPD=""
+fi
+AM_CONDITIONAL(LDPD, test "x$LDPD" = "xldpd")
+
 if test "${enable_watchquagga}" = "no";then
   WATCHQUAGGA=""
 else
@@ -1193,6 +1223,7 @@ AC_SUBST(RIPD)
 AC_SUBST(RIPNGD)
 AC_SUBST(OSPFD)
 AC_SUBST(OSPF6D)
+AC_SUBST(LDPD)
 AC_SUBST(WATCHQUAGGA)
 AC_SUBST(ISISD)
 AC_SUBST(PIMD)
@@ -1339,6 +1370,32 @@ AC_TRY_COMPILE([#include <netinet/in.h>], [
   AC_MSG_RESULT(no)
 ])
 
+dnl ----------------------
+dnl checking for SO_BINDANY
+dnl ----------------------
+AC_MSG_CHECKING(for SO_BINDANY)
+AC_TRY_COMPILE([#include <sys/socket.h>], [
+  int opt = SO_BINDANY;
+], [
+  AC_MSG_RESULT(yes)
+  AC_DEFINE(HAVE_SO_BINDANY, 1, [Have SO_BINDANY])
+], [
+  AC_MSG_RESULT(no)
+])
+
+dnl ----------------------
+dnl checking for IP_FREEBIND
+dnl ----------------------
+AC_MSG_CHECKING(for IP_FREEBIND)
+AC_TRY_COMPILE([#include <linux/in.h>], [
+  int opt = IP_FREEBIND;
+], [
+  AC_MSG_RESULT(yes)
+  AC_DEFINE(HAVE_IP_FREEBIND, 1, [Have IP_FREEBIND])
+], [
+  AC_MSG_RESULT(no)
+])
+
 dnl --------------------------------------
 dnl checking for getrusage struct and call
 dnl --------------------------------------
@@ -1503,6 +1560,8 @@ AC_DEFINE_UNQUOTED(PATH_RIPNGD_PID, "$quagga_statedir/ripngd.pid",ripngd PID)
 AC_DEFINE_UNQUOTED(PATH_BGPD_PID, "$quagga_statedir/bgpd.pid",bgpd PID)
 AC_DEFINE_UNQUOTED(PATH_OSPFD_PID, "$quagga_statedir/ospfd.pid",ospfd PID)
 AC_DEFINE_UNQUOTED(PATH_OSPF6D_PID, "$quagga_statedir/ospf6d.pid",ospf6d PID)
+AC_DEFINE_UNQUOTED(PATH_LDPD_PID, "$quagga_statedir/ldpd.pid",ldpd PID)
+AC_DEFINE_UNQUOTED(LDPD_SOCKET, "$quagga_statedir/ldpd.sock",ldpd control socket)
 AC_DEFINE_UNQUOTED(PATH_ISISD_PID, "$quagga_statedir/isisd.pid",isisd PID)
 AC_DEFINE_UNQUOTED(PATH_PIMD_PID, "$quagga_statedir/pimd.pid",pimd PID)
 AC_DEFINE_UNQUOTED(PATH_WATCHQUAGGA_PID, "$quagga_statedir/watchquagga.pid",watchquagga PID)
@@ -1513,6 +1572,7 @@ AC_DEFINE_UNQUOTED(RIPNG_VTYSH_PATH, "$quagga_statedir/ripngd.vty",ripng vty soc
 AC_DEFINE_UNQUOTED(BGP_VTYSH_PATH, "$quagga_statedir/bgpd.vty",bgpd vty socket)
 AC_DEFINE_UNQUOTED(OSPF_VTYSH_PATH, "$quagga_statedir/ospfd.vty",ospfd vty socket)
 AC_DEFINE_UNQUOTED(OSPF6_VTYSH_PATH, "$quagga_statedir/ospf6d.vty",ospf6d vty socket)
+AC_DEFINE_UNQUOTED(LDP_VTYSH_PATH, "$quagga_statedir/ldpd.vty",ldpd vty socket)
 AC_DEFINE_UNQUOTED(ISIS_VTYSH_PATH, "$quagga_statedir/isisd.vty",isisd vty socket)
 AC_DEFINE_UNQUOTED(PIM_VTYSH_PATH, "$quagga_statedir/pimd.vty",pimd vty socket)
 AC_DEFINE_UNQUOTED(DAEMON_VTY_DIR, "$quagga_statedir",daemon vty directory)
@@ -1538,7 +1598,7 @@ AC_MSG_RESULT($ac_cv_htonl_works)
 
 AC_CONFIG_FILES([Makefile lib/Makefile zebra/Makefile ripd/Makefile 
 	  ripngd/Makefile bgpd/Makefile ospfd/Makefile watchquagga/Makefile
-	  ospf6d/Makefile isisd/Makefile vtysh/Makefile
+	  ospf6d/Makefile ldpd/Makefile isisd/Makefile vtysh/Makefile
 	  doc/Makefile ospfclient/Makefile tests/Makefile m4/Makefile
 	  pimd/Makefile
 	  tests/bgpd.tests/Makefile
diff --git a/doc/Makefile.am b/doc/Makefile.am
index 00d404a..7051c2a 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -87,6 +87,10 @@ if OSPFD
 man_MANS += ospfd.8
 endif
 
+if LDPD
+man_MANS += ldpd.8
+endif
+
 if RIPD
 man_MANS += ripd.8
 endif
@@ -108,7 +112,7 @@ man_MANS += zebra.8
 endif
 
 EXTRA_DIST = BGP-TypeCode draft-zebra-00.ms draft-zebra-00.txt \
-	bgpd.8 isisd.8 ospf6d.8 ospfclient.8 ospfd.8 ripd.8 \
+	bgpd.8 isisd.8 ospf6d.8 ospfclient.8 ospfd.8 ldpd.8 ripd.8 \
 	ripngd.8 pimd.8 vtysh.1 watchquagga.8 zebra.8 \
 	mpls/ChangeLog.opaque.txt mpls/cli_summary.txt \
 	mpls/opaque_lsa.txt mpls/ospfd.conf \
diff --git a/doc/ldpd-basic-test-setup.md b/doc/ldpd-basic-test-setup.md
new file mode 100644
index 0000000..d028348
--- /dev/null
+++ b/doc/ldpd-basic-test-setup.md
@@ -0,0 +1,582 @@
+## Topology
+
+The goal of this test is to verify that the all the basic functionality
+of ldpd is working as expected, be it running on Linux or OpenBSD. In
+addition to that, more advanced features are also tested, like LDP
+sessions over IPv6, MD5 authentication and pseudowire signaling.
+
+In the topology below there are 3 PE routers, 3 CE routers and one P
+router (not attached to any consumer site).
+
+All routers have IPv4 addresses and OSPF is used as the IGP. The
+three routers from the bottom of the picture, P, PE2 and PE3, are also
+configured for IPv6 (dual-stack) and static IPv6 routes are used to
+provide connectivity among them.
+
+The three CEs share the same VPLS membership. LDP is used to set up the
+LSPs among the PEs and to signal the pseudowires. MD5 authentication is
+used to protect all LDP sessions.
+
+```
+                          CE1 172.16.1.1/24
+                           +
+                           |
+                       +---+---+
+                       |  PE1  |
+                       | IOS XE|
+                       |       |
+                       +---+---+
+                           |
+                           | 10.0.1.0/24
+                           |
+                       +---+---+
+                       |   P   |
+                +------+ IOS XR+------+
+                |      |       |      |
+                |      +-------+      |
+    10.0.2.0/24 |                     | 10.0.3.0/24
+2001:db8:2::/64 |                     | 2001:db8:3::/64
+                |                     |
+            +---+---+             +---+---+
+            |  PE2  |             |  PE3  |
+            |OpenBSD+-------------+ Linux |
+            |       |             |       |
+            +---+---+ 10.0.4.0/24 +---+---+
+                |   2001:db8:4::/64   |
+                +                     +
+ 172.16.1.2/24 CE2                   CE3 172.16.1.3/24
+```
+
+
+## Configuration
+
+#### Linux
+1 - Enable IPv4/v6 forwarding:
+```
+# sysctl -w net.ipv4.ip_forward=1
+# sysctl -w net.ipv6.conf.all.forwarding=1
+```
+
+2 - Set up the interfaces:
+```
+# ip link add name lo1 type dummy
+# ip link set dev lo1 up
+# ip addr add 4.4.4.4/32 dev lo1
+# ip -6 addr add 4:4:4::4/128 dev lo1
+# ip link set dev eth1 up
+# ip addr add 10.0.4.4/24 dev eth1
+# ip -6 addr add 2001:db8:4::4/64 dev eth1
+# ip link set dev eth2 up
+# ip addr add 10.0.3.4/24 dev eth2
+# ip -6 addr add 2001:db8:3::4/64 dev eth2
+```
+
+3 - Set up the bridge and pseudowire interfaces:
+```
+# ip link add type bridge
+# ip link set dev bridge0 up
+# ip link set dev eth0 up
+# ip link set dev eth0 master bridge0
+# ip link add name mpw0 type dummy
+# ip link set dev mpw0 up
+# ip link set dev mpw0 master bridge0
+# ip link add name mpw1 type dummy
+# ip link set dev mpw1 up
+# ip link set dev mpw1 master bridge0
+```
+
+> NOTE: MPLS support in the Linux kernel is very recent and it still
+doesn't support pseudowire interfaces. We are using here dummy interfaces
+just to show how the VPLS configuration should looks like in the future.
+
+4 - Add static IPv6 routes for the remote loopbacks:
+```
+# ip -6 route add 2:2:2::2/128 via 2001:db8:3::2
+# ip -6 route add 3:3:3::3/128 via 2001:db8:4::3
+```
+
+5 - Edit /etc/quagga/ospfd.conf:
+```
+router ospf
+ network 4.4.4.4/32 area 0.0.0.0
+ network 10.0.3.4/24 area 0.0.0.0
+ network 10.0.4.4/24 area 0.0.0.0
+!
+```
+
+6 - Edit /etc/quagga/ldpd.conf:
+```
+mpls ldp
+ dual-stack cisco-interop
+ neighbor 1.1.1.1 password opensourcerouting
+ neighbor 2.2.2.2 password opensourcerouting
+ neighbor 3.3.3.3 password opensourcerouting
+ !
+ address-family ipv4
+  discovery transport-address 4.4.4.4
+  !
+  interface eth2
+  !
+  interface eth1
+  !
+ !
+ address-family ipv6
+  discovery transport-address 4:4:4::4
+  !
+  interface eth2
+  !
+  interface eth1
+  !
+ !
+!
+l2vpn ENG type vpls
+ bridge br0
+ member interface eth0
+ !
+ member pseudowire mpw0
+  neighbor lsr-id 1.1.1.1
+  pw-id 100
+ !
+ member pseudowire mpw1
+  neighbor lsr-id 3.3.3.3
+  neighbor address 3:3:3::3
+  pw-id 100
+ !
+!
+```
+
+> NOTE: Care should be taken when using the **label local advertise
+explicit-null** command under Linux. If the MPLS kernel module is not
+loaded, all packets arriving with the explicit-null label will be dropped,
+which can cause the LDP sessions to be torn down.
+
+7 - Run zebra, ospfd and ldpd.
+
+#### OpenBSD
+1 - Enable IPv4/v6 forwarding:
+```
+# sysctl net.inet.ip.forwarding=1
+# sysctl net.inet6.ip6.forwarding=1
+```
+
+2 - Set up the interfaces:
+```
+# ifconfig lo1 alias 3.3.3.3 netmask 255.255.255.255
+# ifconfig lo1 inet6 3:3:3::3/128
+# ifconfig em2 10.0.2.3/24 mpls
+# ifconfig em2 inet6 2001:db8:2::3/64
+# ifconfig em3 10.0.4.3/24 mpls
+# ifconfig em3 inet6 2001:db8:4::3/64
+```
+
+3 - Set up the bridge and pseudowire interfaces:
+```
+# ifconfig bridge0 create
+# ifconfig bridge0 up
+# ifconfig em1 up
+# ifconfig bridge0 add em1
+# ifconfig mpw0 create
+# ifconfig mpw0 up
+# ifconfig bridge0 add mpw0
+# ifconfig mpw1 create
+# ifconfig mpw1 up
+# ifconfig bridge0 add mpw1
+```
+
+4 - Add static IPv6 routes for the remote loopbacks:
+```
+# route -n add 4:4:4::4/128 2001:db8:4::4
+# route -n add 2:2:2::2/128 2001:db8:2::2
+```
+
+5 - Edit /etc/quagga/ospfd.conf:
+```
+router ospf
+ network 10.0.2.3/24 area 0
+ network 10.0.4.3/24 area 0
+ network 3.3.3.3/32 area 0
+!
+```
+
+6 - Edit /etc/quagga/ldpd.conf:
+```
+mpls ldp
+ dual-stack cisco-interop
+ neighbor 1.1.1.1 password opensourcerouting
+ neighbor 2.2.2.2 password opensourcerouting
+ neighbor 4.4.4.4 password opensourcerouting
+ !
+ address-family ipv4
+  discovery transport-address 3.3.3.3
+  !
+  interface em3
+  !
+  interface em2
+  !
+ !
+ address-family ipv6
+  discovery transport-address 3:3:3::3
+  !
+  interface em3
+  !
+  interface em2
+  !
+ !
+!
+l2vpn ENG type vpls
+ bridge br0
+ member interface em1
+ !
+ member pseudowire mpw0
+  neighbor lsr-id 1.1.1.1
+  pw-id 100
+ !
+ member pseudowire mpw1
+  neighbor lsr-id 4.4.4.4
+  neighbor address 4:4:4::4
+  pw-id 100
+ !
+!
+```
+
+7 - Run zebra, ospfd and ldpd.
+
+#### Cisco routers
+CE1 (IOS):
+```
+interface FastEthernet0/0
+ ip address 172.16.1.1 255.255.255.0
+ !
+!
+```
+
+CE2 (IOS):
+```
+interface FastEthernet0/0
+ ip address 172.16.1.2 255.255.255.0
+ !
+!
+```
+
+CE3 (IOS):
+```
+interface FastEthernet0/0
+ ip address 172.16.1.3 255.255.255.0
+ !
+!
+```
+
+PE1 - IOS-XE (1):
+```
+mpls ldp neighbor 2.2.2.2 password opensourcerouting
+mpls ldp neighbor 3.3.3.3 password opensourcerouting
+mpls ldp neighbor 4.4.4.4 password opensourcerouting
+!
+l2vpn vfi context VFI
+ vpn id 1
+ member pseudowire2
+ member pseudowire1
+!
+bridge-domain 1
+ member GigabitEthernet1 service-instance 1
+ member vfi VFI
+!
+interface Loopback1
+ ip address 1.1.1.1 255.255.255.255
+!
+interface pseudowire1
+ encapsulation mpls
+ neighbor 3.3.3.3 100
+!
+interface pseudowire2
+ encapsulation mpls
+ neighbor 4.4.4.4 100
+!
+interface GigabitEthernet3
+ ip address 10.0.1.1 255.255.255.0
+ mpls ip
+!
+router ospf 1
+ network 0.0.0.0 255.255.255.255 area 0
+!
+```
+
+P - IOS-XR (2):
+```
+interface Loopback1
+ ipv4 address 2.2.2.2 255.255.255.255
+ ipv6 address 2:2:2::2/128
+!
+interface GigabitEthernet0/0/0/0
+ ipv4 address 10.0.1.2 255.255.255.0
+!
+interface GigabitEthernet0/0/0/1
+ ipv4 address 10.0.2.2 255.255.255.0
+ ipv6 address 2001:db8:2::2/64
+ ipv6 enable
+!
+interface GigabitEthernet0/0/0/2
+ ipv4 address 10.0.3.2 255.255.255.0
+ ipv6 address 2001:db8:3::2/64
+ ipv6 enable
+!
+router static
+ address-family ipv6 unicast
+  3:3:3::3/128 2001:db8:2::3
+  4:4:4::4/128 2001:db8:3::4
+ !
+!
+router ospf 1
+ router-id 2.2.2.2
+ address-family ipv4 unicast
+ area 0
+  interface Loopback1
+  !
+  interface GigabitEthernet0/0/0/0
+  !
+  interface GigabitEthernet0/0/0/1
+  !
+  interface GigabitEthernet0/0/0/2
+  !
+ !
+!
+mpls ldp
+ router-id 2.2.2.2
+ neighbor
+  1.1.1.1:0 password clear opensourcerouting
+  3.3.3.3:0 password clear opensourcerouting
+  4.4.4.4:0 password clear opensourcerouting
+ !
+ address-family ipv4
+ !
+ address-family ipv6
+  discovery transport-address 2:2:2::2
+ !
+ interface GigabitEthernet0/0/0/0
+  address-family ipv4
+  !
+ !
+ interface GigabitEthernet0/0/0/1
+  address-family ipv4
+  !
+  address-family ipv6
+  !
+ !
+ interface GigabitEthernet0/0/0/2
+  address-family ipv4
+  !
+  address-family ipv6
+  !
+ !
+!
+```
+
+## Verification - Control Plane
+
+Using the CLI on the Linux box, the goal is to ensure that everything
+is working as expected.
+
+First, verify that all the required adjacencies and neighborships sessions
+were established:
+
+```
+linux# show mpls ldp discovery
+Local LDP Identifier: 4.4.4.4:0
+Discovery Sources:
+  Interfaces:
+    eth1: xmit/recv
+      LDP Id: 3.3.3.3:0, Transport address: 3.3.3.3
+          Hold time: 15 sec
+      LDP Id: 3.3.3.3:0, Transport address: 3:3:3::3
+          Hold time: 15 sec
+    eth2: xmit/recv
+      LDP Id: 2.2.2.2:0, Transport address: 2.2.2.2
+          Hold time: 15 sec
+      LDP Id: 2.2.2.2:0, Transport address: 2:2:2::2
+          Hold time: 15 sec
+  Targeted Hellos:
+    4.4.4.4 -> 1.1.1.1: xmit/recv
+      LDP Id: 1.1.1.1:0, Transport address: 1.1.1.1
+          Hold time: 45 sec
+    4:4:4::4 -> 3:3:3::3: xmit/recv
+      LDP Id: 3.3.3.3:0, Transport address: 3:3:3::3
+          Hold time: 45 sec
+
+linux# show mpls ldp neighbor
+Peer LDP Identifier: 1.1.1.1:0
+  TCP connection: 4.4.4.4:40921 - 1.1.1.1:646
+  Session Holdtime: 180 sec
+  State: OPERATIONAL; Downstream-Unsolicited
+  Up time: 00:06:02
+  LDP Discovery Sources:
+    IPv4:
+      Targeted Hello: 1.1.1.1
+
+Peer LDP Identifier: 2.2.2.2:0
+  TCP connection: 4:4:4::4:52286 - 2:2:2::2:646
+  Session Holdtime: 180 sec
+  State: OPERATIONAL; Downstream-Unsolicited
+  Up time: 00:06:02
+  LDP Discovery Sources:
+    IPv4:
+      Interface: eth2
+    IPv6:
+      Interface: eth2
+
+Peer LDP Identifier: 3.3.3.3:0
+  TCP connection: 4:4:4::4:60575 - 3:3:3::3:646
+  Session Holdtime: 180 sec
+  State: OPERATIONAL; Downstream-Unsolicited
+  Up time: 00:05:57
+  LDP Discovery Sources:
+    IPv4:
+      Interface: eth1
+    IPv6:
+      Targeted Hello: 3:3:3::3
+      Interface: eth1
+```
+
+Note that the neighborships with the P and PE2 routers were established
+over IPv6, since this is the default behavior for dual-stack LSRs, as
+specified in RFC 7552. If desired, the **dual-stack transport-connection
+prefer ipv4** command can be used to establish these sessions over IPv4
+(the command should be applied an all routers).
+
+Now, verify that there's a remote label for each PE address:
+```
+linux# show mpls ldp binding
+1.1.1.1/32
+        Local binding: label: 20
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            1.1.1.1             imp-null
+            2.2.2.2             24000
+            3.3.3.3             20
+2.2.2.2/32
+        Local binding: label: 21
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            1.1.1.1             18
+            2.2.2.2             imp-null
+            3.3.3.3             21
+3.3.3.3/32
+        Local binding: label: 22
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            1.1.1.1             21
+            2.2.2.2             24003
+            3.3.3.3             imp-null
+4.4.4.4/32
+        Local binding: label: imp-null
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            1.1.1.1             22
+            2.2.2.2             24001
+            3.3.3.3             22
+10.0.1.0/24
+        Local binding: label: 23
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            1.1.1.1             imp-null
+            2.2.2.2             imp-null
+            3.3.3.3             23
+10.0.2.0/24
+        Local binding: label: 24
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            1.1.1.1             20
+            2.2.2.2             imp-null
+            3.3.3.3             imp-null
+10.0.3.0/24
+        Local binding: label: imp-null
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            1.1.1.1             19
+            2.2.2.2             imp-null
+            3.3.3.3             24
+10.0.4.0/24
+        Local binding: label: imp-null
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            1.1.1.1             23
+            2.2.2.2             24002
+            3.3.3.3             imp-null
+2:2:2::2/128
+        Local binding: label: 18
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            2.2.2.2             imp-null
+            3.3.3.3             18
+3:3:3::3/128
+        Local binding: label: 19
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            2.2.2.2             24007
+4:4:4::4/128
+        Local binding: label: imp-null
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            2.2.2.2             24006
+            3.3.3.3             19
+2001:db8:2::/64
+        Local binding: label: -
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            2.2.2.2             imp-null
+            3.3.3.3             imp-null
+2001:db8:3::/64
+        Local binding: label: imp-null
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            2.2.2.2             imp-null
+2001:db8:4::/64
+        Local binding: label: imp-null
+        Remote bindings:
+            Peer                Label
+            -----------------   ---------
+            3.3.3.3             imp-null
+```
+
+Check if the pseudowires are up:
+```
+linux# show l2vpn atom vc
+Interface Peer ID         VC ID      Name             Status
+--------- --------------- ---------- ---------------- ----------
+mpw1      3.3.3.3         100        ENG              UP
+mpw0      1.1.1.1         100        ENG              UP
+```
+
+Check the label bindings of the pseudowires:
+```
+linux# show l2vpn atom binding
+  Destination Address: 1.1.1.1, VC ID: 100
+    Local Label:  25
+        Cbit: 1,    VC Type: Ethernet,    GroupID: 0
+        MTU: 1500
+    Remote Label:  16
+        Cbit: 1,    VC Type: Ethernet,    GroupID: 0
+        MTU: 1500
+  Destination Address: 3.3.3.3, VC ID: 100
+    Local Label:  26
+        Cbit: 1,    VC Type: Ethernet,    GroupID: 0
+        MTU: 1500
+    Remote Label:  26
+        Cbit: 1,    VC Type: Ethernet,    GroupID: 0
+        MTU: 1500
+```
+
+## Verification - Data Plane
+TODO - MPLS support in zebra is not implemented yet.
diff --git a/doc/ldpd.8 b/doc/ldpd.8
new file mode 100644
index 0000000..092ff39
--- /dev/null
+++ b/doc/ldpd.8
@@ -0,0 +1,109 @@
+.TH LDPD 8 "29 March 2016" "Quagga LDP daemon" "Version 1.0.20160309"
+.SH NAME
+ldpd \- an LDP engine for use with Quagga routing software.
+.SH SYNOPSIS
+.B ldpd
+[
+.B \-dhv
+] [
+.B \-f
+.I config-file
+] [
+.B \-i
+.I pid-file
+] [
+.B \-P
+.I port-number
+] [
+.B \-A
+.I vty-address
+] [
+.B \-u
+.I user
+] [
+.B \-g
+.I group
+]
+.SH DESCRIPTION
+.B ldpd
+is a component that works with the
+.B Quagga
+routing engine.
+.SH OPTIONS
+Options available for the
+.B ldpd
+command:
+.TP
+\fB\-d\fR, \fB\-\-daemon\fR
+Runs in daemon mode, forking and exiting from tty.
+.TP
+\fB\-f\fR, \fB\-\-config-file \fR\fIconfig-file\fR 
+Specifies the config file to use for startup. If not specified this
+option will likely default to \fB\fI/usr/local/etc/ldpd.conf\fR.
+.TP
+\fB\-g\fR, \fB\-\-group \fR\fIgroup\fR
+Specify the group to run as. Default is \fIquagga\fR.
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+A brief message.
+.TP
+\fB\-i\fR, \fB\-\-pid_file \fR\fIpid-file\fR
+When ldpd starts its process identifier is written to
+\fB\fIpid-file\fR.  The init system uses the recorded PID to stop or
+restart ldpd.  The likely default is \fB\fI/var/run/ldpd.pid\fR.
+.TP
+\fB\-P\fR, \fB\-\-vty_port \fR\fIport-number\fR 
+Specify the port that the ldpd VTY will listen on. This defaults to
+2612, as specified in \fB\fI/etc/services\fR.
+.TP
+\fB\-A\fR, \fB\-\-vty_addr \fR\fIvty-address\fR
+Specify the address that the ldpd VTY will listen on. Default is all
+interfaces.
+.TP
+\fB\-u\fR, \fB\-\-user \fR\fIuser\fR
+Specify the user to run as. Default is \fIquagga\fR.
+.TP
+\fB\-v\fR, \fB\-\-version\fR
+Print the version and exit.
+.SH FILES
+.TP
+.BI /usr/local/sbin/ldpd
+The default location of the 
+.B ldpd
+binary.
+.TP
+.BI /usr/local/etc/ldpd.conf
+The default location of the 
+.B ldpd
+config file.
+.TP
+.BI $(PWD)/ldpd.log 
+If the 
+.B ldpd
+process is config'd to output logs to a file, then you will find this
+file in the directory where you started \fBldpd\fR.
+.SH WARNING
+This man page is intended to be a quick reference for command line
+options. The definitive document is the Info file \fBQuagga\fR.
+.SH DIAGNOSTICS
+The ldpd process may log to standard output, to a VTY, to a log
+file, or through syslog to the system logs. \fBldpd\fR supports many
+debugging options, see the Info file, or the source for details.
+.SH "SEE ALSO"
+.BR bgpd (8),
+.BR ripd (8),
+.BR ripngd (8),
+.BR ospfd (8),
+.BR ospf6d (8),
+.BR isisd (8),
+.BR zebra (8),
+.BR vtysh (1)
+.SH BUGS
+.B ldpd
+eats bugs for breakfast. If you have food for the maintainers try
+.BI http://bugzilla.quagga.net
+.SH AUTHORS
+See
+.BI http://www.quagga.net
+or the Info file for an accurate list of authors.
+
diff --git a/ldpd/.gitignore b/ldpd/.gitignore
new file mode 100644
index 0000000..be90d42
--- /dev/null
+++ b/ldpd/.gitignore
@@ -0,0 +1,18 @@
+Makefile
+Makefile.in
+*.o
+ldpd
+ldpd.conf
+tags
+TAGS
+.deps
+.nfs*
+*.lo
+*.la
+*.a
+*.libs
+.arch-inventory
+.arch-ids
+*~
+*.loT
+
diff --git a/ldpd/Makefile.am b/ldpd/Makefile.am
new file mode 100644
index 0000000..97c7abc
--- /dev/null
+++ b/ldpd/Makefile.am
@@ -0,0 +1,25 @@
+## Process this file with automake to produce Makefile.in.
+
+AM_CPPFLAGS = -I.. -I$(top_srcdir) -I$(top_srcdir)/lib -I$(top_builddir)/lib
+DEFS = @DEFS@ -DSYSCONFDIR=\"$(sysconfdir)/\"
+INSTALL_SDATA=@INSTALL@ -m 600
+
+AM_CFLAGS = $(WERROR)
+
+noinst_LIBRARIES = libldp.a
+sbin_PROGRAMS = ldpd
+
+libldp_a_SOURCES = \
+	accept.c address.c adjacency.c control.c hello.c init.c interface.c \
+	keepalive.c l2vpn.c labelmapping.c lde.c lde_lib.c ldpd.c \
+	ldpe.c log.c neighbor.c notification.c packet.c pfkey.c \
+	socket.c util.c ldp_vty_cmds.c ldp_vty_conf.c ldp_vty_exec.c ldp_zebra.c
+
+noinst_HEADERS = \
+	control.h lde.h ldpd.h ldpe.h ldp.h log.h ldp_vty.h
+
+ldpd_SOURCES = ldpd.c
+ldpd_LDADD = libldp.a ../lib/libzebra.la @LIBCAP@
+
+examplesdir = $(exampledir)
+dist_examples_DATA = ldpd.conf.sample
diff --git a/ldpd/accept.c b/ldpd/accept.c
new file mode 100644
index 0000000..4cb461b
--- /dev/null
+++ b/ldpd/accept.c
@@ -0,0 +1,136 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2012 Claudio Jeker <claudio@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+
+struct accept_ev {
+	LIST_ENTRY(accept_ev)	 entry;
+	struct thread		*ev;
+	int			(*accept_cb)(struct thread *);
+	void			*arg;
+	int			 fd;
+};
+
+struct {
+	LIST_HEAD(, accept_ev)	 queue;
+	struct thread		*evt;
+} accept_queue;
+
+static void	accept_arm(void);
+static void	accept_unarm(void);
+static int	accept_cb(struct thread *);
+static int	accept_timeout(struct thread *);
+
+void
+accept_init(void)
+{
+	LIST_INIT(&accept_queue.queue);
+}
+
+int
+accept_add(int fd, int (*cb)(struct thread *), void *arg)
+{
+	struct accept_ev	*av;
+
+	if ((av = calloc(1, sizeof(*av))) == NULL)
+		return (-1);
+	av->fd = fd;
+	av->accept_cb = cb;
+	av->arg = arg;
+	LIST_INSERT_HEAD(&accept_queue.queue, av, entry);
+
+	av->ev = thread_add_read(master, accept_cb, av, av->fd);
+
+	log_debug("%s: accepting on fd %d", __func__, fd);
+
+	return (0);
+}
+
+void
+accept_del(int fd)
+{
+	struct accept_ev	*av;
+
+	LIST_FOREACH(av, &accept_queue.queue, entry)
+		if (av->fd == fd) {
+			log_debug("%s: %d removed from queue", __func__, fd);
+			THREAD_READ_OFF(av->ev);
+			LIST_REMOVE(av, entry);
+			free(av);
+			return;
+		}
+}
+
+void
+accept_pause(void)
+{
+	log_debug(__func__);
+	accept_unarm();
+	accept_queue.evt = thread_add_timer(master, accept_timeout, NULL, 1);
+}
+
+void
+accept_unpause(void)
+{
+	if (accept_queue.evt != NULL) {
+		log_debug(__func__);
+		THREAD_TIMER_OFF(accept_queue.evt);
+		accept_arm();
+	}
+}
+
+static void
+accept_arm(void)
+{
+	struct accept_ev	*av;
+	LIST_FOREACH(av, &accept_queue.queue, entry)
+		av->ev = thread_add_read(master, accept_cb, av, av->fd);
+}
+
+static void
+accept_unarm(void)
+{
+	struct accept_ev	*av;
+	LIST_FOREACH(av, &accept_queue.queue, entry)
+		THREAD_READ_OFF(av->ev);
+}
+
+static int
+accept_cb(struct thread *thread)
+{
+	struct accept_ev	*av = THREAD_ARG(thread);
+	av->ev = thread_add_read(master, accept_cb, av, av->fd);
+	av->accept_cb(thread);
+
+	return (0);
+}
+
+static int
+accept_timeout(struct thread *thread)
+{
+	accept_queue.evt = NULL;
+
+	log_debug(__func__);
+	accept_arm();
+
+	return (0);
+}
diff --git a/ldpd/address.c b/ldpd/address.c
new file mode 100644
index 0000000..80c383f
--- /dev/null
+++ b/ldpd/address.c
@@ -0,0 +1,202 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "lde.h"
+#include "log.h"
+
+static void	gen_address_list_tlv(struct ibuf *, uint16_t, int,
+		    struct if_addr *);
+
+void
+send_address(struct nbr *nbr, int af, struct if_addr *if_addr, int withdraw)
+{
+	struct ibuf	*buf;
+	uint32_t	 msg_type;
+	uint16_t	 size;
+	int		 iface_count = 0;
+
+	if (!withdraw)
+		msg_type = MSG_TYPE_ADDR;
+	else
+		msg_type = MSG_TYPE_ADDRWITHDRAW;
+
+	if (if_addr == NULL) {
+		LIST_FOREACH(if_addr, &global.addr_list, entry)
+			if (if_addr->af == af)
+				iface_count++;
+	} else
+		iface_count = 1;
+
+	size = LDP_HDR_SIZE + LDP_MSG_SIZE + sizeof(struct address_list_tlv);
+	switch (af) {
+	case AF_INET:
+		size += iface_count * sizeof(struct in_addr);
+		break;
+	case AF_INET6:
+		size += iface_count * sizeof(struct in6_addr);
+		break;
+	default:
+		fatalx("send_address: unknown af");
+	}
+
+	if ((buf = ibuf_open(size)) == NULL)
+		fatal(__func__);
+
+	gen_ldp_hdr(buf, size);
+	size -= LDP_HDR_SIZE;
+	gen_msg_hdr(buf, msg_type, size);
+	size -= LDP_MSG_SIZE;
+	gen_address_list_tlv(buf, size, af, if_addr);
+
+	evbuf_enqueue(&nbr->tcp->wbuf, buf);
+
+	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
+}
+
+int
+recv_address(struct nbr *nbr, char *buf, uint16_t len)
+{
+	struct ldp_msg		addr;
+	struct address_list_tlv	alt;
+	enum imsg_type		type;
+	struct lde_addr		lde_addr;
+
+	memcpy(&addr, buf, sizeof(addr));
+	buf += LDP_MSG_SIZE;
+	len -= LDP_MSG_SIZE;
+
+	/* Address List TLV */
+	if (len < sizeof(alt)) {
+		session_shutdown(nbr, S_BAD_MSG_LEN, addr.msgid, addr.type);
+		return (-1);
+	}
+
+	memcpy(&alt, buf, sizeof(alt));
+	if (ntohs(alt.length) != len - TLV_HDR_LEN) {
+		session_shutdown(nbr, S_BAD_TLV_LEN, addr.msgid, addr.type);
+		return (-1);
+	}
+	if (ntohs(alt.type) != TLV_TYPE_ADDRLIST) {
+		session_shutdown(nbr, S_UNKNOWN_TLV, addr.msgid, addr.type);
+		return (-1);
+	}
+	switch (ntohs(alt.family)) {
+	case AF_IPV4:
+		if (!nbr->v4_enabled)
+			/* just ignore the message */
+			return (0);
+		break;
+	case AF_IPV6:
+		if (!nbr->v6_enabled)
+			/* just ignore the message */
+			return (0);
+		break;
+	default:
+		send_notification_nbr(nbr, S_UNSUP_ADDR, addr.msgid, addr.type);
+		return (-1);
+	}
+	buf += sizeof(alt);
+	len -= sizeof(alt);
+
+	if (ntohs(addr.type) == MSG_TYPE_ADDR)
+		type = IMSG_ADDRESS_ADD;
+	else
+		type = IMSG_ADDRESS_DEL;
+
+	while (len > 0) {
+		switch (ntohs(alt.family)) {
+		case AF_IPV4:
+			if (len < sizeof(struct in_addr)) {
+				session_shutdown(nbr, S_BAD_TLV_LEN, addr.msgid,
+				    addr.type);
+				return (-1);
+			}
+
+			memset(&lde_addr, 0, sizeof(lde_addr));
+			lde_addr.af = AF_INET;
+			memcpy(&lde_addr.addr, buf, sizeof(struct in_addr));
+
+			buf += sizeof(struct in_addr);
+			len -= sizeof(struct in_addr);
+			break;
+		case AF_IPV6:
+			if (len < sizeof(struct in6_addr)) {
+				session_shutdown(nbr, S_BAD_TLV_LEN, addr.msgid,
+				    addr.type);
+				return (-1);
+			}
+
+			memset(&lde_addr, 0, sizeof(lde_addr));
+			lde_addr.af = AF_INET6;
+			memcpy(&lde_addr.addr, buf, sizeof(struct in6_addr));
+
+			buf += sizeof(struct in6_addr);
+			len -= sizeof(struct in6_addr);
+			break;
+		default:
+			fatalx("recv_address: unknown af");
+		}
+
+		log_debug("%s: neighbor ID %s address %s%s", __func__,
+		    inet_ntoa(nbr->id), log_addr(lde_addr.af, &lde_addr.addr),
+		    ntohs(addr.type) == MSG_TYPE_ADDR ? "" : " (withdraw)");
+
+		ldpe_imsg_compose_lde(type, nbr->peerid, 0, &lde_addr,
+		    sizeof(lde_addr));
+	}
+
+	return (0);
+}
+
+static void
+gen_address_list_tlv(struct ibuf *buf, uint16_t size, int af,
+    struct if_addr *if_addr)
+{
+	struct address_list_tlv	 alt;
+	uint16_t		 addr_size;
+
+	memset(&alt, 0, sizeof(alt));
+	alt.type = TLV_TYPE_ADDRLIST;
+	alt.length = htons(size - TLV_HDR_LEN);
+	switch (af) {
+	case AF_INET:
+		alt.family = htons(AF_IPV4);
+		addr_size = sizeof(struct in_addr);
+		break;
+	case AF_INET6:
+		alt.family = htons(AF_IPV6);
+		addr_size = sizeof(struct in6_addr);
+		break;
+	default:
+		fatalx("gen_address_list_tlv: unknown af");
+	}
+
+	ibuf_add(buf, &alt, sizeof(alt));
+
+	if (if_addr == NULL) {
+		LIST_FOREACH(if_addr, &global.addr_list, entry) {
+			if (if_addr->af == af)
+				ibuf_add(buf, &if_addr->addr, addr_size);
+		}
+	} else
+		ibuf_add(buf, &if_addr->addr, addr_size);
+}
diff --git a/ldpd/adjacency.c b/ldpd/adjacency.c
new file mode 100644
index 0000000..1c23153
--- /dev/null
+++ b/ldpd/adjacency.c
@@ -0,0 +1,329 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2015 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ * Copyright (c) 2005 Claudio Jeker <claudio@openbsd.org>
+ * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+
+static int	 adj_itimer(struct thread *);
+static void	 tnbr_del(struct tnbr *);
+static int	 tnbr_hello_timer(struct thread *);
+static void	 tnbr_start_hello_timer(struct tnbr *);
+static void	 tnbr_stop_hello_timer(struct tnbr *);
+
+struct adj *
+adj_new(struct in_addr lsr_id, struct hello_source *source,
+    union ldpd_addr *addr)
+{
+	struct adj	*adj;
+
+	log_debug("%s: lsr-id %s, %s", __func__, inet_ntoa(lsr_id),
+	    log_hello_src(source));
+
+	if ((adj = calloc(1, sizeof(*adj))) == NULL)
+		fatal(__func__);
+
+	adj->lsr_id = lsr_id;
+	adj->nbr = NULL;
+	adj->source = *source;
+	adj->trans_addr = *addr;
+
+	LIST_INSERT_HEAD(&global.adj_list, adj, global_entry);
+
+	switch (source->type) {
+	case HELLO_LINK:
+		LIST_INSERT_HEAD(&source->link.ia->adj_list, adj, ia_entry);
+		break;
+	case HELLO_TARGETED:
+		source->target->adj = adj;
+		break;
+	}
+
+	return (adj);
+}
+
+void
+adj_del(struct adj *adj)
+{
+	log_debug("%s: lsr-id %s, %s", __func__, inet_ntoa(adj->lsr_id),
+	    log_hello_src(&adj->source));
+
+	adj_stop_itimer(adj);
+
+	LIST_REMOVE(adj, global_entry);
+	if (adj->nbr)
+		LIST_REMOVE(adj, nbr_entry);
+	if (adj->source.type == HELLO_LINK)
+		LIST_REMOVE(adj, ia_entry);
+
+	/* last adjacency deleted */
+	if (adj->nbr && LIST_EMPTY(&adj->nbr->adj_list))
+		nbr_del(adj->nbr);
+
+	free(adj);
+}
+
+struct adj *
+adj_find(struct hello_source *source)
+{
+	struct adj *adj;
+
+	LIST_FOREACH(adj, &global.adj_list, global_entry) {
+		if (adj->source.type != source->type)
+			continue;
+
+		switch (source->type) {
+		case HELLO_LINK:
+			if (ldp_addrcmp(source->link.ia->af,
+			    &adj->source.link.src_addr,
+			    &source->link.src_addr) == 0)
+				return (adj);
+			break;
+		case HELLO_TARGETED:
+			if (adj->source.target == source->target)
+				return (adj);
+			break;
+		}
+	}
+
+	return (NULL);
+}
+
+int
+adj_get_af(struct adj *adj)
+{
+	switch (adj->source.type) {
+	case HELLO_LINK:
+		return (adj->source.link.ia->af);
+	case HELLO_TARGETED:
+		return (adj->source.target->af);
+	default:
+		fatalx("adj_get_af: unknown hello type");
+	}
+}
+
+/* adjacency timers */
+
+/* ARGSUSED */
+static int
+adj_itimer(struct thread *thread)
+{
+	struct adj *adj = THREAD_ARG(thread);
+
+	adj->inactivity_timer = NULL;
+
+	log_debug("%s: lsr-id %s", __func__, inet_ntoa(adj->lsr_id));
+
+	if (adj->source.type == HELLO_TARGETED) {
+		if (!(adj->source.target->flags & F_TNBR_CONFIGURED) &&
+		    adj->source.target->pw_count == 0) {
+			/* remove dynamic targeted neighbor */
+			tnbr_del(adj->source.target);
+			return (0);
+		}
+		adj->source.target->adj = NULL;
+	}
+
+	adj_del(adj);
+
+	return (0);
+}
+
+void
+adj_start_itimer(struct adj *adj)
+{
+	THREAD_TIMER_OFF(adj->inactivity_timer);
+	adj->inactivity_timer = thread_add_timer(master, adj_itimer, adj,
+	    adj->holdtime);
+}
+
+void
+adj_stop_itimer(struct adj *adj)
+{
+	THREAD_TIMER_OFF(adj->inactivity_timer);
+}
+
+/* targeted neighbors */
+
+struct tnbr *
+tnbr_new(int af, union ldpd_addr *addr)
+{
+	struct tnbr		*tnbr;
+
+	if ((tnbr = calloc(1, sizeof(*tnbr))) == NULL)
+		fatal(__func__);
+
+	tnbr->af = af;
+	tnbr->addr = *addr;
+	tnbr->state = TNBR_STA_DOWN;
+
+	return (tnbr);
+}
+
+static void
+tnbr_del(struct tnbr *tnbr)
+{
+	tnbr_stop_hello_timer(tnbr);
+	if (tnbr->adj)
+		adj_del(tnbr->adj);
+	LIST_REMOVE(tnbr, entry);
+	free(tnbr);
+}
+
+struct tnbr *
+tnbr_find(struct ldpd_conf *xconf, int af, union ldpd_addr *addr)
+{
+	struct tnbr *tnbr;
+
+	LIST_FOREACH(tnbr, &xconf->tnbr_list, entry)
+		if (af == tnbr->af &&
+		    ldp_addrcmp(af, addr, &tnbr->addr) == 0)
+			return (tnbr);
+
+	return (NULL);
+}
+
+struct tnbr *
+tnbr_check(struct tnbr *tnbr)
+{
+	if (!(tnbr->flags & (F_TNBR_CONFIGURED|F_TNBR_DYNAMIC)) &&
+	    tnbr->pw_count == 0) {
+		tnbr_del(tnbr);
+		return (NULL);
+	}
+
+	return (tnbr);
+}
+
+void
+tnbr_update(struct tnbr *tnbr)
+{
+	int			 socket_ok, rtr_id_ok;
+
+	if ((ldp_af_global_get(&global, tnbr->af))->ldp_edisc_socket != -1)
+		socket_ok = 1;
+	else
+		socket_ok = 0;
+
+	if (ldp_rtr_id_get(leconf) != INADDR_ANY)
+		rtr_id_ok = 1;
+	else
+		rtr_id_ok = 0;
+
+	if (tnbr->state == TNBR_STA_DOWN) {
+		if (!socket_ok || !rtr_id_ok)
+			return;
+
+		tnbr->state = TNBR_STA_ACTIVE;
+		send_hello(HELLO_TARGETED, NULL, tnbr);
+
+		tnbr_start_hello_timer(tnbr);
+	} else if (tnbr->state == TNBR_STA_ACTIVE) {
+		if (socket_ok && rtr_id_ok)
+			return;
+
+		tnbr->state = TNBR_STA_DOWN;
+		tnbr_stop_hello_timer(tnbr);
+	}
+}
+
+void
+tnbr_update_all(int af)
+{
+	struct tnbr		*tnbr;
+
+	/* update targeted neighbors */
+	LIST_FOREACH(tnbr, &leconf->tnbr_list, entry)
+		if (tnbr->af == af || af == AF_UNSPEC)
+			tnbr_update(tnbr);
+}
+
+uint16_t
+tnbr_get_hello_holdtime(struct tnbr *tnbr)
+{
+	if ((ldp_af_conf_get(leconf, tnbr->af))->thello_holdtime != 0)
+		return ((ldp_af_conf_get(leconf, tnbr->af))->thello_holdtime);
+
+	return (leconf->thello_holdtime);
+}
+
+uint16_t
+tnbr_get_hello_interval(struct tnbr *tnbr)
+{
+	if ((ldp_af_conf_get(leconf, tnbr->af))->thello_interval != 0)
+		return ((ldp_af_conf_get(leconf, tnbr->af))->thello_interval);
+
+	return (leconf->thello_interval);
+}
+
+/* target neighbors timers */
+
+/* ARGSUSED */
+static int
+tnbr_hello_timer(struct thread *thread)
+{
+	struct tnbr	*tnbr = THREAD_ARG(thread);
+
+	tnbr->hello_timer = NULL;
+	send_hello(HELLO_TARGETED, NULL, tnbr);
+	tnbr_start_hello_timer(tnbr);
+
+	return (0);
+}
+
+static void
+tnbr_start_hello_timer(struct tnbr *tnbr)
+{
+	THREAD_TIMER_OFF(tnbr->hello_timer);
+	tnbr->hello_timer = thread_add_timer(master, tnbr_hello_timer, tnbr,
+	    tnbr_get_hello_interval(tnbr));
+}
+
+static void
+tnbr_stop_hello_timer(struct tnbr *tnbr)
+{
+	THREAD_TIMER_OFF(tnbr->hello_timer);
+}
+
+struct ctl_adj *
+adj_to_ctl(struct adj *adj)
+{
+	static struct ctl_adj	 actl;
+
+	actl.af = adj_get_af(adj);
+	actl.id = adj->lsr_id;
+	actl.type = adj->source.type;
+	switch (adj->source.type) {
+	case HELLO_LINK:
+		memcpy(actl.ifname, adj->source.link.ia->iface->name,
+		    sizeof(actl.ifname));
+		break;
+	case HELLO_TARGETED:
+		actl.src_addr = adj->source.target->addr;
+		break;
+	}
+	actl.holdtime = adj->holdtime;
+	actl.trans_addr = adj->trans_addr;
+
+	return (&actl);
+}
diff --git a/ldpd/control.c b/ldpd/control.c
new file mode 100644
index 0000000..4360584
--- /dev/null
+++ b/ldpd/control.c
@@ -0,0 +1,286 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+#include <sys/un.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+#include "control.h"
+
+#define	CONTROL_BACKLOG	5
+
+static int		 control_accept(struct thread *);
+static struct ctl_conn	*control_connbyfd(int);
+static struct ctl_conn	*control_connbypid(pid_t);
+static void		 control_close(int);
+static int		 control_dispatch_imsg(struct thread *);
+
+struct ctl_conns	 ctl_conns;
+
+static int		 control_fd;
+
+int
+control_init(void)
+{
+	struct sockaddr_un	 s_un;
+	int			 fd;
+	mode_t			 old_umask;
+
+	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
+		log_warn("%s: socket", __func__);
+		return (-1);
+	}
+	sock_set_blockmode(fd, BM_NONBLOCK);
+
+	memset(&s_un, 0, sizeof(s_un));
+	s_un.sun_family = AF_UNIX;
+	strlcpy(s_un.sun_path, LDPD_SOCKET, sizeof(s_un.sun_path));
+
+	if (unlink(LDPD_SOCKET) == -1)
+		if (errno != ENOENT) {
+			log_warn("%s: unlink %s", __func__, LDPD_SOCKET);
+			close(fd);
+			return (-1);
+		}
+
+	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
+	if (bind(fd, (struct sockaddr *)&s_un, sizeof(s_un)) == -1) {
+		log_warn("%s: bind: %s", __func__, LDPD_SOCKET);
+		close(fd);
+		umask(old_umask);
+		return (-1);
+	}
+	umask(old_umask);
+
+	if (chmod(LDPD_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
+		log_warn("%s: chmod", __func__);
+		close(fd);
+		(void)unlink(LDPD_SOCKET);
+		return (-1);
+	}
+
+	control_fd = fd;
+
+	return (0);
+}
+
+int
+control_listen(void)
+{
+	if (listen(control_fd, CONTROL_BACKLOG) == -1) {
+		log_warn("%s: listen", __func__);
+		return (-1);
+	}
+
+	return (accept_add(control_fd, control_accept, NULL));
+}
+
+void
+control_cleanup(void)
+{
+	accept_del(control_fd);
+	close(control_fd);
+	unlink(LDPD_SOCKET);
+}
+
+/* ARGSUSED */
+static int
+control_accept(struct thread *thread)
+{
+	int			 connfd;
+	socklen_t		 len;
+	struct sockaddr_un	 s_un;
+	struct ctl_conn		*c;
+
+	len = sizeof(s_un);
+	if ((connfd = accept(THREAD_FD(thread), (struct sockaddr *)&s_un,
+	    &len)) == -1) {
+		/*
+		 * Pause accept if we are out of file descriptors, or
+		 * libevent will haunt us here too.
+		 */
+		if (errno == ENFILE || errno == EMFILE)
+			accept_pause();
+		else if (errno != EWOULDBLOCK && errno != EINTR &&
+		    errno != ECONNABORTED)
+			log_warn("%s: accept", __func__);
+		return (0);
+	}
+	sock_set_blockmode(connfd, BM_NONBLOCK);
+
+	if ((c = calloc(1, sizeof(struct ctl_conn))) == NULL) {
+		log_warn(__func__);
+		close(connfd);
+		return (0);
+	}
+
+	imsg_init(&c->iev.ibuf, connfd);
+	c->iev.handler_read = control_dispatch_imsg;
+	c->iev.ev_read = thread_add_read(master, c->iev.handler_read,
+	    &c->iev, c->iev.ibuf.fd);
+	c->iev.handler_write = ldp_write_handler;
+	c->iev.ev_write = NULL;
+
+	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
+
+	return (0);
+}
+
+static struct ctl_conn *
+control_connbyfd(int fd)
+{
+	struct ctl_conn	*c;
+
+	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.fd != fd;
+	    c = TAILQ_NEXT(c, entry))
+		;	/* nothing */
+
+	return (c);
+}
+
+static struct ctl_conn *
+control_connbypid(pid_t pid)
+{
+	struct ctl_conn	*c;
+
+	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.pid != pid;
+	    c = TAILQ_NEXT(c, entry))
+		;	/* nothing */
+
+	return (c);
+}
+
+static void
+control_close(int fd)
+{
+	struct ctl_conn	*c;
+
+	if ((c = control_connbyfd(fd)) == NULL) {
+		log_warnx("%s: fd %d: not found", __func__, fd);
+		return;
+	}
+
+	msgbuf_clear(&c->iev.ibuf.w);
+	TAILQ_REMOVE(&ctl_conns, c, entry);
+
+	THREAD_READ_OFF(c->iev.ev_read);
+	THREAD_WRITE_OFF(c->iev.ev_write);
+	close(c->iev.ibuf.fd);
+	accept_unpause();
+	free(c);
+}
+
+/* ARGSUSED */
+static int
+control_dispatch_imsg(struct thread *thread)
+{
+	int		 fd = THREAD_FD(thread);
+	struct ctl_conn	*c;
+	struct imsg	 imsg;
+	ssize_t		 n;
+	unsigned int	 ifidx;
+
+	if ((c = control_connbyfd(fd)) == NULL) {
+		log_warnx("%s: fd %d: not found", __func__, fd);
+		return (0);
+	}
+
+	c->iev.ev_read = NULL;
+
+	if (((n = imsg_read(&c->iev.ibuf)) == -1 && errno != EAGAIN) ||
+	    n == 0) {
+		control_close(fd);
+		return (0);
+	}
+
+	for (;;) {
+		if ((n = imsg_get(&c->iev.ibuf, &imsg)) == -1) {
+			control_close(fd);
+			return (0);
+		}
+
+		if (n == 0)
+			break;
+
+		switch (imsg.hdr.type) {
+		case IMSG_CTL_FIB_COUPLE:
+		case IMSG_CTL_FIB_DECOUPLE:
+		case IMSG_CTL_RELOAD:
+		case IMSG_CTL_KROUTE:
+		case IMSG_CTL_KROUTE_ADDR:
+		case IMSG_CTL_IFINFO:
+			/* ignore */
+			break;
+		case IMSG_CTL_SHOW_INTERFACE:
+			if (imsg.hdr.len == IMSG_HEADER_SIZE +
+			    sizeof(ifidx)) {
+				memcpy(&ifidx, imsg.data, sizeof(ifidx));
+				ldpe_iface_ctl(c, ifidx);
+				imsg_compose_event(&c->iev, IMSG_CTL_END, 0,
+				    0, -1, NULL, 0);
+			}
+			break;
+		case IMSG_CTL_SHOW_DISCOVERY:
+			ldpe_adj_ctl(c);
+			break;
+		case IMSG_CTL_SHOW_LIB:
+		case IMSG_CTL_SHOW_L2VPN_PW:
+		case IMSG_CTL_SHOW_L2VPN_BINDING:
+			c->iev.ibuf.pid = imsg.hdr.pid;
+			ldpe_imsg_compose_lde(imsg.hdr.type, 0, imsg.hdr.pid,
+			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
+			break;
+		case IMSG_CTL_SHOW_NBR:
+			ldpe_nbr_ctl(c);
+			break;
+		case IMSG_CTL_CLEAR_NBR:
+			if (imsg.hdr.len != IMSG_HEADER_SIZE +
+			    sizeof(struct ctl_nbr))
+				break;
+
+			nbr_clear_ctl(imsg.data);
+			break;
+		case IMSG_CTL_LOG_VERBOSE:
+			/* ignore */
+			break;
+		default:
+			log_debug("%s: error handling imsg %d", __func__,
+			    imsg.hdr.type);
+			break;
+		}
+		imsg_free(&imsg);
+	}
+
+	imsg_event_add(&c->iev);
+
+	return (0);
+}
+
+int
+control_imsg_relay(struct imsg *imsg)
+{
+	struct ctl_conn	*c;
+
+	if ((c = control_connbypid(imsg->hdr.pid)) == NULL)
+		return (0);
+
+	return (imsg_compose_event(&c->iev, imsg->hdr.type, 0, imsg->hdr.pid,
+	    -1, imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
+}
diff --git a/ldpd/control.h b/ldpd/control.h
new file mode 100644
index 0000000..32c49fd
--- /dev/null
+++ b/ldpd/control.h
@@ -0,0 +1,37 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _CONTROL_H_
+#define	_CONTROL_H_
+
+#include "openbsd-queue.h"
+
+struct ctl_conn {
+	TAILQ_ENTRY(ctl_conn)	entry;
+	struct imsgev		iev;
+};
+TAILQ_HEAD(ctl_conns, ctl_conn);
+
+extern struct ctl_conns ctl_conns;
+
+int	control_init(void);
+int	control_listen(void);
+void	control_cleanup(void);
+int	control_imsg_relay(struct imsg *);
+
+#endif	/* _CONTROL_H_ */
diff --git a/ldpd/hello.c b/ldpd/hello.c
new file mode 100644
index 0000000..36a2793
--- /dev/null
+++ b/ldpd/hello.c
@@ -0,0 +1,534 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+
+static int	gen_hello_prms_tlv(struct ibuf *buf, uint16_t, uint16_t);
+static int	gen_opt4_hello_prms_tlv(struct ibuf *, uint16_t, uint32_t);
+static int	gen_opt16_hello_prms_tlv(struct ibuf *, uint16_t, uint8_t *);
+static int	gen_ds_hello_prms_tlv(struct ibuf *, uint32_t);
+static int	tlv_decode_hello_prms(char *, uint16_t, uint16_t *, uint16_t *);
+static int	tlv_decode_opt_hello_prms(char *, uint16_t, int *, int,
+		    union ldpd_addr *, uint32_t *, uint16_t *);
+
+int
+send_hello(enum hello_type type, struct iface_af *ia, struct tnbr *tnbr)
+{
+	int			 af;
+	union ldpd_addr		 dst;
+	uint16_t		 size, holdtime = 0, flags = 0;
+	int			 fd = 0;
+	struct ibuf		*buf;
+
+	switch (type) {
+	case HELLO_LINK:
+		af = ia->af;
+		holdtime = if_get_hello_holdtime(ia);
+		flags = 0;
+		fd = (ldp_af_global_get(&global, af))->ldp_disc_socket;
+
+		/* multicast destination address */
+		switch (af) {
+		case AF_INET:
+			dst.v4 = global.mcast_addr_v4;
+			break;
+		case AF_INET6:
+			dst.v6 = global.mcast_addr_v6;
+			break;
+		default:
+			fatalx("send_hello: unknown af");
+		}
+		break;
+	case HELLO_TARGETED:
+		af = tnbr->af;
+		holdtime = tnbr_get_hello_holdtime(tnbr);
+		flags = TARGETED_HELLO;
+		if ((tnbr->flags & F_TNBR_CONFIGURED) || tnbr->pw_count)
+			flags |= REQUEST_TARG_HELLO;
+		fd = (ldp_af_global_get(&global, af))->ldp_edisc_socket;
+
+		/* unicast destination address */
+		dst = tnbr->addr;
+		break;
+	default:
+		fatalx("send_hello: unknown hello type");
+	}
+
+	/* calculate message size */
+	size = LDP_HDR_SIZE + LDP_MSG_SIZE + sizeof(struct hello_prms_tlv);
+	switch (af) {
+	case AF_INET:
+		size += sizeof(struct hello_prms_opt4_tlv);
+		break;
+	case AF_INET6:
+		size += sizeof(struct hello_prms_opt16_tlv);
+		break;
+	default:
+		fatalx("send_hello: unknown af");
+	}
+	if (ldp_is_dual_stack(leconf))
+		size += sizeof(struct hello_prms_opt4_tlv);
+
+	/* generate message */
+	if ((buf = ibuf_open(size)) == NULL)
+		fatal(__func__);
+
+	gen_ldp_hdr(buf, size);
+	size -= LDP_HDR_SIZE;
+	gen_msg_hdr(buf, MSG_TYPE_HELLO, size);
+	gen_hello_prms_tlv(buf, holdtime, flags);
+
+	/*
+	 * RFC 7552 - Section 6.1:
+	 * "An LSR MUST include only the transport address whose address
+	 * family is the same as that of the IP packet carrying the Hello
+	 * message".
+	 */
+	switch (af) {
+	case AF_INET:
+		gen_opt4_hello_prms_tlv(buf, TLV_TYPE_IPV4TRANSADDR,
+		    leconf->ipv4.trans_addr.v4.s_addr);
+		break;
+	case AF_INET6:
+		gen_opt16_hello_prms_tlv(buf, TLV_TYPE_IPV6TRANSADDR,
+		    leconf->ipv6.trans_addr.v6.s6_addr);
+		break;
+	default:
+		fatalx("send_hello: unknown af");
+	}
+
+   	/*
+	 * RFC 7552 - Section 6.1.1:
+	 * "A Dual-stack LSR (i.e., an LSR supporting Dual-stack LDP for a peer)
+	 * MUST include the Dual-Stack capability TLV in all of its LDP Hellos".
+	 */
+	if (ldp_is_dual_stack(leconf))
+		gen_ds_hello_prms_tlv(buf, leconf->trans_pref);
+
+	send_packet(fd, af, &dst, ia, buf->buf, buf->wpos);
+	ibuf_free(buf);
+
+	return (0);
+}
+
+void
+recv_hello(struct in_addr lsr_id, struct ldp_msg *lm, int af,
+    union ldpd_addr *src, struct iface *iface, int multicast, char *buf,
+    uint16_t len)
+{
+	struct adj		*adj = NULL;
+	struct nbr		*nbr;
+	uint16_t		 holdtime = 0, flags = 0;
+	int			 tlvs_rcvd;
+	int			 ds_tlv;
+	union ldpd_addr		 trans_addr;
+	uint32_t		 scope_id = 0;
+	uint32_t		 conf_number;
+	uint16_t		 trans_pref;
+	int			 r;
+	struct hello_source	 source;
+	struct iface_af		*ia = NULL;
+	struct tnbr		*tnbr = NULL;
+
+	r = tlv_decode_hello_prms(buf, len, &holdtime, &flags);
+	if (r == -1) {
+		log_debug("%s: lsr-id %s: failed to decode params", __func__,
+		    inet_ntoa(lsr_id));
+		return;
+	}
+	if (holdtime != 0 && holdtime < MIN_HOLDTIME) {
+		log_debug("%s: lsr-id %s: invalid hello holdtime (%u)",
+		    __func__, inet_ntoa(lsr_id), holdtime);
+		return;
+	}
+	buf += r;
+	len -= r;
+
+	/* safety checks */
+	if (multicast && (flags & TARGETED_HELLO)) {
+		log_debug("%s: lsr-id %s: multicast targeted hello", __func__,
+		    inet_ntoa(lsr_id));
+		return;
+	}
+	if (!multicast && !((flags & TARGETED_HELLO))) {
+		log_debug("%s: lsr-id %s: unicast link hello", __func__,
+		    inet_ntoa(lsr_id));
+		return;
+	}
+
+	memset(&source, 0, sizeof(source));
+	if (flags & TARGETED_HELLO) {
+		/*
+	 	 * RFC 7552 - Section 5.2:
+		* "The link-local IPv6 addresses MUST NOT be used as the
+		* targeted LDP Hello packet's source or destination addresses.
+		*/
+		if (af == AF_INET6 && IN6_IS_SCOPE_EMBED(&src->v6)) {
+			log_debug("%s: lsr-id %s: targeted hello with "
+			    "link-local source address", __func__,
+			    inet_ntoa(lsr_id));
+			return;
+		}
+
+		tnbr = tnbr_find(leconf, af, src);
+
+		/* remove the dynamic tnbr if the 'R' bit was cleared */
+		if (tnbr && (tnbr->flags & F_TNBR_DYNAMIC) &&
+		    !((flags & REQUEST_TARG_HELLO))) {
+			tnbr->flags &= ~F_TNBR_DYNAMIC;
+			tnbr = tnbr_check(tnbr);
+		}
+
+		if (!tnbr) {
+			if (!((flags & REQUEST_TARG_HELLO) &&
+			    ((ldp_af_conf_get(leconf, af))->flags &
+			    F_LDPD_AF_THELLO_ACCEPT)))
+				return;
+
+			tnbr = tnbr_new(af, src);
+			tnbr->flags |= F_TNBR_DYNAMIC;
+			tnbr_update(tnbr);
+			LIST_INSERT_HEAD(&leconf->tnbr_list, tnbr, entry);
+		}
+
+		source.type = HELLO_TARGETED;
+		source.target = tnbr;
+	} else {
+		ia = iface_af_get(iface, af);
+		source.type = HELLO_LINK;
+		source.link.ia = ia;
+		source.link.src_addr = *src;
+	}
+
+	r = tlv_decode_opt_hello_prms(buf, len, &tlvs_rcvd, af, &trans_addr,
+	    &conf_number, &trans_pref);
+	if (r == -1) {
+		log_debug("%s: lsr-id %s: failed to decode optional params",
+		    __func__, inet_ntoa(lsr_id));
+		return;
+	}
+	if (r != len) {
+		log_debug("%s: lsr-id %s: unexpected data in message",
+		    __func__, inet_ntoa(lsr_id));
+		return;
+	}
+
+	/* implicit transport address */
+	if (!(tlvs_rcvd & F_HELLO_TLV_RCVD_ADDR))
+		trans_addr = *src;
+	if (bad_addr(af, &trans_addr)) {
+		log_debug("%s: lsr-id %s: invalid transport address %s",
+		    __func__, inet_ntoa(lsr_id), log_addr(af, &trans_addr));
+		return;
+	}
+	if (af == AF_INET6 && IN6_IS_SCOPE_EMBED(&trans_addr.v6)) {
+		/*
+	 	 * RFC 7552 - Section 6.1:
+		 * An LSR MUST use a global unicast IPv6 address in an IPv6
+		 * Transport Address optional object of outgoing targeted
+		 * Hellos and check for the same in incoming targeted Hellos
+		 * (i.e., MUST discard the targeted Hello if it failed the
+		 * check)".
+		 */
+		if (source.type == HELLO_TARGETED)
+			return;
+		scope_id = iface->ifindex;
+	}
+
+	adj = adj_find(&source);
+	nbr = nbr_find_ldpid(lsr_id.s_addr);
+
+	/* check dual-stack tlv */
+	ds_tlv = (tlvs_rcvd & F_HELLO_TLV_RCVD_DS) ? 1 : 0;
+	if (ds_tlv && trans_pref != leconf->trans_pref) {
+		/*
+	 	 * RFC 7552 - Section 6.1.1:
+		 * "If the Dual-Stack capability TLV is present and the remote
+		 * preference does not match the local preference (or does not
+		 * get recognized), then the LSR MUST discard the Hello message
+		 * and log an error.
+		 * If an LDP session was already in place, then the LSR MUST
+		 * send a fatal Notification message with status code of
+		 * 'Transport Connection Mismatch' and reset the session".
+		 */
+		log_debug("%s: lsr-id %s: remote transport preference does not "
+		    "match the local preference", __func__, inet_ntoa(lsr_id));
+		if (nbr)
+			session_shutdown(nbr, S_TRANS_MISMTCH, lm->msgid,
+			    lm->type);
+		if (adj)
+			adj_del(adj);
+		return;
+	}
+
+	if (adj == NULL) {
+		adj = adj_new(lsr_id, &source, &trans_addr);
+		if (nbr) {
+			adj->nbr = nbr;
+			LIST_INSERT_HEAD(&nbr->adj_list, adj, nbr_entry);
+		}
+	}
+
+	if (nbr == NULL) {
+		/*
+		 * The hello adjacency's address-family doesn't match the local
+		 * preference.
+		 */
+		if (ds_tlv &&
+		    ((trans_pref == DUAL_STACK_LDPOV4 && af != AF_INET) ||
+		    (trans_pref == DUAL_STACK_LDPOV6 && af != AF_INET6)))
+			return;
+
+		nbr = nbr_find_addr(af, &trans_addr);
+		if (nbr) {
+			log_debug("%s: transport address %s is already being "
+			    "used by lsr-id %s", __func__, log_addr(af,
+			    &trans_addr), inet_ntoa(nbr->id));
+			return;
+		}
+
+		/* create new adjacency and new neighbor */
+		nbr = nbr_new(lsr_id, af, ds_tlv, &trans_addr, scope_id);
+	} else {
+		/*
+		 * Check for noncompliant dual-stack neighbor according to
+		 * RFC 7552 section 6.1.1.
+		 */
+		if (!ds_tlv) {
+			switch (af) {
+			case AF_INET:
+				if (nbr_adj_count(nbr, AF_INET6) > 0) {
+					session_shutdown(nbr, S_DS_NONCMPLNCE,
+					    lm->msgid, lm->type);
+					return;
+				}
+				break;
+			case AF_INET6:
+				if (nbr_adj_count(nbr, AF_INET) > 0) {
+					session_shutdown(nbr, S_DS_NONCMPLNCE,
+					    lm->msgid, lm->type);
+					return;
+				}
+				break;
+			default:
+				fatalx("recv_hello: unknown af");
+			}
+		}
+
+		/*
+		 * Protection against misconfigured networks and buggy
+		 * implementations.
+		 */
+		if (af == nbr->af &&
+		    (ldp_addrcmp(af, &nbr->raddr, &trans_addr) ||
+		    nbr->raddr_scope != scope_id)) {
+			log_warnx("%s: lsr-id %s: ignoring hello packet "
+			    "advertising different transport address", __func__,
+			    inet_ntoa(lsr_id));
+			return;
+		}
+	}
+
+	/* always update the holdtime to properly handle runtime changes */
+	switch (source.type) {
+	case HELLO_LINK:
+		if (holdtime == 0)
+			holdtime = LINK_DFLT_HOLDTIME;
+
+		adj->holdtime = min(if_get_hello_holdtime(ia), holdtime);
+		break;
+	case HELLO_TARGETED:
+		if (holdtime == 0)
+			holdtime = TARGETED_DFLT_HOLDTIME;
+
+		adj->holdtime = min(tnbr_get_hello_holdtime(tnbr), holdtime);
+	}
+	if (adj->holdtime != INFINITE_HOLDTIME)
+		adj_start_itimer(adj);
+	else
+		adj_stop_itimer(adj);
+
+	if (nbr->state == NBR_STA_PRESENT && nbr_session_active_role(nbr) &&
+	    !nbr_pending_connect(nbr) && !nbr_pending_idtimer(nbr))
+		nbr_establish_connection(nbr);
+}
+
+static int
+gen_hello_prms_tlv(struct ibuf *buf, uint16_t holdtime, uint16_t flags)
+{
+	struct hello_prms_tlv	parms;
+
+	memset(&parms, 0, sizeof(parms));
+	parms.type = htons(TLV_TYPE_COMMONHELLO);
+	parms.length = htons(sizeof(parms.holdtime) + sizeof(parms.flags));
+	parms.holdtime = htons(holdtime);
+	parms.flags = htons(flags);
+
+	return (ibuf_add(buf, &parms, sizeof(parms)));
+}
+
+static int
+gen_opt4_hello_prms_tlv(struct ibuf *buf, uint16_t type, uint32_t value)
+{
+	struct hello_prms_opt4_tlv	parms;
+
+	memset(&parms, 0, sizeof(parms));
+	parms.type = htons(type);
+	parms.length = htons(sizeof(parms.value));
+	parms.value = value;
+
+	return (ibuf_add(buf, &parms, sizeof(parms)));
+}
+
+static int
+gen_opt16_hello_prms_tlv(struct ibuf *buf, uint16_t type, uint8_t *value)
+{
+	struct hello_prms_opt16_tlv	parms;
+
+	memset(&parms, 0, sizeof(parms));
+	parms.type = htons(type);
+	parms.length = htons(sizeof(parms.value));
+	memcpy(&parms.value, value, sizeof(parms.value));
+
+	return (ibuf_add(buf, &parms, sizeof(parms)));
+}
+
+static int
+gen_ds_hello_prms_tlv(struct ibuf *buf, uint32_t value)
+{
+	if (leconf->flags & F_LDPD_DS_CISCO_INTEROP)
+		value = htonl(value);
+	else
+		value = htonl(value << 28);
+
+	return (gen_opt4_hello_prms_tlv(buf, TLV_TYPE_DUALSTACK, value));
+}
+
+static int
+tlv_decode_hello_prms(char *buf, uint16_t len, uint16_t *holdtime,
+    uint16_t *flags)
+{
+	struct hello_prms_tlv	tlv;
+
+	if (len < sizeof(tlv))
+		return (-1);
+	memcpy(&tlv, buf, sizeof(tlv));
+
+	if (tlv.type != htons(TLV_TYPE_COMMONHELLO))
+		return (-1);
+	if (ntohs(tlv.length) != sizeof(tlv) - TLV_HDR_LEN)
+		return (-1);
+
+	*holdtime = ntohs(tlv.holdtime);
+	*flags = ntohs(tlv.flags);
+
+	return (sizeof(tlv));
+}
+
+static int
+tlv_decode_opt_hello_prms(char *buf, uint16_t len, int *tlvs_rcvd, int af,
+    union ldpd_addr *addr, uint32_t *conf_number, uint16_t *trans_pref)
+{
+	struct tlv	tlv;
+	uint16_t	tlv_len;
+	int		total = 0;
+
+	*tlvs_rcvd = 0;
+	memset(addr, 0, sizeof(*addr));
+	*conf_number = 0;
+	*trans_pref = 0;
+
+	/*
+	 * RFC 7552 - Section 6.1:
+	 * "An LSR SHOULD accept the Hello message that contains both IPv4 and
+	 * IPv6 Transport Address optional objects but MUST use only the
+	 * transport address whose address family is the same as that of the
+	 * IP packet carrying the Hello message.  An LSR SHOULD accept only
+	 * the first Transport Address optional object for a given address
+	 * family in the received Hello message and ignore the rest if the
+	 * LSR receives more than one Transport Address optional object for a
+	 * given address family".
+	 */
+	while (len >= sizeof(tlv)) {
+		memcpy(&tlv, buf, sizeof(tlv));
+		tlv_len = ntohs(tlv.length);
+		switch (ntohs(tlv.type)) {
+		case TLV_TYPE_IPV4TRANSADDR:
+			if (tlv_len != sizeof(addr->v4))
+				return (-1);
+			if (af != AF_INET || ldp_addrisset(AF_INET, addr))
+				break;
+			memcpy(&addr->v4, buf + TLV_HDR_LEN, sizeof(addr->v4));
+			*tlvs_rcvd |= F_HELLO_TLV_RCVD_ADDR;
+			break;
+		case TLV_TYPE_IPV6TRANSADDR:
+			if (tlv_len != sizeof(addr->v6))
+				return (-1);
+			if (af != AF_INET6 || ldp_addrisset(AF_INET6, addr))
+				break;
+			memcpy(&addr->v6, buf + TLV_HDR_LEN, sizeof(addr->v6));
+			*tlvs_rcvd |= F_HELLO_TLV_RCVD_ADDR;
+			break;
+		case TLV_TYPE_CONFIG:
+			if (tlv_len != sizeof(uint32_t))
+				return (-1);
+			memcpy(conf_number, buf + TLV_HDR_LEN,
+			    sizeof(uint32_t));
+			*tlvs_rcvd |= F_HELLO_TLV_RCVD_CONF;
+			break;
+		case TLV_TYPE_DUALSTACK:
+			if (tlv_len != sizeof(uint32_t))
+				return (-1);
+   			/*
+	 		 * RFC 7552 - Section 6.1:
+			 * "A Single-stack LSR does not need to use the
+			 * Dual-Stack capability in Hello messages and SHOULD
+			 * ignore this capability if received".
+			 */
+			if (!ldp_is_dual_stack(leconf))
+				break;
+			/* Shame on you, Cisco! */
+			if (leconf->flags & F_LDPD_DS_CISCO_INTEROP) {
+				memcpy(trans_pref, buf + TLV_HDR_LEN +
+				    sizeof(uint16_t), sizeof(uint16_t));
+				*trans_pref = ntohs(*trans_pref);
+			} else {
+				memcpy(trans_pref, buf + TLV_HDR_LEN,
+				    sizeof(uint16_t));
+				*trans_pref = ntohs(*trans_pref) >> 12;
+			}
+			*tlvs_rcvd |= F_HELLO_TLV_RCVD_DS;
+			break;
+		default:
+			/* if unknown flag set, ignore TLV */
+			if (!(ntohs(tlv.type) & UNKNOWN_FLAG))
+				return (-1);
+			break;
+		}
+		buf += TLV_HDR_LEN + tlv_len;
+		len -= TLV_HDR_LEN + tlv_len;
+		total += TLV_HDR_LEN + tlv_len;
+	}
+
+	return (total);
+}
diff --git a/ldpd/init.c b/ldpd/init.c
new file mode 100644
index 0000000..8886a23
--- /dev/null
+++ b/ldpd/init.c
@@ -0,0 +1,157 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+
+static int	gen_init_prms_tlv(struct ibuf *, struct nbr *, uint16_t);
+static int	tlv_decode_opt_init_prms(char *, uint16_t);
+
+void
+send_init(struct nbr *nbr)
+{
+	struct ibuf		*buf;
+	uint16_t		 size;
+
+	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));
+
+	size = LDP_HDR_SIZE + LDP_MSG_SIZE + SESS_PRMS_SIZE;
+	if ((buf = ibuf_open(size)) == NULL)
+		fatal(__func__);
+
+	gen_ldp_hdr(buf, size);
+	size -= LDP_HDR_SIZE;
+	gen_msg_hdr(buf, MSG_TYPE_INIT, size);
+	size -= LDP_MSG_SIZE;
+	gen_init_prms_tlv(buf, nbr, size);
+
+	evbuf_enqueue(&nbr->tcp->wbuf, buf);
+}
+
+int
+recv_init(struct nbr *nbr, char *buf, uint16_t len)
+{
+	struct ldp_msg		init;
+	struct sess_prms_tlv	sess;
+	uint16_t		max_pdu_len;
+
+	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));
+
+	memcpy(&init, buf, sizeof(init));
+	buf += LDP_MSG_SIZE;
+	len -= LDP_MSG_SIZE;
+
+	if (len < SESS_PRMS_SIZE) {
+		session_shutdown(nbr, S_BAD_MSG_LEN, init.msgid, init.type);
+		return (-1);
+	}
+	memcpy(&sess, buf, sizeof(sess));
+	if (ntohs(sess.keepalive_time) < MIN_KEEPALIVE) {
+		session_shutdown(nbr, S_KEEPALIVE_BAD, init.msgid, init.type);
+		return (-1);
+	}
+
+	if (ntohs(sess.length) != SESS_PRMS_SIZE - TLV_HDR_LEN) {
+		session_shutdown(nbr, S_BAD_TLV_LEN, init.msgid, init.type);
+		return (-1);
+	}
+
+	if (ntohs(sess.proto_version) != LDP_VERSION) {
+		session_shutdown(nbr, S_BAD_PROTO_VER, init.msgid, init.type);
+		return (-1);
+	}
+
+	buf += SESS_PRMS_SIZE;
+	len -= SESS_PRMS_SIZE;
+
+	/* just ignore all optional TLVs for now */
+	if (tlv_decode_opt_init_prms(buf, len) == -1) {
+		session_shutdown(nbr, S_BAD_TLV_VAL, init.msgid, init.type);
+		return (-1);
+	}
+
+	nbr->keepalive = min(nbr_get_keepalive(nbr->af, nbr->id),
+	    ntohs(sess.keepalive_time));
+
+	max_pdu_len = ntohs(sess.max_pdu_len);
+	/*
+	 * RFC 5036 - Section 3.5.3:
+	 * "A value of 255 or less specifies the default maximum length of
+	 * 4096 octets".
+	 */
+	if (max_pdu_len <= 255)
+		max_pdu_len = LDP_MAX_LEN;
+	nbr->max_pdu_len = min(max_pdu_len, LDP_MAX_LEN);
+
+	nbr_fsm(nbr, NBR_EVT_INIT_RCVD);
+
+	return (0);
+}
+
+static int
+gen_init_prms_tlv(struct ibuf *buf, struct nbr *nbr, uint16_t size)
+{
+	struct sess_prms_tlv	parms;
+
+	memset(&parms, 0, sizeof(parms));
+	parms.type = htons(TLV_TYPE_COMMONSESSION);
+	parms.length = htons(size - TLV_HDR_LEN);
+	parms.proto_version = htons(LDP_VERSION);
+	parms.keepalive_time = htons(nbr_get_keepalive(nbr->af, nbr->id));
+	parms.reserved = 0;
+	parms.pvlim = 0;
+	parms.max_pdu_len = 0;
+	parms.lsr_id = nbr->id.s_addr;
+	parms.lspace_id = 0;
+
+	return (ibuf_add(buf, &parms, SESS_PRMS_SIZE));
+}
+
+static int
+tlv_decode_opt_init_prms(char *buf, uint16_t len)
+{
+	struct tlv	tlv;
+	uint16_t	tlv_len;
+	int		total = 0;
+
+	 while (len >= sizeof(tlv)) {
+		memcpy(&tlv, buf, sizeof(tlv));
+		tlv_len = ntohs(tlv.length);
+		switch (ntohs(tlv.type)) {
+		case TLV_TYPE_ATMSESSIONPAR:
+			log_warnx("ATM session parameter present");
+			return (-1);
+		case TLV_TYPE_FRSESSION:
+			log_warnx("FR session parameter present");
+			return (-1);
+		default:
+			/* if unknown flag set, ignore TLV */
+			if (!(ntohs(tlv.type) & UNKNOWN_FLAG))
+				return (-1);
+			break;
+		}
+		buf += TLV_HDR_LEN + tlv_len;
+		len -= TLV_HDR_LEN + tlv_len;
+		total += TLV_HDR_LEN + tlv_len;
+	}
+
+	return (total);
+}
diff --git a/ldpd/interface.c b/ldpd/interface.c
new file mode 100644
index 0000000..b207ff0
--- /dev/null
+++ b/ldpd/interface.c
@@ -0,0 +1,563 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2005 Claudio Jeker <claudio@openbsd.org>
+ * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+
+#include "sockopt.h"
+
+static struct if_addr	*if_addr_new(struct kaddr *);
+static struct if_addr	*if_addr_lookup(struct if_addr_head *, struct kaddr *);
+static int		 if_start(struct iface *, int);
+static int		 if_reset(struct iface *, int);
+static void		 if_update_af(struct iface_af *, int);
+static int		 if_hello_timer(struct thread *);
+static void		 if_start_hello_timer(struct iface_af *);
+static void		 if_stop_hello_timer(struct iface_af *);
+static int		 if_join_ipv4_group(struct iface *, struct in_addr *);
+static int		 if_leave_ipv4_group(struct iface *, struct in_addr *);
+static int		 if_join_ipv6_group(struct iface *, struct in6_addr *);
+static int		 if_leave_ipv6_group(struct iface *, struct in6_addr *);
+
+struct iface *
+if_new(struct kif *kif)
+{
+	struct iface		*iface;
+
+	if ((iface = calloc(1, sizeof(*iface))) == NULL)
+		fatal("if_new: calloc");
+
+	strlcpy(iface->name, kif->ifname, sizeof(iface->name));
+	LIST_INIT(&iface->addr_list);
+	if (kif->ifindex)
+		if_update_info(iface, kif);
+
+	/* ipv4 */
+	iface->ipv4.af = AF_INET;
+	iface->ipv4.iface = iface;
+	iface->ipv4.enabled = 0;
+	iface->ipv4.state = IF_STA_DOWN;
+	LIST_INIT(&iface->ipv4.adj_list);
+
+	/* ipv6 */
+	iface->ipv6.af = AF_INET6;
+	iface->ipv6.iface = iface;
+	iface->ipv6.enabled = 0;
+	iface->ipv6.state = IF_STA_DOWN;
+	LIST_INIT(&iface->ipv6.adj_list);
+
+	return (iface);
+}
+
+void
+if_del(struct iface *iface)
+{
+	struct if_addr		*if_addr;
+
+	log_debug("%s: interface %s", __func__, iface->name);
+
+	if (iface->ipv4.state == IF_STA_ACTIVE)
+		if_reset(iface, AF_INET);
+	if (iface->ipv6.state == IF_STA_ACTIVE)
+		if_reset(iface, AF_INET6);
+
+	while ((if_addr = LIST_FIRST(&iface->addr_list)) != NULL) {
+		LIST_REMOVE(if_addr, entry);
+		free(if_addr);
+	}
+
+	free(iface);
+}
+
+struct iface *
+if_lookup(struct ldpd_conf *xconf, unsigned short ifindex)
+{
+	struct iface *iface;
+
+	LIST_FOREACH(iface, &xconf->iface_list, entry)
+		if (iface->ifindex == ifindex)
+			return (iface);
+
+	return (NULL);
+}
+
+struct iface *
+if_lookup_name(struct ldpd_conf *xconf, const char *ifname)
+{
+	struct iface *iface;
+
+	LIST_FOREACH(iface, &xconf->iface_list, entry)
+		if (strcmp(iface->name, ifname) == 0)
+			return (iface);
+
+	return (NULL);
+}
+
+void
+if_update_info(struct iface *iface, struct kif *kif)
+{
+	/* get type */
+	if (kif->flags & IFF_POINTOPOINT)
+		iface->type = IF_TYPE_POINTOPOINT;
+	if (kif->flags & IFF_BROADCAST &&
+	    kif->flags & IFF_MULTICAST)
+		iface->type = IF_TYPE_BROADCAST;
+
+	/* get index and flags */
+	iface->ifindex = kif->ifindex;
+	iface->flags = kif->flags;
+}
+
+struct iface_af *
+iface_af_get(struct iface *iface, int af)
+{
+	switch (af) {
+	case AF_INET:
+		return (&iface->ipv4);
+	case AF_INET6:
+		return (&iface->ipv6);
+	default:
+		fatalx("iface_af_get: unknown af");
+	}
+}
+
+static struct if_addr *
+if_addr_new(struct kaddr *ka)
+{
+	struct if_addr	*if_addr;
+
+	if ((if_addr = calloc(1, sizeof(*if_addr))) == NULL)
+		fatal(__func__);
+
+	if_addr->af = ka->af;
+	if_addr->addr = ka->addr;
+	if_addr->prefixlen = ka->prefixlen;
+	if_addr->dstbrd = ka->dstbrd;
+
+	return (if_addr);
+}
+
+static struct if_addr *
+if_addr_lookup(struct if_addr_head *addr_list, struct kaddr *ka)
+{
+	struct if_addr	*if_addr;
+	int		 af = ka->af;
+
+	LIST_FOREACH(if_addr, addr_list, entry)
+		if (!ldp_addrcmp(af, &if_addr->addr, &ka->addr) &&
+		    if_addr->prefixlen == ka->prefixlen &&
+		    !ldp_addrcmp(af, &if_addr->dstbrd, &ka->dstbrd))
+			return (if_addr);
+
+	return (NULL);
+}
+
+void
+if_addr_add(struct kaddr *ka)
+{
+	struct iface		*iface;
+	struct if_addr		*if_addr;
+	struct nbr		*nbr;
+
+	if (if_addr_lookup(&global.addr_list, ka) == NULL) {
+		if_addr = if_addr_new(ka);
+
+		LIST_INSERT_HEAD(&global.addr_list, if_addr, entry);
+		RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
+			if (nbr->state != NBR_STA_OPER)
+				continue;
+			if (if_addr->af == AF_INET && !nbr->v4_enabled)
+				continue;
+			if (if_addr->af == AF_INET6 && !nbr->v6_enabled)
+				continue;
+
+			send_address(nbr, if_addr->af, if_addr, 0);
+		}
+	}
+
+	iface = if_lookup(leconf, ka->ifindex);
+	if (iface) {
+		if (ka->af == AF_INET6 && IN6_IS_ADDR_LINKLOCAL(&ka->addr.v6))
+			iface->linklocal = ka->addr.v6;
+
+		if (if_addr_lookup(&iface->addr_list, ka) == NULL) {
+			if_addr = if_addr_new(ka);
+			LIST_INSERT_HEAD(&iface->addr_list, if_addr, entry);
+			if_update(iface, if_addr->af);
+		}
+	}
+}
+
+void
+if_addr_del(struct kaddr *ka)
+{
+	struct iface		*iface;
+	struct if_addr		*if_addr;
+	struct nbr		*nbr;
+
+	iface = if_lookup(leconf, ka->ifindex);
+	if (iface) {
+		if (ka->af == AF_INET6 &&
+		    IN6_ARE_ADDR_EQUAL(&iface->linklocal, &ka->addr.v6))
+			memset(&iface->linklocal, 0, sizeof(iface->linklocal));
+
+		if_addr = if_addr_lookup(&iface->addr_list, ka);
+		if (if_addr) {
+			LIST_REMOVE(if_addr, entry);
+			if_update(iface, if_addr->af);
+			free(if_addr);
+		}
+	}
+
+	if_addr = if_addr_lookup(&global.addr_list, ka);
+	if (if_addr) {
+		RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
+			if (nbr->state != NBR_STA_OPER)
+				continue;
+			if (if_addr->af == AF_INET && !nbr->v4_enabled)
+				continue;
+			if (if_addr->af == AF_INET6 && !nbr->v6_enabled)
+				continue;
+			send_address(nbr, if_addr->af, if_addr, 1);
+		}
+		LIST_REMOVE(if_addr, entry);
+		free(if_addr);
+	}
+}
+
+static int
+if_start(struct iface *iface, int af)
+{
+	struct iface_af		*ia;
+	struct timeval		 now;
+
+	log_debug("%s: %s address-family %s", __func__, iface->name,
+	    af_name(af));
+
+	ia = iface_af_get(iface, af);
+
+	gettimeofday(&now, NULL);
+	ia->uptime = now.tv_sec;
+
+	switch (af) {
+	case AF_INET:
+		if (if_join_ipv4_group(iface, &global.mcast_addr_v4))
+			return (-1);
+		break;
+	case AF_INET6:
+		if (if_join_ipv6_group(iface, &global.mcast_addr_v6))
+			return (-1);
+		break;
+	default:
+		fatalx("if_start: unknown af");
+	}
+
+	send_hello(HELLO_LINK, ia, NULL);
+
+	if_start_hello_timer(ia);
+	return (0);
+}
+
+static int
+if_reset(struct iface *iface, int af)
+{
+	struct iface_af		*ia;
+	struct adj		*adj;
+
+	log_debug("%s: %s address-family %s", __func__, iface->name,
+	    af_name(af));
+
+	ia = iface_af_get(iface, af);
+	if_stop_hello_timer(ia);
+
+	while ((adj = LIST_FIRST(&ia->adj_list)) != NULL)
+		adj_del(adj);
+
+	/* try to cleanup */
+	switch (af) {
+	case AF_INET:
+		if (global.ipv4.ldp_disc_socket != -1)
+			if_leave_ipv4_group(iface, &global.mcast_addr_v4);
+		break;
+	case AF_INET6:
+		if (global.ipv6.ldp_disc_socket != -1)
+			if_leave_ipv6_group(iface, &global.mcast_addr_v6);
+		break;
+	default:
+		fatalx("if_start: unknown af");
+	}
+
+	return (0);
+}
+
+static void
+if_update_af(struct iface_af *ia, int link_ok)
+{
+	int			 addr_ok = 0, socket_ok, rtr_id_ok;
+	struct if_addr		*if_addr;
+
+	switch (ia->af) {
+	case AF_INET:
+		/*
+		 * NOTE: for LDPv4, each interface should have at least one
+		 * valid IP address otherwise they can not be enabled.
+		 */
+		LIST_FOREACH(if_addr, &ia->iface->addr_list, entry) {
+			if (if_addr->af == AF_INET) {
+				addr_ok = 1;
+				break;
+			}
+		}
+		break;
+	case AF_INET6:
+		/* for IPv6 the link-local address is enough. */
+		if (IN6_IS_ADDR_LINKLOCAL(&ia->iface->linklocal))
+			addr_ok = 1;
+		break;
+	default:
+		fatalx("if_update_af: unknown af");
+	}
+
+	if ((ldp_af_global_get(&global, ia->af))->ldp_disc_socket != -1)
+		socket_ok = 1;
+	else
+		socket_ok = 0;
+
+	if (ldp_rtr_id_get(leconf) != INADDR_ANY)
+		rtr_id_ok = 1;
+	else
+		rtr_id_ok = 0;
+
+	if (ia->state == IF_STA_DOWN) {
+		if (!ia->enabled || !link_ok || !addr_ok || !socket_ok ||
+		    !rtr_id_ok)
+			return;
+
+		ia->state = IF_STA_ACTIVE;
+		if_start(ia->iface, ia->af);
+	} else if (ia->state == IF_STA_ACTIVE) {
+		if (ia->enabled && link_ok && addr_ok && socket_ok && rtr_id_ok)
+			return;
+
+		ia->state = IF_STA_DOWN;
+		if_reset(ia->iface, ia->af);
+	}
+}
+
+void
+if_update(struct iface *iface, int af)
+{
+	int			 link_ok;
+
+	link_ok = (iface->flags & IFF_UP) && (iface->flags & IFF_RUNNING);
+
+	if (af == AF_INET || af == AF_UNSPEC)
+		if_update_af(&iface->ipv4, link_ok);
+	if (af == AF_INET6 || af == AF_UNSPEC)
+		if_update_af(&iface->ipv6, link_ok);
+}
+
+void
+if_update_all(int af)
+{
+	struct iface		*iface;
+
+	LIST_FOREACH(iface, &leconf->iface_list, entry)
+		if_update(iface, af);
+}
+
+uint16_t
+if_get_hello_holdtime(struct iface_af *ia)
+{
+	if (ia->hello_holdtime != 0)
+		return (ia->hello_holdtime);
+
+	if ((ldp_af_conf_get(leconf, ia->af))->lhello_holdtime != 0)
+		return ((ldp_af_conf_get(leconf, ia->af))->lhello_holdtime);
+
+	return (leconf->lhello_holdtime);
+}
+
+uint16_t
+if_get_hello_interval(struct iface_af *ia)
+{
+	if (ia->hello_interval != 0)
+		return (ia->hello_interval);
+
+	if ((ldp_af_conf_get(leconf, ia->af))->lhello_interval != 0)
+		return ((ldp_af_conf_get(leconf, ia->af))->lhello_interval);
+
+	return (leconf->lhello_interval);
+}
+
+/* timers */
+/* ARGSUSED */
+static int
+if_hello_timer(struct thread *thread)
+{
+	struct iface_af		*ia = THREAD_ARG(thread);
+
+	ia->hello_timer = NULL;
+	send_hello(HELLO_LINK, ia, NULL);
+	if_start_hello_timer(ia);
+
+	return (0);
+}
+
+static void
+if_start_hello_timer(struct iface_af *ia)
+{
+	THREAD_TIMER_OFF(ia->hello_timer);
+	ia->hello_timer = thread_add_timer(master, if_hello_timer, ia,
+	    if_get_hello_interval(ia));
+}
+
+static void
+if_stop_hello_timer(struct iface_af *ia)
+{
+	THREAD_TIMER_OFF(ia->hello_timer);
+}
+
+struct ctl_iface *
+if_to_ctl(struct iface_af *ia)
+{
+	static struct ctl_iface	 ictl;
+	struct timeval		 now;
+	struct adj		*adj;
+
+	ictl.af = ia->af;
+	memcpy(ictl.name, ia->iface->name, sizeof(ictl.name));
+	ictl.ifindex = ia->iface->ifindex;
+	ictl.state = ia->state;
+	ictl.flags = ia->iface->flags;
+	ictl.type = ia->iface->type;
+	ictl.hello_holdtime = if_get_hello_holdtime(ia);
+	ictl.hello_interval = if_get_hello_interval(ia);
+
+	gettimeofday(&now, NULL);
+	if (ia->state != IF_STA_DOWN &&
+	    ia->uptime != 0) {
+		ictl.uptime = now.tv_sec - ia->uptime;
+	} else
+		ictl.uptime = 0;
+
+	ictl.adj_cnt = 0;
+	LIST_FOREACH(adj, &ia->adj_list, ia_entry)
+		ictl.adj_cnt++;
+
+	return (&ictl);
+}
+
+/* multicast membership sockopts */
+in_addr_t
+if_get_ipv4_addr(struct iface *iface)
+{
+	struct if_addr		*if_addr;
+
+	LIST_FOREACH(if_addr, &iface->addr_list, entry)
+		if (if_addr->af == AF_INET)
+			return (if_addr->addr.v4.s_addr);
+
+	return (INADDR_ANY);
+}
+
+static int
+if_join_ipv4_group(struct iface *iface, struct in_addr *addr)
+{
+	struct in_addr		 if_addr;
+
+	log_debug("%s: interface %s addr %s", __func__, iface->name,
+	    inet_ntoa(*addr));
+
+	if_addr.s_addr = if_get_ipv4_addr(iface);
+
+	if (setsockopt_ipv4_multicast(global.ipv4.ldp_disc_socket,
+	    IP_ADD_MEMBERSHIP, if_addr, addr->s_addr, iface->ifindex) < 0) {
+		log_warn("%s: error IP_ADD_MEMBERSHIP, interface %s address %s",
+		     __func__, iface->name, inet_ntoa(*addr));
+		return (-1);
+	}
+	return (0);
+}
+
+static int
+if_leave_ipv4_group(struct iface *iface, struct in_addr *addr)
+{
+	struct in_addr		 if_addr;
+
+	log_debug("%s: interface %s addr %s", __func__, iface->name,
+	    inet_ntoa(*addr));
+
+	if_addr.s_addr = if_get_ipv4_addr(iface);
+
+	if (setsockopt_ipv4_multicast(global.ipv4.ldp_disc_socket,
+	    IP_DROP_MEMBERSHIP, if_addr, addr->s_addr, iface->ifindex) < 0) {
+		log_warn("%s: error IP_DROP_MEMBERSHIP, interface %s "
+		    "address %s", __func__, iface->name, inet_ntoa(*addr));
+		return (-1);
+	}
+
+	return (0);
+}
+
+static int
+if_join_ipv6_group(struct iface *iface, struct in6_addr *addr)
+{
+	struct ipv6_mreq	 mreq;
+
+	log_debug("%s: interface %s addr %s", __func__, iface->name,
+	    log_in6addr(addr));
+
+	mreq.ipv6mr_multiaddr = *addr;
+	mreq.ipv6mr_interface = iface->ifindex;
+
+	if (setsockopt(global.ipv6.ldp_disc_socket, IPPROTO_IPV6,
+	    IPV6_JOIN_GROUP, &mreq, sizeof(mreq)) < 0) {
+		log_warn("%s: error IPV6_JOIN_GROUP, interface %s address %s",
+		    __func__, iface->name, log_in6addr(addr));
+		return (-1);
+	}
+
+	return (0);
+}
+
+static int
+if_leave_ipv6_group(struct iface *iface, struct in6_addr *addr)
+{
+	struct ipv6_mreq	 mreq;
+
+	log_debug("%s: interface %s addr %s", __func__, iface->name,
+	    log_in6addr(addr));
+
+	mreq.ipv6mr_multiaddr = *addr;
+	mreq.ipv6mr_interface = iface->ifindex;
+
+	if (setsockopt(global.ipv6.ldp_disc_socket, IPPROTO_IPV6,
+	    IPV6_LEAVE_GROUP, (void *)&mreq, sizeof(mreq)) < 0) {
+		log_warn("%s: error IPV6_LEAVE_GROUP, interface %s address %s",
+		    __func__, iface->name, log_in6addr(addr));
+		return (-1);
+	}
+
+	return (0);
+}
diff --git a/ldpd/keepalive.c b/ldpd/keepalive.c
new file mode 100644
index 0000000..fd6770a
--- /dev/null
+++ b/ldpd/keepalive.c
@@ -0,0 +1,57 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+
+void
+send_keepalive(struct nbr *nbr)
+{
+	struct ibuf	*buf;
+	uint16_t	 size;
+
+	size = LDP_HDR_SIZE + LDP_MSG_SIZE;
+	if ((buf = ibuf_open(size)) == NULL)
+		fatal(__func__);
+
+	gen_ldp_hdr(buf, size);
+	size -= LDP_HDR_SIZE;
+	gen_msg_hdr(buf, MSG_TYPE_KEEPALIVE, size);
+
+	evbuf_enqueue(&nbr->tcp->wbuf, buf);
+}
+
+int
+recv_keepalive(struct nbr *nbr, char *buf, uint16_t len)
+{
+	struct ldp_msg ka;
+
+	memcpy(&ka, buf, sizeof(ka));
+	if (len != LDP_MSG_SIZE) {
+		session_shutdown(nbr, S_BAD_MSG_LEN, ka.msgid, ka.type);
+		return (-1);
+	}
+
+	if (nbr->state != NBR_STA_OPER)
+		nbr_fsm(nbr, NBR_EVT_KEEPALIVE_RCVD);
+
+	return (0);
+}
diff --git a/ldpd/l2vpn.c b/ldpd/l2vpn.c
new file mode 100644
index 0000000..2f208a9
--- /dev/null
+++ b/ldpd/l2vpn.c
@@ -0,0 +1,539 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2015 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ * Copyright (c) 2005 Claudio Jeker <claudio@openbsd.org>
+ * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "lde.h"
+#include "log.h"
+
+static void	 l2vpn_pw_fec(struct l2vpn_pw *, struct fec *);
+
+struct l2vpn *
+l2vpn_new(const char *name)
+{
+	struct l2vpn	*l2vpn;
+
+	if ((l2vpn = calloc(1, sizeof(*l2vpn))) == NULL)
+		fatal("l2vpn_new: calloc");
+
+	strlcpy(l2vpn->name, name, sizeof(l2vpn->name));
+
+	/* set default values */
+	l2vpn->mtu = DEFAULT_L2VPN_MTU;
+	l2vpn->pw_type = DEFAULT_PW_TYPE;
+
+	LIST_INIT(&l2vpn->if_list);
+	LIST_INIT(&l2vpn->pw_list);
+	LIST_INIT(&l2vpn->pw_inactive_list);
+
+	return (l2vpn);
+}
+
+struct l2vpn *
+l2vpn_find(struct ldpd_conf *xconf, const char *name)
+{
+	struct l2vpn	*l2vpn;
+
+	LIST_FOREACH(l2vpn, &xconf->l2vpn_list, entry)
+		if (strcmp(l2vpn->name, name) == 0)
+			return (l2vpn);
+
+	return (NULL);
+}
+
+void
+l2vpn_del(struct l2vpn *l2vpn)
+{
+	struct l2vpn_if		*lif;
+	struct l2vpn_pw		*pw;
+
+	while ((lif = LIST_FIRST(&l2vpn->if_list)) != NULL) {
+		LIST_REMOVE(lif, entry);
+		free(lif);
+	}
+	while ((pw = LIST_FIRST(&l2vpn->pw_list)) != NULL) {
+		l2vpn_pw_exit(pw);
+		LIST_REMOVE(pw, entry);
+		free(pw);
+	}
+	while ((pw = LIST_FIRST(&l2vpn->pw_inactive_list)) != NULL) {
+		LIST_REMOVE(pw, entry);
+		free(pw);
+	}
+
+	free(l2vpn);
+}
+
+void
+l2vpn_init(struct l2vpn *l2vpn)
+{
+	struct l2vpn_pw	*pw;
+
+	LIST_FOREACH(pw, &l2vpn->pw_list, entry)
+		l2vpn_pw_init(pw);
+}
+
+struct l2vpn_if *
+l2vpn_if_new(struct l2vpn *l2vpn, struct kif *kif)
+{
+	struct l2vpn_if	*lif;
+
+	if ((lif = calloc(1, sizeof(*lif))) == NULL)
+		fatal("l2vpn_if_new: calloc");
+
+	lif->l2vpn = l2vpn;
+	strlcpy(lif->ifname, kif->ifname, sizeof(lif->ifname));
+	lif->ifindex = kif->ifindex;
+	lif->flags = kif->flags;
+
+	return (lif);
+}
+
+struct l2vpn_if *
+l2vpn_if_find(struct l2vpn *l2vpn, unsigned int ifindex)
+{
+	struct l2vpn_if	*lif;
+
+	LIST_FOREACH(lif, &l2vpn->if_list, entry)
+		if (lif->ifindex == ifindex)
+			return (lif);
+
+	return (NULL);
+}
+
+struct l2vpn_if *
+l2vpn_if_find_name(struct l2vpn *l2vpn, const char *ifname)
+{
+	struct l2vpn_if	*lif;
+
+	LIST_FOREACH(lif, &l2vpn->if_list, entry)
+		if (strcmp(lif->ifname, ifname) == 0)
+			return (lif);
+
+	return (NULL);
+}
+
+
+struct l2vpn_pw *
+l2vpn_pw_new(struct l2vpn *l2vpn, struct kif *kif)
+{
+	struct l2vpn_pw	*pw;
+
+	if ((pw = calloc(1, sizeof(*pw))) == NULL)
+		fatal("l2vpn_pw_new: calloc");
+
+	pw->l2vpn = l2vpn;
+	strlcpy(pw->ifname, kif->ifname, sizeof(pw->ifname));
+	pw->ifindex = kif->ifindex;
+
+	return (pw);
+}
+
+struct l2vpn_pw *
+l2vpn_pw_find(struct l2vpn *l2vpn, unsigned int ifindex)
+{
+	struct l2vpn_pw	*pw;
+
+	LIST_FOREACH(pw, &l2vpn->pw_list, entry)
+		if (pw->ifindex == ifindex)
+			return (pw);
+	LIST_FOREACH(pw, &l2vpn->pw_inactive_list, entry)
+		if (pw->ifindex == ifindex)
+			return (pw);
+
+	return (NULL);
+}
+
+struct l2vpn_pw *
+l2vpn_pw_find_name(struct l2vpn *l2vpn, const char *ifname)
+{
+	struct l2vpn_pw	*pw;
+
+	LIST_FOREACH(pw, &l2vpn->pw_list, entry)
+		if (strcmp(pw->ifname, ifname) == 0)
+			return (pw);
+	LIST_FOREACH(pw, &l2vpn->pw_inactive_list, entry)
+		if (strcmp(pw->ifname, ifname) == 0)
+			return (pw);
+
+	return (NULL);
+}
+
+void
+l2vpn_pw_init(struct l2vpn_pw *pw)
+{
+	struct fec	 fec;
+
+	l2vpn_pw_reset(pw);
+
+	l2vpn_pw_fec(pw, &fec);
+	lde_kernel_insert(&fec, AF_INET, (union ldpd_addr*)&pw->lsr_id,
+	    0, (void *)pw);
+}
+
+void
+l2vpn_pw_exit(struct l2vpn_pw *pw)
+{
+	struct fec	 fec;
+
+	l2vpn_pw_fec(pw, &fec);
+	lde_kernel_remove(&fec, AF_INET, (union ldpd_addr*)&pw->lsr_id);
+}
+
+static void
+l2vpn_pw_fec(struct l2vpn_pw *pw, struct fec *fec)
+{
+	memset(fec, 0, sizeof(*fec));
+	fec->type = FEC_TYPE_PWID;
+	fec->u.pwid.type = pw->l2vpn->pw_type;
+	fec->u.pwid.pwid = pw->pwid;
+	fec->u.pwid.lsr_id = pw->lsr_id;
+}
+
+void
+l2vpn_pw_reset(struct l2vpn_pw *pw)
+{
+	pw->remote_group = 0;
+	pw->remote_mtu = 0;
+	pw->remote_status = 0;
+
+	if (pw->flags & F_PW_CWORD_CONF)
+		pw->flags |= F_PW_CWORD;
+	else
+		pw->flags &= ~F_PW_CWORD;
+
+	if (pw->flags & F_PW_STATUSTLV_CONF)
+		pw->flags |= F_PW_STATUSTLV;
+	else
+		pw->flags &= ~F_PW_STATUSTLV;
+}
+
+int
+l2vpn_pw_ok(struct l2vpn_pw *pw, struct fec_nh *fnh)
+{
+	struct fec		 fec;
+	struct fec_node		*fn;
+
+	/* check for a remote label */
+	if (fnh->remote_label == NO_LABEL)
+		return (0);
+
+	/* MTUs must match */
+	if (pw->l2vpn->mtu != pw->remote_mtu)
+		return (0);
+
+	/* check pw status if applicable */
+	if ((pw->flags & F_PW_STATUSTLV) &&
+	    pw->remote_status != PW_FORWARDING)
+		return (0);
+
+	/* check for a working lsp to the nexthop */
+	memset(&fec, 0, sizeof(fec));
+	switch (pw->af) {
+	case AF_INET:
+		fec.type = FEC_TYPE_IPV4;
+		fec.u.ipv4.prefix = pw->addr.v4;
+		fec.u.ipv4.prefixlen = 32;
+		break;
+	case AF_INET6:
+		fec.type = FEC_TYPE_IPV6;
+		fec.u.ipv6.prefix = pw->addr.v6;
+		fec.u.ipv6.prefixlen = 128;
+		break;
+	default:
+		fatalx("l2vpn_pw_ok: unknown af");
+	}
+
+	fn = (struct fec_node *)fec_find(&ft, &fec);
+	if (fn == NULL || fn->local_label == NO_LABEL)
+		return (0);
+	/*
+	 * Need to ensure that there's a label binding for all nexthops.
+	 * Otherwise, ECMP for this route could render the pseudowire unusable.
+	 */
+	LIST_FOREACH(fnh, &fn->nexthops, entry)
+		if (fnh->remote_label == NO_LABEL)
+			return (0);
+
+	return (1);
+}
+
+int
+l2vpn_pw_negotiate(struct lde_nbr *ln, struct fec_node *fn, struct map *map)
+{
+	struct l2vpn_pw		*pw;
+
+	/* NOTE: thanks martini & friends for all this mess */
+
+	pw = (struct l2vpn_pw *) fn->data;
+	if (pw == NULL)
+		/*
+		 * pseudowire not configured, return and record
+		 * the mapping later
+		 */
+		return (0);
+
+	/* RFC4447 - Section 6.2: control word negotiation */
+	if (fec_find(&ln->sent_map, &fn->fec)) {
+		if ((map->flags & F_MAP_PW_CWORD) &&
+		    !(pw->flags & F_PW_CWORD_CONF)) {
+			/* ignore the received label mapping */
+			return (1);
+		} else if (!(map->flags & F_MAP_PW_CWORD) &&
+		    (pw->flags & F_PW_CWORD_CONF)) {
+			/* TODO append a "Wrong C-bit" status code */
+			lde_send_labelwithdraw(ln, fn, NO_LABEL);
+
+			pw->flags &= ~F_PW_CWORD;
+			lde_send_labelmapping(ln, fn, 1);
+		}
+	} else if (map->flags & F_MAP_PW_CWORD) {
+		if (pw->flags & F_PW_CWORD_CONF)
+			pw->flags |= F_PW_CWORD;
+		else
+			/* act as if no label mapping had been received */
+			return (1);
+	} else
+		pw->flags &= ~F_PW_CWORD;
+
+	/* RFC4447 - Section 5.4.3: pseudowire status negotiation */
+	if (fec_find(&ln->recv_map, &fn->fec) == NULL &&
+	    !(map->flags & F_MAP_PW_STATUS))
+		pw->flags &= ~F_PW_STATUSTLV;
+
+	return (0);
+}
+
+void
+l2vpn_send_pw_status(uint32_t peerid, uint32_t status, struct fec *fec)
+{
+	struct notify_msg	 nm;
+
+	memset(&nm, 0, sizeof(nm));
+	nm.status = S_PW_STATUS;
+
+	nm.pw_status = status;
+	nm.flags |= F_NOTIF_PW_STATUS;
+
+	lde_fec2map(fec, &nm.fec);
+	nm.flags |= F_NOTIF_FEC;
+
+	lde_imsg_compose_ldpe(IMSG_NOTIFICATION_SEND, peerid, 0,
+	    &nm, sizeof(nm));
+}
+
+void
+l2vpn_recv_pw_status(struct lde_nbr *ln, struct notify_msg *nm)
+{
+	struct fec		 fec;
+	struct fec_node		*fn;
+	struct fec_nh		*fnh;
+	struct l2vpn_pw		*pw;
+
+	/* TODO group wildcard */
+	if (!(nm->fec.flags & F_MAP_PW_ID))
+		return;
+
+	lde_map2fec(&nm->fec, ln->id, &fec);
+	fn = (struct fec_node *)fec_find(&ft, &fec);
+	if (fn == NULL)
+		/* unknown fec */
+		return;
+
+	pw = (struct l2vpn_pw *) fn->data;
+	if (pw == NULL)
+		return;
+
+	fnh = fec_nh_find(fn, AF_INET, (union ldpd_addr *)&ln->id);
+	if (fnh == NULL)
+		return;
+
+	/* remote status didn't change */
+	if (pw->remote_status == nm->pw_status)
+		return;
+
+	pw->remote_status = nm->pw_status;
+
+	if (l2vpn_pw_ok(pw, fnh))
+		lde_send_change_klabel(fn, fnh);
+	else
+		lde_send_delete_klabel(fn, fnh);
+}
+
+void
+l2vpn_sync_pws(int af, union ldpd_addr *addr)
+{
+	struct l2vpn		*l2vpn;
+	struct l2vpn_pw		*pw;
+	struct fec		 fec;
+	struct fec_node		*fn;
+	struct fec_nh		*fnh;
+
+	LIST_FOREACH(l2vpn, &ldeconf->l2vpn_list, entry) {
+		LIST_FOREACH(pw, &l2vpn->pw_list, entry) {
+			if (af != pw->af || ldp_addrcmp(af, &pw->addr, addr))
+				continue;
+
+			l2vpn_pw_fec(pw, &fec);
+			fn = (struct fec_node *)fec_find(&ft, &fec);
+			if (fn == NULL)
+				continue;
+			fnh = fec_nh_find(fn, AF_INET, (union ldpd_addr *)
+			    &pw->lsr_id);
+			if (fnh == NULL)
+				continue;
+
+			if (l2vpn_pw_ok(pw, fnh))
+				lde_send_change_klabel(fn, fnh);
+			else
+				lde_send_delete_klabel(fn, fnh);
+		}
+	}
+}
+
+void
+l2vpn_pw_ctl(pid_t pid)
+{
+	struct l2vpn		*l2vpn;
+	struct l2vpn_pw		*pw;
+	static struct ctl_pw	 pwctl;
+
+	LIST_FOREACH(l2vpn, &ldeconf->l2vpn_list, entry)
+		LIST_FOREACH(pw, &l2vpn->pw_list, entry) {
+			memset(&pwctl, 0, sizeof(pwctl));
+			strlcpy(pwctl.l2vpn_name, pw->l2vpn->name,
+			    sizeof(pwctl.l2vpn_name));
+			strlcpy(pwctl.ifname, pw->ifname,
+			    sizeof(pwctl.ifname));
+			pwctl.pwid = pw->pwid;
+			pwctl.lsr_id = pw->lsr_id;
+			pwctl.status = pw->flags & F_PW_STATUS_UP;
+
+			lde_imsg_compose_ldpe(IMSG_CTL_SHOW_L2VPN_PW, 0,
+			    pid, &pwctl, sizeof(pwctl));
+		}
+}
+
+void
+l2vpn_binding_ctl(pid_t pid)
+{
+	struct fec		*f;
+	struct fec_node		*fn;
+	struct lde_map		*me;
+	struct l2vpn_pw		*pw;
+	static struct ctl_pw	 pwctl;
+
+	RB_FOREACH(f, fec_tree, &ft) {
+		if (f->type != FEC_TYPE_PWID)
+			continue;
+
+		fn = (struct fec_node *)f;
+		if (fn->local_label == NO_LABEL &&
+		    LIST_EMPTY(&fn->downstream))
+			continue;
+
+		memset(&pwctl, 0, sizeof(pwctl));
+		pwctl.type = f->u.pwid.type;
+		pwctl.pwid = f->u.pwid.pwid;
+		pwctl.lsr_id = f->u.pwid.lsr_id;
+
+		pw = (struct l2vpn_pw *) fn->data;
+		if (pw) {
+			pwctl.local_label = fn->local_label;
+			pwctl.local_gid = 0;
+			pwctl.local_ifmtu = pw->l2vpn->mtu;
+			pwctl.local_cword = (pw->flags & F_PW_CWORD_CONF) ?
+			    1 : 0;
+		} else
+			pwctl.local_label = NO_LABEL;
+
+		LIST_FOREACH(me, &fn->downstream, entry)
+			if (f->u.pwid.lsr_id.s_addr == me->nexthop->id.s_addr)
+				break;
+
+		if (me) {
+			pwctl.remote_label = me->map.label;
+			pwctl.remote_gid = me->map.fec.pwid.group_id;
+			if (me->map.flags & F_MAP_PW_IFMTU)
+				pwctl.remote_ifmtu = me->map.fec.pwid.ifmtu;
+			if (pw)
+				pwctl.remote_cword = (pw->flags & F_PW_CWORD) ?
+				    1 : 0;
+
+			lde_imsg_compose_ldpe(IMSG_CTL_SHOW_L2VPN_BINDING,
+			    0, pid, &pwctl, sizeof(pwctl));
+		} else if (pw) {
+			pwctl.remote_label = NO_LABEL;
+
+			lde_imsg_compose_ldpe(IMSG_CTL_SHOW_L2VPN_BINDING,
+			    0, pid, &pwctl, sizeof(pwctl));
+		}
+	}
+}
+
+/* ldpe */
+
+void
+ldpe_l2vpn_init(struct l2vpn *l2vpn)
+{
+	struct l2vpn_pw		*pw;
+
+	LIST_FOREACH(pw, &l2vpn->pw_list, entry)
+		ldpe_l2vpn_pw_init(pw);
+}
+
+void
+ldpe_l2vpn_exit(struct l2vpn *l2vpn)
+{
+	struct l2vpn_pw		*pw;
+
+	LIST_FOREACH(pw, &l2vpn->pw_list, entry)
+		ldpe_l2vpn_pw_exit(pw);
+}
+
+void
+ldpe_l2vpn_pw_init(struct l2vpn_pw *pw)
+{
+	struct tnbr		*tnbr;
+
+	tnbr = tnbr_find(leconf, pw->af, &pw->addr);
+	if (tnbr == NULL) {
+		tnbr = tnbr_new(pw->af, &pw->addr);
+		tnbr_update(tnbr);
+		LIST_INSERT_HEAD(&leconf->tnbr_list, tnbr, entry);
+	}
+
+	tnbr->pw_count++;
+}
+
+void
+ldpe_l2vpn_pw_exit(struct l2vpn_pw *pw)
+{
+	struct tnbr		*tnbr;
+
+	tnbr = tnbr_find(leconf, pw->af, &pw->addr);
+	if (tnbr) {
+		tnbr->pw_count--;
+		tnbr_check(tnbr);
+	}
+}
diff --git a/ldpd/labelmapping.c b/ldpd/labelmapping.c
new file mode 100644
index 0000000..808f541
--- /dev/null
+++ b/ldpd/labelmapping.c
@@ -0,0 +1,725 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2014, 2015 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+
+#include "mpls.h"
+
+static void	 enqueue_pdu(struct nbr *, struct ibuf *, uint16_t);
+static void	 gen_label_tlv(struct ibuf *, uint32_t);
+static int	 tlv_decode_label(struct nbr *, struct ldp_msg *, char *,
+		    uint16_t, uint32_t *);
+static void	 gen_reqid_tlv(struct ibuf *, uint32_t);
+
+static void
+enqueue_pdu(struct nbr *nbr, struct ibuf *buf, uint16_t size)
+{
+	struct ldp_hdr		*ldp_hdr;
+
+	ldp_hdr = ibuf_seek(buf, 0, sizeof(struct ldp_hdr));
+	ldp_hdr->length = htons(size);
+	evbuf_enqueue(&nbr->tcp->wbuf, buf);
+}
+
+/* Generic function that handles all Label Message types */
+void
+send_labelmessage(struct nbr *nbr, uint16_t type, struct mapping_head *mh)
+{
+	struct ibuf		*buf = NULL;
+	struct mapping_entry	*me;
+	uint16_t		 msg_size, size = 0;
+	int			 first = 1;
+
+	/* nothing to send */
+	if (TAILQ_EMPTY(mh))
+		return;
+
+	while ((me = TAILQ_FIRST(mh)) != NULL) {
+		/* generate pdu */
+		if (first) {
+			if ((buf = ibuf_open(nbr->max_pdu_len +
+			    LDP_HDR_DEAD_LEN)) == NULL)
+				fatal(__func__);
+
+			/* real size will be set up later */
+			gen_ldp_hdr(buf, 0);
+
+			size = LDP_HDR_PDU_LEN;
+			first = 0;
+		}
+
+		/* calculate size */
+		msg_size = LDP_MSG_SIZE + TLV_HDR_LEN;
+
+		switch (me->map.type) {
+		case MAP_TYPE_WILDCARD:
+			msg_size += FEC_ELM_WCARD_LEN;
+			break;
+		case MAP_TYPE_PREFIX:
+			msg_size += FEC_ELM_PREFIX_MIN_LEN +
+			    PREFIX_SIZE(me->map.fec.prefix.prefixlen);
+			break;
+		case MAP_TYPE_PWID:
+			msg_size += FEC_PWID_ELM_MIN_LEN;
+
+			if (me->map.flags & F_MAP_PW_ID)
+				msg_size += sizeof(uint32_t);
+			if (me->map.flags & F_MAP_PW_IFMTU)
+				msg_size += FEC_SUBTLV_IFMTU_LEN;
+	    		if (me->map.flags & F_MAP_PW_STATUS)
+				msg_size += PW_STATUS_TLV_LEN;
+			break;
+		}
+
+		if (me->map.label != NO_LABEL)
+			msg_size += LABEL_TLV_LEN;
+		if (me->map.flags & F_MAP_REQ_ID)
+			msg_size += REQID_TLV_LEN;
+
+		/* maximum pdu length exceeded, we need a new ldp pdu */
+		if (size + msg_size > nbr->max_pdu_len) {
+			enqueue_pdu(nbr, buf, size);
+			first = 1;
+			continue;
+		}
+
+		size += msg_size;
+
+		/* append message and tlvs */
+		gen_msg_hdr(buf, type, msg_size);
+		gen_fec_tlv(buf, &me->map);
+		if (me->map.label != NO_LABEL)
+			gen_label_tlv(buf, me->map.label);
+		if (me->map.flags & F_MAP_REQ_ID)
+			gen_reqid_tlv(buf, me->map.requestid);
+	    	if (me->map.flags & F_MAP_PW_STATUS)
+			gen_pw_status_tlv(buf, me->map.pw_status);
+
+		TAILQ_REMOVE(mh, me, entry);
+		free(me);
+	}
+
+	enqueue_pdu(nbr, buf, size);
+
+	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
+}
+
+/* Generic function that handles all Label Message types */
+int
+recv_labelmessage(struct nbr *nbr, char *buf, uint16_t len, uint16_t type)
+{
+	struct ldp_msg		 lm;
+	struct tlv		 ft;
+	uint32_t		 label = NO_LABEL, reqid = 0;
+	uint32_t		 pw_status = 0;
+	uint8_t			 flags = 0;
+	int			 feclen, lbllen, tlen;
+	struct mapping_entry	*me;
+	struct mapping_head	 mh;
+	struct map		 map;
+
+	memcpy(&lm, buf, sizeof(lm));
+	buf += LDP_MSG_SIZE;
+	len -= LDP_MSG_SIZE;
+
+	/* FEC TLV */
+	if (len < sizeof(ft)) {
+		session_shutdown(nbr, S_BAD_TLV_LEN, lm.msgid, lm.type);
+		return (-1);
+	}
+
+	memcpy(&ft, buf, sizeof(ft));
+	if (ntohs(ft.type) != TLV_TYPE_FEC) {
+		send_notification_nbr(nbr, S_MISS_MSG, lm.msgid, lm.type);
+		return (-1);
+	}
+	feclen = ntohs(ft.length);
+
+	if (feclen > len - TLV_HDR_LEN) {
+		session_shutdown(nbr, S_BAD_TLV_LEN, lm.msgid, lm.type);
+		return (-1);
+	}
+
+	buf += TLV_HDR_LEN;	/* just advance to the end of the fec header */
+	len -= TLV_HDR_LEN;
+
+	TAILQ_INIT(&mh);
+	do {
+		memset(&map, 0, sizeof(map));
+		map.messageid = lm.msgid;
+
+		if ((tlen = tlv_decode_fec_elm(nbr, &lm, buf, feclen,
+		    &map)) == -1)
+			goto err;
+		if (map.type == MAP_TYPE_PWID &&
+		    !(map.flags & F_MAP_PW_ID) &&
+		    type != MSG_TYPE_LABELWITHDRAW &&
+		    type != MSG_TYPE_LABELRELEASE) {
+			send_notification_nbr(nbr, S_MISS_MSG, lm.msgid,
+			    lm.type);
+			return (-1);
+		}
+
+		/*
+		 * The Wildcard FEC Element can be used only in the
+		 * Label Withdraw and Label Release messages.
+		 */
+		if (map.type == MAP_TYPE_WILDCARD) {
+			switch (type) {
+			case MSG_TYPE_LABELMAPPING:
+			case MSG_TYPE_LABELREQUEST:
+			case MSG_TYPE_LABELABORTREQ:
+				session_shutdown(nbr, S_BAD_TLV_VAL, lm.msgid,
+				    lm.type);
+				goto err;
+			default:
+				break;
+			}
+		}
+
+		/*
+		 * LDP supports the use of multiple FEC Elements per
+		 * FEC for the Label Mapping message only.
+		 */
+		if (type != MSG_TYPE_LABELMAPPING &&
+		    tlen != feclen) {
+			session_shutdown(nbr, S_BAD_TLV_VAL, lm.msgid,
+			    lm.type);
+			goto err;
+		}
+
+		mapping_list_add(&mh, &map);
+
+		buf += tlen;
+		len -= tlen;
+		feclen -= tlen;
+	} while (feclen > 0);
+
+	/* Mandatory Label TLV */
+	if (type == MSG_TYPE_LABELMAPPING) {
+		lbllen = tlv_decode_label(nbr, &lm, buf, len, &label);
+		if (lbllen == -1)
+			goto err;
+
+		buf += lbllen;
+		len -= lbllen;
+	}
+
+	/* Optional Parameters */
+	while (len > 0) {
+		struct tlv 	tlv;
+		uint32_t	reqbuf, labelbuf, statusbuf;
+
+		if (len < sizeof(tlv)) {
+			session_shutdown(nbr, S_BAD_TLV_LEN, lm.msgid,
+			    lm.type);
+			goto err;
+		}
+
+		memcpy(&tlv, buf, sizeof(tlv));
+		if (ntohs(tlv.length) != len - TLV_HDR_LEN) {
+			session_shutdown(nbr, S_BAD_TLV_LEN, lm.msgid,
+			    lm.type);
+			goto err;
+		}
+		buf += TLV_HDR_LEN;
+		len -= TLV_HDR_LEN;
+
+		switch (ntohs(tlv.type) & ~UNKNOWN_FLAG) {
+		case TLV_TYPE_LABELREQUEST:
+			switch (type) {
+			case MSG_TYPE_LABELMAPPING:
+			case MSG_TYPE_LABELREQUEST:
+				if (ntohs(tlv.length) != 4) {
+					session_shutdown(nbr, S_BAD_TLV_LEN,
+					    lm.msgid, lm.type);
+					goto err;
+				}
+
+				flags |= F_MAP_REQ_ID;
+				memcpy(&reqbuf, buf, sizeof(reqbuf));
+				reqid = ntohl(reqbuf);
+				break;
+			default:
+				/* ignore */
+				break;
+			}
+			break;
+		case TLV_TYPE_HOPCOUNT:
+		case TLV_TYPE_PATHVECTOR:
+			/* TODO just ignore for now */
+			break;
+		case TLV_TYPE_GENERICLABEL:
+			switch (type) {
+			case MSG_TYPE_LABELWITHDRAW:
+			case MSG_TYPE_LABELRELEASE:
+				if (ntohs(tlv.length) != 4) {
+					session_shutdown(nbr, S_BAD_TLV_LEN,
+					    lm.msgid, lm.type);
+					goto err;
+				}
+
+				memcpy(&labelbuf, buf, sizeof(labelbuf));
+				label = ntohl(labelbuf);
+				break;
+			default:
+				/* ignore */
+				break;
+			}
+			break;
+		case TLV_TYPE_ATMLABEL:
+		case TLV_TYPE_FRLABEL:
+			switch (type) {
+			case MSG_TYPE_LABELWITHDRAW:
+			case MSG_TYPE_LABELRELEASE:
+				/* unsupported */
+				session_shutdown(nbr, S_BAD_TLV_VAL, lm.msgid,
+				    lm.type);
+				goto err;
+				break;
+			default:
+				/* ignore */
+				break;
+			}
+			break;
+		case TLV_TYPE_PW_STATUS:
+			switch (type) {
+			case MSG_TYPE_LABELMAPPING:
+				if (ntohs(tlv.length) != 4) {
+					session_shutdown(nbr, S_BAD_TLV_LEN,
+					    lm.msgid, lm.type);
+					goto err;
+				}
+
+				flags |= F_MAP_PW_STATUS;
+				memcpy(&statusbuf, buf, sizeof(statusbuf));
+				pw_status = ntohl(statusbuf);
+				break;
+			default:
+				/* ignore */
+				break;
+			}
+			break;
+		default:
+			if (!(ntohs(tlv.type) & UNKNOWN_FLAG)) {
+				send_notification_nbr(nbr, S_UNKNOWN_TLV,
+				    lm.msgid, lm.type);
+			}
+			/* ignore unknown tlv */
+			break;
+		}
+		buf += ntohs(tlv.length);
+		len -= ntohs(tlv.length);
+	}
+
+	/* notify lde about the received message. */
+	while ((me = TAILQ_FIRST(&mh)) != NULL) {
+		int imsg_type = IMSG_NONE;
+
+		me->map.flags |= flags;
+		switch (me->map.type) {
+		case MAP_TYPE_PREFIX:
+			switch (me->map.fec.prefix.af) {
+			case AF_IPV4:
+				if (label == MPLS_LABEL_IPV6NULL) {
+					session_shutdown(nbr, S_BAD_TLV_VAL,
+					    lm.msgid, lm.type);
+					goto err;
+				}
+				if (!nbr->v4_enabled)
+					goto next;
+				break;
+			case AF_IPV6:
+				if (label == MPLS_LABEL_IPV4NULL) {
+					session_shutdown(nbr, S_BAD_TLV_VAL,
+					    lm.msgid, lm.type);
+					goto err;
+				}
+				if (!nbr->v6_enabled)
+					goto next;
+				break;
+			default:
+				fatalx("recv_labelmessage: unknown af");
+			}
+			break;
+		case MAP_TYPE_PWID:
+			if (label <= MPLS_LABEL_RESERVED_MAX) {
+				session_shutdown(nbr, S_BAD_TLV_VAL, lm.msgid,
+				    lm.type);
+				goto err;
+			}
+			if (me->map.flags & F_MAP_PW_STATUS)
+				me->map.pw_status = pw_status;
+			break;
+		default:
+			break;
+		}
+		me->map.label = label;
+		if (me->map.flags & F_MAP_REQ_ID)
+			me->map.requestid = reqid;
+
+		switch (type) {
+		case MSG_TYPE_LABELMAPPING:
+			log_debug("label mapping from nbr %s, FEC %s, "
+			    "label %u", inet_ntoa(nbr->id),
+			    log_map(&me->map), me->map.label);
+			imsg_type = IMSG_LABEL_MAPPING;
+			break;
+		case MSG_TYPE_LABELREQUEST:
+			log_debug("label request from nbr %s, FEC %s",
+			    inet_ntoa(nbr->id), log_map(&me->map));
+			imsg_type = IMSG_LABEL_REQUEST;
+			break;
+		case MSG_TYPE_LABELWITHDRAW:
+			log_debug("label withdraw from nbr %s, FEC %s",
+			    inet_ntoa(nbr->id), log_map(&me->map));
+			imsg_type = IMSG_LABEL_WITHDRAW;
+			break;
+		case MSG_TYPE_LABELRELEASE:
+			log_debug("label release from nbr %s, FEC %s",
+			    inet_ntoa(nbr->id), log_map(&me->map));
+			imsg_type = IMSG_LABEL_RELEASE;
+			break;
+		case MSG_TYPE_LABELABORTREQ:
+			log_debug("label abort from nbr %s, FEC %s",
+			    inet_ntoa(nbr->id), log_map(&me->map));
+			imsg_type = IMSG_LABEL_ABORT;
+			break;
+		default:
+			break;
+		}
+
+		ldpe_imsg_compose_lde(imsg_type, nbr->peerid, 0, &me->map,
+		    sizeof(struct map));
+
+next:
+		TAILQ_REMOVE(&mh, me, entry);
+		free(me);
+	}
+
+	return (0);
+
+err:
+	mapping_list_clr(&mh);
+
+	return (-1);
+}
+
+/* Other TLV related functions */
+static void
+gen_label_tlv(struct ibuf *buf, uint32_t label)
+{
+	struct label_tlv	lt;
+
+	lt.type = htons(TLV_TYPE_GENERICLABEL);
+	lt.length = htons(sizeof(label));
+	lt.label = htonl(label);
+
+	ibuf_add(buf, &lt, sizeof(lt));
+}
+
+static int
+tlv_decode_label(struct nbr *nbr, struct ldp_msg *lm, char *buf,
+    uint16_t len, uint32_t *label)
+{
+	struct label_tlv lt;
+
+	if (len < sizeof(lt)) {
+		session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid, lm->type);
+		return (-1);
+	}
+	memcpy(&lt, buf, sizeof(lt));
+
+	if (!(ntohs(lt.type) & TLV_TYPE_GENERICLABEL)) {
+		send_notification_nbr(nbr, S_MISS_MSG, lm->msgid, lm->type);
+		return (-1);
+	}
+
+	switch (htons(lt.type)) {
+	case TLV_TYPE_GENERICLABEL:
+		if (ntohs(lt.length) != sizeof(lt) - TLV_HDR_LEN) {
+			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
+			    lm->type);
+			return (-1);
+		}
+
+		*label = ntohl(lt.label);
+		if (*label > MPLS_LABEL_MAX ||
+		    (*label <= MPLS_LABEL_RESERVED_MAX &&
+		     *label != MPLS_LABEL_IPV4NULL &&
+		     *label != MPLS_LABEL_IPV6NULL &&
+		     *label != MPLS_LABEL_IMPLNULL)) {
+			session_shutdown(nbr, S_BAD_TLV_VAL, lm->msgid,
+			    lm->type);
+			return (-1);
+		}
+		break;
+	case TLV_TYPE_ATMLABEL:
+	case TLV_TYPE_FRLABEL:
+	default:
+		/* unsupported */
+		session_shutdown(nbr, S_BAD_TLV_VAL, lm->msgid, lm->type);
+		return (-1);
+	}
+
+	return (sizeof(lt));
+}
+
+static void
+gen_reqid_tlv(struct ibuf *buf, uint32_t reqid)
+{
+	struct reqid_tlv	rt;
+
+	rt.type = htons(TLV_TYPE_LABELREQUEST);
+	rt.length = htons(sizeof(reqid));
+	rt.reqid = htonl(reqid);
+
+	ibuf_add(buf, &rt, sizeof(rt));
+}
+
+void
+gen_pw_status_tlv(struct ibuf *buf, uint32_t status)
+{
+	struct pw_status_tlv	st;
+
+	st.type = htons(TLV_TYPE_PW_STATUS);
+	st.length = htons(sizeof(status));
+	st.value = htonl(status);
+
+	ibuf_add(buf, &st, sizeof(st));
+}
+
+void
+gen_fec_tlv(struct ibuf *buf, struct map *map)
+{
+	struct tlv	ft;
+	uint16_t	family, len, pw_type, ifmtu;
+	uint8_t		pw_len = 0;
+	uint32_t	group_id, pwid;
+
+	ft.type = htons(TLV_TYPE_FEC);
+
+	switch (map->type) {
+	case MAP_TYPE_WILDCARD:
+		ft.length = htons(sizeof(uint8_t));
+		ibuf_add(buf, &ft, sizeof(ft));
+		ibuf_add(buf, &map->type, sizeof(map->type));
+		break;
+	case MAP_TYPE_PREFIX:
+		len = PREFIX_SIZE(map->fec.prefix.prefixlen);
+		ft.length = htons(sizeof(map->type) + sizeof(family) +
+		    sizeof(map->fec.prefix.prefixlen) + len);
+		ibuf_add(buf, &ft, sizeof(ft));
+
+		ibuf_add(buf, &map->type, sizeof(map->type));
+		family = htons(map->fec.prefix.af);
+		ibuf_add(buf, &family, sizeof(family));
+		ibuf_add(buf, &map->fec.prefix.prefixlen,
+		    sizeof(map->fec.prefix.prefixlen));
+		if (len)
+			ibuf_add(buf, &map->fec.prefix.prefix, len);
+		break;
+	case MAP_TYPE_PWID:
+		if (map->flags & F_MAP_PW_ID)
+			pw_len += sizeof(uint32_t);
+		if (map->flags & F_MAP_PW_IFMTU)
+			pw_len += FEC_SUBTLV_IFMTU_LEN;
+
+		len = FEC_PWID_ELM_MIN_LEN + pw_len;
+
+		ft.length = htons(len);
+		ibuf_add(buf, &ft, sizeof(ft));
+
+		ibuf_add(buf, &map->type, sizeof(uint8_t));
+		pw_type = map->fec.pwid.type;
+		if (map->flags & F_MAP_PW_CWORD)
+			pw_type |= CONTROL_WORD_FLAG;
+		pw_type = htons(pw_type);
+		ibuf_add(buf, &pw_type, sizeof(uint16_t));
+		ibuf_add(buf, &pw_len, sizeof(uint8_t));
+		group_id = htonl(map->fec.pwid.group_id);
+		ibuf_add(buf, &group_id, sizeof(uint32_t));
+		if (map->flags & F_MAP_PW_ID) {
+			pwid = htonl(map->fec.pwid.pwid);
+			ibuf_add(buf, &pwid, sizeof(uint32_t));
+		}
+		if (map->flags & F_MAP_PW_IFMTU) {
+			struct subtlv 	stlv;
+
+			stlv.type = SUBTLV_IFMTU;
+			stlv.length = FEC_SUBTLV_IFMTU_LEN;
+			ibuf_add(buf, &stlv, sizeof(uint16_t));
+
+			ifmtu = htons(map->fec.pwid.ifmtu);
+			ibuf_add(buf, &ifmtu, sizeof(uint16_t));
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+int
+tlv_decode_fec_elm(struct nbr *nbr, struct ldp_msg *lm, char *buf,
+    uint16_t len, struct map *map)
+{
+	uint16_t	off = 0;
+	uint8_t		pw_len;
+
+	map->type = *buf;
+	off += sizeof(uint8_t);
+
+	switch (map->type) {
+	case MAP_TYPE_WILDCARD:
+		if (len == FEC_ELM_WCARD_LEN)
+			return (off);
+		else {
+			session_shutdown(nbr, S_BAD_TLV_VAL, lm->msgid,
+			    lm->type);
+			return (-1);
+		}
+		break;
+	case MAP_TYPE_PREFIX:
+		if (len < FEC_ELM_PREFIX_MIN_LEN) {
+			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
+			    lm->type);
+			return (-1);
+		}
+
+		/* Address Family */
+		memcpy(&map->fec.prefix.af, buf + off,
+		    sizeof(map->fec.prefix.af));
+		map->fec.prefix.af = ntohs(map->fec.prefix.af);
+		off += sizeof(map->fec.prefix.af);
+		if (map->fec.prefix.af != AF_IPV4 &&
+		    map->fec.prefix.af != AF_IPV6) {
+			send_notification_nbr(nbr, S_UNSUP_ADDR, lm->msgid,
+			    lm->type);
+			return (-1);
+		}
+
+		/* Prefix Length */
+		map->fec.prefix.prefixlen = buf[off];
+		off += sizeof(uint8_t);
+		if (len < off + PREFIX_SIZE(map->fec.prefix.prefixlen)) {
+			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
+			    lm->type);
+			return (-1);
+		}
+
+		/* Prefix */
+		memset(&map->fec.prefix.prefix, 0,
+		    sizeof(map->fec.prefix.prefix));
+		memcpy(&map->fec.prefix.prefix, buf + off,
+		    PREFIX_SIZE(map->fec.prefix.prefixlen));
+
+		return (off + PREFIX_SIZE(map->fec.prefix.prefixlen));
+	case MAP_TYPE_PWID:
+		if (len < FEC_PWID_ELM_MIN_LEN) {
+			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
+			    lm->type);
+			return (-1);
+		}
+
+		/* PW type */
+		memcpy(&map->fec.pwid.type, buf + off, sizeof(uint16_t));
+		map->fec.pwid.type = ntohs(map->fec.pwid.type);
+		if (map->fec.pwid.type & CONTROL_WORD_FLAG) {
+			map->flags |= F_MAP_PW_CWORD;
+			map->fec.pwid.type &= ~CONTROL_WORD_FLAG;
+		}
+		off += sizeof(uint16_t);
+
+		/* PW info Length */
+		pw_len = buf[off];
+		off += sizeof(uint8_t);
+
+		if (len != FEC_PWID_ELM_MIN_LEN + pw_len) {
+			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
+			    lm->type);
+			return (-1);
+		}
+
+		/* Group ID */
+		memcpy(&map->fec.pwid.group_id, buf + off, sizeof(uint32_t));
+		map->fec.pwid.group_id = ntohl(map->fec.pwid.group_id);
+		off += sizeof(uint32_t);
+
+		/* PW ID */
+		if (pw_len == 0)
+			return (off);
+
+		if (pw_len < sizeof(uint32_t)) {
+			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
+			    lm->type);
+			return (-1);
+		}
+
+		memcpy(&map->fec.pwid.pwid, buf + off, sizeof(uint32_t));
+		map->fec.pwid.pwid = ntohl(map->fec.pwid.pwid);
+		map->flags |= F_MAP_PW_ID;
+		off += sizeof(uint32_t);
+		pw_len -= sizeof(uint32_t);
+
+		/* Optional Interface Parameter Sub-TLVs */
+		while (pw_len > 0) {
+			struct subtlv 	stlv;
+
+			if (pw_len < sizeof(stlv)) {
+				session_shutdown(nbr, S_BAD_TLV_LEN,
+				    lm->msgid, lm->type);
+				return (-1);
+			}
+
+			memcpy(&stlv, buf + off, sizeof(stlv));
+			off += SUBTLV_HDR_LEN;
+			pw_len -= SUBTLV_HDR_LEN;
+
+			switch (stlv.type) {
+			case SUBTLV_IFMTU:
+				if (stlv.length != FEC_SUBTLV_IFMTU_LEN) {
+					session_shutdown(nbr, S_BAD_TLV_LEN,
+					    lm->msgid, lm->type);
+					return (-1);
+				}
+				memcpy(&map->fec.pwid.ifmtu, buf + off,
+				    sizeof(uint16_t));
+				map->fec.pwid.ifmtu = ntohs(map->fec.pwid.ifmtu);
+				map->flags |= F_MAP_PW_IFMTU;
+				break;
+			default:
+				/* ignore */
+				break;
+			}
+			off += stlv.length - SUBTLV_HDR_LEN;
+			pw_len -= stlv.length - SUBTLV_HDR_LEN;
+		}
+
+		return (off);
+	default:
+		send_notification_nbr(nbr, S_UNKNOWN_FEC, lm->msgid, lm->type);
+		break;
+	}
+
+	return (-1);
+}
diff --git a/ldpd/lde.c b/ldpd/lde.c
new file mode 100644
index 0000000..8639e5f
--- /dev/null
+++ b/ldpd/lde.c
@@ -0,0 +1,1276 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2004, 2005 Claudio Jeker <claudio@openbsd.org>
+ * Copyright (c) 2004 Esben Norby <norby@openbsd.org>
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldp.h"
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+#include "lde.h"
+
+#include <lib/log.h>
+#include "memory.h"
+#include "privs.h"
+#include "sigevent.h"
+#include "mpls.h"
+
+static void		 lde_shutdown(void);
+static int		 lde_imsg_compose_parent(int, pid_t, void *, uint16_t);
+static int		 lde_dispatch_imsg(struct thread *);
+static int		 lde_dispatch_parent(struct thread *);
+static __inline		 int lde_nbr_compare(struct lde_nbr *,
+			    struct lde_nbr *);
+static struct lde_nbr	*lde_nbr_new(uint32_t, struct lde_nbr *);
+static void		 lde_nbr_del(struct lde_nbr *);
+static struct lde_nbr	*lde_nbr_find(uint32_t);
+static void		 lde_nbr_clear(void);
+static void		 lde_map_free(void *);
+static int		 lde_address_add(struct lde_nbr *, struct lde_addr *);
+static int		 lde_address_del(struct lde_nbr *, struct lde_addr *);
+static void		 lde_address_list_free(struct lde_nbr *);
+
+RB_GENERATE(nbr_tree, lde_nbr, entry, lde_nbr_compare)
+
+struct ldpd_conf	*ldeconf;
+struct nbr_tree		 lde_nbrs = RB_INITIALIZER(&lde_nbrs);
+
+static struct imsgev	*iev_ldpe;
+static struct imsgev	*iev_main;
+
+/* Master of threads. */
+struct thread_master *master;
+
+/* lde privileges */
+static zebra_capabilities_t _caps_p [] =
+{
+	/* none */
+};
+
+static struct zebra_privs_t lde_privs =
+{
+#if defined(QUAGGA_USER) && defined(QUAGGA_GROUP)
+	.user = QUAGGA_USER,
+	.group = QUAGGA_GROUP,
+#endif
+#if defined(VTY_GROUP)
+	.vty_group = VTY_GROUP,
+#endif
+	.caps_p = _caps_p,
+	.cap_num_p = array_size(_caps_p),
+	.cap_num_i = 0
+};
+
+/* SIGINT / SIGTERM handler. */
+static void
+sigint(void)
+{
+	lde_shutdown();
+}
+
+static struct quagga_signal_t lde_signals[] =
+{
+	{
+		.signal = SIGINT,
+		.handler = &sigint,
+	},
+	{
+		.signal = SIGTERM,
+		.handler = &sigint,
+	},
+};
+
+/* label decision engine */
+pid_t
+lde(void)
+{
+	struct thread		 thread;
+	struct timeval		 now;
+
+	ldeconf = config_new_empty();
+
+	zlog_set_level(NULL, ZLOG_DEST_STDOUT, zlog_default->default_lvl);
+
+#ifdef HAVE_SETPROCTITLE
+	setproctitle("label decision engine");
+#endif
+	ldpd_process = PROC_LDE_ENGINE;
+
+	/* drop privileges */
+	zprivs_init(&lde_privs);
+
+#ifdef HAVE_PLEDGE
+	if (pledge("stdio recvfd", NULL) == -1)
+		fatal("pledge");
+#endif
+
+	master = thread_master_create();
+
+	/* setup signal handler */
+	signal_init(master, array_size(lde_signals), lde_signals);
+
+	/* setup pipe and event handler to the parent process */
+	if ((iev_main = malloc(sizeof(struct imsgev))) == NULL)
+		fatal(NULL);
+	imsg_init(&iev_main->ibuf, 3);
+	iev_main->handler_read = lde_dispatch_parent;
+	iev_main->ev_read = thread_add_read(master, iev_main->handler_read,
+	    iev_main, iev_main->ibuf.fd);
+	iev_main->handler_write = ldp_write_handler;
+	iev_main->ev_write = NULL;
+
+	/* start the LIB garbage collector */
+	lde_gc_start_timer();
+
+	gettimeofday(&now, NULL);
+	global.uptime = now.tv_sec;
+
+	/* Fetch next active thread. */
+	while (thread_fetch(master, &thread))
+		thread_call(&thread);
+
+	/* NOTREACHED */
+	return (0);
+}
+
+static void
+lde_shutdown(void)
+{
+	lde_gc_stop_timer();
+	lde_nbr_clear();
+	fec_tree_clear();
+
+	config_clear(ldeconf);
+
+	msgbuf_clear(&iev_ldpe->ibuf.w);
+	free(iev_ldpe);
+	msgbuf_clear(&iev_main->ibuf.w);
+	free(iev_main);
+
+	log_info("label decision engine exiting");
+	_exit(0);
+}
+
+/* imesg */
+static int
+lde_imsg_compose_parent(int type, pid_t pid, void *data, uint16_t datalen)
+{
+	return (imsg_compose_event(iev_main, type, 0, pid, -1, data, datalen));
+}
+
+int
+lde_imsg_compose_ldpe(int type, uint32_t peerid, pid_t pid, void *data,
+    uint16_t datalen)
+{
+	return (imsg_compose_event(iev_ldpe, type, peerid, pid,
+	     -1, data, datalen));
+}
+
+/* ARGSUSED */
+static int
+lde_dispatch_imsg(struct thread *thread)
+{
+	struct imsgev		*iev = THREAD_ARG(thread);
+	struct imsgbuf		*ibuf = &iev->ibuf;
+	struct imsg		 imsg;
+	struct lde_nbr		*ln;
+	struct map		 map;
+	struct lde_addr		 lde_addr;
+	struct notify_msg	 nm;
+	ssize_t			 n;
+	int			 shut = 0;
+
+	iev->ev_read = NULL;
+
+	if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
+		fatal("imsg_read error");
+	if (n == 0)	/* connection closed */
+		shut = 1;
+
+	for (;;) {
+		if ((n = imsg_get(ibuf, &imsg)) == -1)
+			fatal("lde_dispatch_imsg: imsg_get error");
+		if (n == 0)
+			break;
+
+		switch (imsg.hdr.type) {
+		case IMSG_LABEL_MAPPING_FULL:
+			ln = lde_nbr_find(imsg.hdr.peerid);
+			if (ln == NULL) {
+				log_debug("%s: cannot find lde neighbor",
+				    __func__);
+				break;
+			}
+
+			fec_snap(ln);
+			break;
+		case IMSG_LABEL_MAPPING:
+		case IMSG_LABEL_REQUEST:
+		case IMSG_LABEL_RELEASE:
+		case IMSG_LABEL_WITHDRAW:
+		case IMSG_LABEL_ABORT:
+			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(map))
+				fatalx("lde_dispatch_imsg: wrong imsg len");
+			memcpy(&map, imsg.data, sizeof(map));
+
+			ln = lde_nbr_find(imsg.hdr.peerid);
+			if (ln == NULL) {
+				log_debug("%s: cannot find lde neighbor",
+				    __func__);
+				break;
+			}
+
+			switch (imsg.hdr.type) {
+			case IMSG_LABEL_MAPPING:
+				lde_check_mapping(&map, ln);
+				break;
+			case IMSG_LABEL_REQUEST:
+				lde_check_request(&map, ln);
+				break;
+			case IMSG_LABEL_RELEASE:
+				if (map.type == MAP_TYPE_WILDCARD)
+					lde_check_release_wcard(&map, ln);
+				else
+					lde_check_release(&map, ln);
+				break;
+			case IMSG_LABEL_WITHDRAW:
+				if (map.type == MAP_TYPE_WILDCARD)
+					lde_check_withdraw_wcard(&map, ln);
+				else
+					lde_check_withdraw(&map, ln);
+				break;
+			case IMSG_LABEL_ABORT:
+				/* not necessary */
+				break;
+			}
+			break;
+		case IMSG_ADDRESS_ADD:
+			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(lde_addr))
+				fatalx("lde_dispatch_imsg: wrong imsg len");
+			memcpy(&lde_addr, imsg.data, sizeof(lde_addr));
+
+			ln = lde_nbr_find(imsg.hdr.peerid);
+			if (ln == NULL) {
+				log_debug("%s: cannot find lde neighbor",
+				    __func__);
+				break;
+			}
+			if (lde_address_add(ln, &lde_addr) < 0) {
+				log_debug("%s: cannot add address %s, it "
+				    "already exists", __func__,
+				    log_addr(lde_addr.af, &lde_addr.addr));
+			}
+			break;
+		case IMSG_ADDRESS_DEL:
+			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(lde_addr))
+				fatalx("lde_dispatch_imsg: wrong imsg len");
+			memcpy(&lde_addr, imsg.data, sizeof(lde_addr));
+
+			ln = lde_nbr_find(imsg.hdr.peerid);
+			if (ln == NULL) {
+				log_debug("%s: cannot find lde neighbor",
+				    __func__);
+				break;
+			}
+			if (lde_address_del(ln, &lde_addr) < 0) {
+				log_debug("%s: cannot delete address %s, it "
+				    "does not exist", __func__,
+				    log_addr(lde_addr.af, &lde_addr.addr));
+			}
+			break;
+		case IMSG_NOTIFICATION:
+			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(nm))
+				fatalx("lde_dispatch_imsg: wrong imsg len");
+			memcpy(&nm, imsg.data, sizeof(nm));
+
+			ln = lde_nbr_find(imsg.hdr.peerid);
+			if (ln == NULL) {
+				log_debug("%s: cannot find lde neighbor",
+				    __func__);
+				break;
+			}
+
+			switch (nm.status) {
+			case S_PW_STATUS:
+				l2vpn_recv_pw_status(ln, &nm);
+				break;
+			default:
+				break;
+			}
+			break;
+		case IMSG_NEIGHBOR_UP:
+			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
+			    sizeof(struct lde_nbr))
+				fatalx("lde_dispatch_imsg: wrong imsg len");
+
+			if (lde_nbr_find(imsg.hdr.peerid))
+				fatalx("lde_dispatch_imsg: "
+				    "neighbor already exists");
+			lde_nbr_new(imsg.hdr.peerid, imsg.data);
+			break;
+		case IMSG_NEIGHBOR_DOWN:
+			lde_nbr_del(lde_nbr_find(imsg.hdr.peerid));
+			break;
+		case IMSG_CTL_SHOW_LIB:
+			rt_dump(imsg.hdr.pid);
+
+			lde_imsg_compose_ldpe(IMSG_CTL_END, 0,
+			    imsg.hdr.pid, NULL, 0);
+			break;
+		case IMSG_CTL_SHOW_L2VPN_PW:
+			l2vpn_pw_ctl(imsg.hdr.pid);
+
+			lde_imsg_compose_ldpe(IMSG_CTL_END, 0,
+			    imsg.hdr.pid, NULL, 0);
+			break;
+		case IMSG_CTL_SHOW_L2VPN_BINDING:
+			l2vpn_binding_ctl(imsg.hdr.pid);
+
+			lde_imsg_compose_ldpe(IMSG_CTL_END, 0,
+			    imsg.hdr.pid, NULL, 0);
+			break;
+		default:
+			log_debug("%s: unexpected imsg %d", __func__,
+			    imsg.hdr.type);
+			break;
+		}
+		imsg_free(&imsg);
+	}
+	if (!shut)
+		imsg_event_add(iev);
+	else {
+		/* this pipe is dead, so remove the event handlers and exit */
+		THREAD_READ_OFF(iev->ev_read);
+		THREAD_WRITE_OFF(iev->ev_write);
+		lde_shutdown();
+	}
+
+	return (0);
+}
+
+/* ARGSUSED */
+static int
+lde_dispatch_parent(struct thread *thread)
+{
+	static struct ldpd_conf	*nconf;
+	struct iface		*niface;
+	struct tnbr		*ntnbr;
+	struct nbr_params	*nnbrp;
+	static struct l2vpn	*nl2vpn;
+	struct l2vpn_if		*nlif;
+	struct l2vpn_pw		*npw;
+	struct imsg		 imsg;
+	struct kroute		 kr;
+	int			 fd = THREAD_FD(thread);
+	struct imsgev		*iev = THREAD_ARG(thread);
+	struct imsgbuf		*ibuf = &iev->ibuf;
+	ssize_t			 n;
+	int			 shut = 0;
+	struct fec		 fec;
+
+	iev->ev_read = NULL;
+
+	if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
+		fatal("imsg_read error");
+	if (n == 0)	/* connection closed */
+		shut = 1;
+
+	for (;;) {
+		if ((n = imsg_get(ibuf, &imsg)) == -1)
+			fatal("lde_dispatch_parent: imsg_get error");
+		if (n == 0)
+			break;
+
+		switch (imsg.hdr.type) {
+		case IMSG_NETWORK_ADD:
+		case IMSG_NETWORK_DEL:
+			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(kr)) {
+				log_warnx("%s: wrong imsg len", __func__);
+				break;
+			}
+			memcpy(&kr, imsg.data, sizeof(kr));
+
+			switch (kr.af) {
+			case AF_INET:
+				fec.type = FEC_TYPE_IPV4;
+				fec.u.ipv4.prefix = kr.prefix.v4;
+				fec.u.ipv4.prefixlen = kr.prefixlen;
+				break;
+			case AF_INET6:
+				fec.type = FEC_TYPE_IPV6;
+				fec.u.ipv6.prefix = kr.prefix.v6;
+				fec.u.ipv6.prefixlen = kr.prefixlen;
+				break;
+			default:
+				fatalx("lde_dispatch_parent: unknown af");
+			}
+
+			switch (imsg.hdr.type) {
+			case IMSG_NETWORK_ADD:
+				lde_kernel_insert(&fec, kr.af, &kr.nexthop,
+				    kr.flags & F_CONNECTED, NULL);
+				break;
+			case IMSG_NETWORK_DEL:
+				lde_kernel_remove(&fec, kr.af, &kr.nexthop);
+				break;
+			}
+			break;
+		case IMSG_SOCKET_IPC:
+			if (iev_ldpe) {
+				log_warnx("%s: received unexpected imsg fd "
+				    "to ldpe", __func__);
+				break;
+			}
+			if ((fd = imsg.fd) == -1) {
+				log_warnx("%s: expected to receive imsg fd to "
+				    "ldpe but didn't receive any", __func__);
+				break;
+			}
+
+			if ((iev_ldpe = malloc(sizeof(struct imsgev))) == NULL)
+				fatal(NULL);
+			imsg_init(&iev_ldpe->ibuf, fd);
+			iev_ldpe->handler_read = lde_dispatch_imsg;
+			iev_ldpe->ev_read = thread_add_read(master,
+			    iev_ldpe->handler_read, iev_ldpe, iev_ldpe->ibuf.fd);
+			iev_ldpe->handler_write = ldp_write_handler;
+			iev_ldpe->ev_write = NULL;
+			break;
+		case IMSG_RECONF_CONF:
+			if ((nconf = malloc(sizeof(struct ldpd_conf))) ==
+			    NULL)
+				fatal(NULL);
+			memcpy(nconf, imsg.data, sizeof(struct ldpd_conf));
+
+			LIST_INIT(&nconf->iface_list);
+			LIST_INIT(&nconf->tnbr_list);
+			LIST_INIT(&nconf->nbrp_list);
+			LIST_INIT(&nconf->l2vpn_list);
+			break;
+		case IMSG_RECONF_IFACE:
+			if ((niface = malloc(sizeof(struct iface))) == NULL)
+				fatal(NULL);
+			memcpy(niface, imsg.data, sizeof(struct iface));
+
+			LIST_INIT(&niface->addr_list);
+			LIST_INIT(&niface->ipv4.adj_list);
+			LIST_INIT(&niface->ipv6.adj_list);
+			niface->ipv4.iface = niface;
+			niface->ipv6.iface = niface;
+
+			LIST_INSERT_HEAD(&nconf->iface_list, niface, entry);
+			break;
+		case IMSG_RECONF_TNBR:
+			if ((ntnbr = malloc(sizeof(struct tnbr))) == NULL)
+				fatal(NULL);
+			memcpy(ntnbr, imsg.data, sizeof(struct tnbr));
+
+			LIST_INSERT_HEAD(&nconf->tnbr_list, ntnbr, entry);
+			break;
+		case IMSG_RECONF_NBRP:
+			if ((nnbrp = malloc(sizeof(struct nbr_params))) == NULL)
+				fatal(NULL);
+			memcpy(nnbrp, imsg.data, sizeof(struct nbr_params));
+
+			LIST_INSERT_HEAD(&nconf->nbrp_list, nnbrp, entry);
+			break;
+		case IMSG_RECONF_L2VPN:
+			if ((nl2vpn = malloc(sizeof(struct l2vpn))) == NULL)
+				fatal(NULL);
+			memcpy(nl2vpn, imsg.data, sizeof(struct l2vpn));
+
+			LIST_INIT(&nl2vpn->if_list);
+			LIST_INIT(&nl2vpn->pw_list);
+			LIST_INIT(&nl2vpn->pw_inactive_list);
+
+			LIST_INSERT_HEAD(&nconf->l2vpn_list, nl2vpn, entry);
+			break;
+		case IMSG_RECONF_L2VPN_IF:
+			if ((nlif = malloc(sizeof(struct l2vpn_if))) == NULL)
+				fatal(NULL);
+			memcpy(nlif, imsg.data, sizeof(struct l2vpn_if));
+
+			nlif->l2vpn = nl2vpn;
+			LIST_INSERT_HEAD(&nl2vpn->if_list, nlif, entry);
+			break;
+		case IMSG_RECONF_L2VPN_PW:
+			if ((npw = malloc(sizeof(struct l2vpn_pw))) == NULL)
+				fatal(NULL);
+			memcpy(npw, imsg.data, sizeof(struct l2vpn_pw));
+
+			npw->l2vpn = nl2vpn;
+			LIST_INSERT_HEAD(&nl2vpn->pw_list, npw, entry);
+			break;
+		case IMSG_RECONF_L2VPN_IPW:
+			if ((npw = malloc(sizeof(struct l2vpn_pw))) == NULL)
+				fatal(NULL);
+			memcpy(npw, imsg.data, sizeof(struct l2vpn_pw));
+
+			npw->l2vpn = nl2vpn;
+			LIST_INSERT_HEAD(&nl2vpn->pw_inactive_list, npw, entry);
+			break;
+		case IMSG_RECONF_END:
+			merge_config(ldeconf, nconf);
+			nconf = NULL;
+			break;
+		default:
+			log_debug("%s: unexpected imsg %d", __func__,
+			    imsg.hdr.type);
+			break;
+		}
+		imsg_free(&imsg);
+	}
+	if (!shut)
+		imsg_event_add(iev);
+	else {
+		/* this pipe is dead, so remove the event handlers and exit */
+		THREAD_READ_OFF(iev->ev_read);
+		THREAD_WRITE_OFF(iev->ev_write);
+		lde_shutdown();
+	}
+
+	return (0);
+}
+
+uint32_t
+lde_assign_label(void)
+{
+	static uint32_t label = MPLS_LABEL_RESERVED_MAX;
+
+	/*
+	 * TODO: request label to zebra or define a range of labels for ldpd.
+	 */
+
+	label++;
+	return (label);
+}
+
+void
+lde_send_change_klabel(struct fec_node *fn, struct fec_nh *fnh)
+{
+	struct kroute	kr;
+	struct kpw	kpw;
+	struct l2vpn_pw	*pw;
+
+	switch (fn->fec.type) {
+	case FEC_TYPE_IPV4:
+		memset(&kr, 0, sizeof(kr));
+		kr.af = AF_INET;
+		kr.prefix.v4 = fn->fec.u.ipv4.prefix;
+		kr.prefixlen = fn->fec.u.ipv4.prefixlen;
+		kr.nexthop.v4 = fnh->nexthop.v4;
+		kr.local_label = fn->local_label;
+		kr.remote_label = fnh->remote_label;
+
+		lde_imsg_compose_parent(IMSG_KLABEL_CHANGE, 0, &kr,
+		    sizeof(kr));
+
+		if (fn->fec.u.ipv4.prefixlen == 32)
+			l2vpn_sync_pws(AF_INET, (union ldpd_addr *)
+			    &fn->fec.u.ipv4.prefix);
+		break;
+	case FEC_TYPE_IPV6:
+		memset(&kr, 0, sizeof(kr));
+		kr.af = AF_INET6;
+		kr.prefix.v6 = fn->fec.u.ipv6.prefix;
+		kr.prefixlen = fn->fec.u.ipv6.prefixlen;
+		kr.nexthop.v6 = fnh->nexthop.v6;
+		kr.local_label = fn->local_label;
+		kr.remote_label = fnh->remote_label;
+
+		lde_imsg_compose_parent(IMSG_KLABEL_CHANGE, 0, &kr,
+		    sizeof(kr));
+
+		if (fn->fec.u.ipv6.prefixlen == 128)
+			l2vpn_sync_pws(AF_INET6, (union ldpd_addr *)
+			    &fn->fec.u.ipv6.prefix);
+		break;
+	case FEC_TYPE_PWID:
+		if (fn->local_label == NO_LABEL ||
+		    fnh->remote_label == NO_LABEL)
+			return;
+
+		pw = (struct l2vpn_pw *) fn->data;
+		pw->flags |= F_PW_STATUS_UP;
+
+		memset(&kpw, 0, sizeof(kpw));
+		kpw.ifindex = pw->ifindex;
+		kpw.pw_type = fn->fec.u.pwid.type;
+		kpw.af = pw->af;
+		kpw.nexthop = pw->addr;
+		kpw.local_label = fn->local_label;
+		kpw.remote_label = fnh->remote_label;
+		kpw.flags = pw->flags;
+
+		lde_imsg_compose_parent(IMSG_KPWLABEL_CHANGE, 0, &kpw,
+		    sizeof(kpw));
+		break;
+	}
+}
+
+void
+lde_send_delete_klabel(struct fec_node *fn, struct fec_nh *fnh)
+{
+	struct kroute	 kr;
+	struct kpw	 kpw;
+	struct l2vpn_pw	*pw;
+
+	switch (fn->fec.type) {
+	case FEC_TYPE_IPV4:
+		memset(&kr, 0, sizeof(kr));
+		kr.af = AF_INET;
+		kr.prefix.v4 = fn->fec.u.ipv4.prefix;
+		kr.prefixlen = fn->fec.u.ipv4.prefixlen;
+		kr.nexthop.v4 = fnh->nexthop.v4;
+		kr.local_label = fn->local_label;
+		kr.remote_label = fnh->remote_label;
+
+		lde_imsg_compose_parent(IMSG_KLABEL_DELETE, 0, &kr,
+		    sizeof(kr));
+
+		if (fn->fec.u.ipv4.prefixlen == 32)
+			l2vpn_sync_pws(AF_INET, (union ldpd_addr *)
+			    &fn->fec.u.ipv4.prefix);
+		break;
+	case FEC_TYPE_IPV6:
+		memset(&kr, 0, sizeof(kr));
+		kr.af = AF_INET6;
+		kr.prefix.v6 = fn->fec.u.ipv6.prefix;
+		kr.prefixlen = fn->fec.u.ipv6.prefixlen;
+		kr.nexthop.v6 = fnh->nexthop.v6;
+		kr.local_label = fn->local_label;
+		kr.remote_label = fnh->remote_label;
+
+		lde_imsg_compose_parent(IMSG_KLABEL_DELETE, 0, &kr,
+		    sizeof(kr));
+
+		if (fn->fec.u.ipv6.prefixlen == 128)
+			l2vpn_sync_pws(AF_INET6, (union ldpd_addr *)
+			    &fn->fec.u.ipv6.prefix);
+		break;
+	case FEC_TYPE_PWID:
+		pw = (struct l2vpn_pw *) fn->data;
+		if (!(pw->flags & F_PW_STATUS_UP))
+			return;
+		pw->flags &= ~F_PW_STATUS_UP;
+
+		memset(&kpw, 0, sizeof(kpw));
+		kpw.ifindex = pw->ifindex;
+		kpw.pw_type = fn->fec.u.pwid.type;
+		kpw.af = pw->af;
+		kpw.nexthop = pw->addr;
+		kpw.local_label = fn->local_label;
+		kpw.remote_label = fnh->remote_label;
+		kpw.flags = pw->flags;
+
+		lde_imsg_compose_parent(IMSG_KPWLABEL_DELETE, 0, &kpw,
+		    sizeof(kpw));
+		break;
+	}
+}
+
+void
+lde_fec2map(struct fec *fec, struct map *map)
+{
+	memset(map, 0, sizeof(*map));
+
+	switch (fec->type) {
+	case FEC_TYPE_IPV4:
+		map->type = MAP_TYPE_PREFIX;
+		map->fec.prefix.af = AF_IPV4;
+		map->fec.prefix.prefix.v4 = fec->u.ipv4.prefix;
+		map->fec.prefix.prefixlen = fec->u.ipv4.prefixlen;
+		break;
+	case FEC_TYPE_IPV6:
+		map->type = MAP_TYPE_PREFIX;
+		map->fec.prefix.af = AF_IPV6;
+		map->fec.prefix.prefix.v6 = fec->u.ipv6.prefix;
+		map->fec.prefix.prefixlen = fec->u.ipv6.prefixlen;
+		break;
+	case FEC_TYPE_PWID:
+		map->type = MAP_TYPE_PWID;
+		map->fec.pwid.type = fec->u.pwid.type;
+		map->fec.pwid.group_id = 0;
+		map->flags |= F_MAP_PW_ID;
+		map->fec.pwid.pwid = fec->u.pwid.pwid;
+		break;
+	}
+}
+
+void
+lde_map2fec(struct map *map, struct in_addr lsr_id, struct fec *fec)
+{
+	memset(fec, 0, sizeof(*fec));
+
+	switch (map->type) {
+	case MAP_TYPE_PREFIX:
+		switch (map->fec.prefix.af) {
+		case AF_IPV4:
+			fec->type = FEC_TYPE_IPV4;
+			fec->u.ipv4.prefix = map->fec.prefix.prefix.v4;
+			fec->u.ipv4.prefixlen = map->fec.prefix.prefixlen;
+			break;
+		case AF_IPV6:
+			fec->type = FEC_TYPE_IPV6;
+			fec->u.ipv6.prefix = map->fec.prefix.prefix.v6;
+			fec->u.ipv6.prefixlen = map->fec.prefix.prefixlen;
+			break;
+		default:
+			fatalx("lde_map2fec: unknown af");
+			break;
+		}
+		break;
+	case MAP_TYPE_PWID:
+		fec->type = FEC_TYPE_PWID;
+		fec->u.pwid.type = map->fec.pwid.type;
+		fec->u.pwid.pwid = map->fec.pwid.pwid;
+		fec->u.pwid.lsr_id = lsr_id;
+		break;
+	}
+}
+
+void
+lde_send_labelmapping(struct lde_nbr *ln, struct fec_node *fn, int single)
+{
+	struct lde_req	*lre;
+	struct lde_map	*me;
+	struct map	 map;
+	struct l2vpn_pw	*pw;
+
+	/*
+	 * This function skips SL.1 - 3 and SL.9 - 14 because the label
+	 * allocation is done way earlier (because of the merging nature of
+	 * ldpd).
+	 */
+
+	lde_fec2map(&fn->fec, &map);
+	switch (fn->fec.type) {
+	case FEC_TYPE_IPV4:
+		if (!ln->v4_enabled)
+			return;
+		break;
+	case FEC_TYPE_IPV6:
+		if (!ln->v6_enabled)
+			return;
+		break;
+	case FEC_TYPE_PWID:
+		pw = (struct l2vpn_pw *) fn->data;
+		if (pw == NULL || pw->lsr_id.s_addr != ln->id.s_addr)
+			/* not the remote end of the pseudowire */
+			return;
+
+		map.flags |= F_MAP_PW_IFMTU;
+		map.fec.pwid.ifmtu = pw->l2vpn->mtu;
+		if (pw->flags & F_PW_CWORD)
+			map.flags |= F_MAP_PW_CWORD;
+		if (pw->flags & F_PW_STATUSTLV) {
+			map.flags |= F_MAP_PW_STATUS;
+			/* VPLS are always up */
+			map.pw_status = PW_FORWARDING;
+		}
+		break;
+	}
+	map.label = fn->local_label;
+
+	/* SL.6: is there a pending request for this mapping? */
+	lre = (struct lde_req *)fec_find(&ln->recv_req, &fn->fec);
+	if (lre) {
+		/* set label request msg id in the mapping response. */
+		map.requestid = lre->msgid;
+		map.flags = F_MAP_REQ_ID;
+
+		/* SL.7: delete record of pending request */
+		lde_req_del(ln, lre, 0);
+	}
+
+	/* SL.4: send label mapping */
+	lde_imsg_compose_ldpe(IMSG_MAPPING_ADD, ln->peerid, 0,
+	    &map, sizeof(map));
+	if (single)
+		lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END, ln->peerid, 0,
+		    NULL, 0);
+
+	/* SL.5: record sent label mapping */
+	me = (struct lde_map *)fec_find(&ln->sent_map, &fn->fec);
+	if (me == NULL)
+		me = lde_map_add(ln, fn, 1);
+	me->map = map;
+}
+
+void
+lde_send_labelwithdraw(struct lde_nbr *ln, struct fec_node *fn, uint32_t label)
+{
+	struct lde_wdraw	*lw;
+	struct map		 map;
+	struct fec		*f;
+	struct l2vpn_pw		*pw;
+
+	if (fn) {
+		lde_fec2map(&fn->fec, &map);
+		switch (fn->fec.type) {
+		case FEC_TYPE_IPV4:
+			if (!ln->v4_enabled)
+				return;
+			break;
+		case FEC_TYPE_IPV6:
+			if (!ln->v6_enabled)
+				return;
+			break;
+		case FEC_TYPE_PWID:
+			pw = (struct l2vpn_pw *) fn->data;
+			if (pw == NULL || pw->lsr_id.s_addr != ln->id.s_addr)
+				/* not the remote end of the pseudowire */
+				return;
+
+			if (pw->flags & F_PW_CWORD)
+				map.flags |= F_MAP_PW_CWORD;
+			break;
+		}
+		map.label = fn->local_label;
+	} else {
+		memset(&map, 0, sizeof(map));
+		map.type = MAP_TYPE_WILDCARD;
+		map.label = label;
+	}
+
+	/* SWd.1: send label withdraw. */
+	lde_imsg_compose_ldpe(IMSG_WITHDRAW_ADD, ln->peerid, 0,
+ 	    &map, sizeof(map));
+	lde_imsg_compose_ldpe(IMSG_WITHDRAW_ADD_END, ln->peerid, 0, NULL, 0);
+
+	/* SWd.2: record label withdraw. */
+	if (fn) {
+		lw = (struct lde_wdraw *)fec_find(&ln->sent_wdraw, &fn->fec);
+		if (lw == NULL)
+			lw = lde_wdraw_add(ln, fn);
+		lw->label = map.label;
+	} else {
+		RB_FOREACH(f, fec_tree, &ft) {
+			fn = (struct fec_node *)f;
+
+			lw = (struct lde_wdraw *)fec_find(&ln->sent_wdraw,
+			    &fn->fec);
+			if (lw == NULL)
+				lw = lde_wdraw_add(ln, fn);
+			lw->label = map.label;
+		}
+	}
+}
+
+void
+lde_send_labelwithdraw_all(struct fec_node *fn, uint32_t label)
+{
+	struct lde_nbr		*ln;
+
+	RB_FOREACH(ln, nbr_tree, &lde_nbrs)
+		lde_send_labelwithdraw(ln, fn, label);
+}
+
+void
+lde_send_labelrelease(struct lde_nbr *ln, struct fec_node *fn, uint32_t label)
+{
+	struct map		 map;
+	struct l2vpn_pw		*pw;
+
+	if (fn) {
+		lde_fec2map(&fn->fec, &map);
+		switch (fn->fec.type) {
+		case FEC_TYPE_IPV4:
+			if (!ln->v4_enabled)
+				return;
+			break;
+		case FEC_TYPE_IPV6:
+			if (!ln->v6_enabled)
+				return;
+			break;
+		case FEC_TYPE_PWID:
+			pw = (struct l2vpn_pw *) fn->data;
+			if (pw == NULL || pw->lsr_id.s_addr != ln->id.s_addr)
+				/* not the remote end of the pseudowire */
+				return;
+
+			if (pw->flags & F_PW_CWORD)
+				map.flags |= F_MAP_PW_CWORD;
+			break;
+		}
+	} else {
+		memset(&map, 0, sizeof(map));
+		map.type = MAP_TYPE_WILDCARD;
+	}
+	map.label = label;
+
+	lde_imsg_compose_ldpe(IMSG_RELEASE_ADD, ln->peerid, 0,
+	    &map, sizeof(map));
+	lde_imsg_compose_ldpe(IMSG_RELEASE_ADD_END, ln->peerid, 0, NULL, 0);
+}
+
+void
+lde_send_notification(uint32_t peerid, uint32_t code, uint32_t msgid,
+    uint16_t type)
+{
+	struct notify_msg nm;
+
+	memset(&nm, 0, sizeof(nm));
+	nm.status = code;
+	/* 'msgid' and 'type' should be in network byte order */
+	nm.messageid = msgid;
+	nm.type = type;
+
+	lde_imsg_compose_ldpe(IMSG_NOTIFICATION_SEND, peerid, 0,
+	    &nm, sizeof(nm));
+}
+
+static __inline int
+lde_nbr_compare(struct lde_nbr *a, struct lde_nbr *b)
+{
+	return (a->peerid - b->peerid);
+}
+
+static struct lde_nbr *
+lde_nbr_new(uint32_t peerid, struct lde_nbr *new)
+{
+	struct lde_nbr	*ln;
+
+	if ((ln = calloc(1, sizeof(*ln))) == NULL)
+		fatal(__func__);
+
+	ln->id = new->id;
+	ln->v4_enabled = new->v4_enabled;
+	ln->v6_enabled = new->v6_enabled;
+	ln->peerid = peerid;
+	fec_init(&ln->recv_map);
+	fec_init(&ln->sent_map);
+	fec_init(&ln->recv_req);
+	fec_init(&ln->sent_req);
+	fec_init(&ln->sent_wdraw);
+
+	TAILQ_INIT(&ln->addr_list);
+
+	if (RB_INSERT(nbr_tree, &lde_nbrs, ln) != NULL)
+		fatalx("lde_nbr_new: RB_INSERT failed");
+
+	return (ln);
+}
+
+static void
+lde_nbr_del(struct lde_nbr *ln)
+{
+	struct fec		*f;
+	struct fec_node		*fn;
+	struct fec_nh		*fnh;
+	struct l2vpn_pw		*pw;
+
+	if (ln == NULL)
+		return;
+
+	/* uninstall received mappings */
+	RB_FOREACH(f, fec_tree, &ft) {
+		fn = (struct fec_node *)f;
+
+		LIST_FOREACH(fnh, &fn->nexthops, entry) {
+			switch (f->type) {
+			case FEC_TYPE_IPV4:
+			case FEC_TYPE_IPV6:
+				if (!lde_address_find(ln, fnh->af,
+				    &fnh->nexthop))
+					continue;
+				break;
+			case FEC_TYPE_PWID:
+				if (f->u.pwid.lsr_id.s_addr != ln->id.s_addr)
+					continue;
+				pw = (struct l2vpn_pw *) fn->data;
+				if (pw)
+					l2vpn_pw_reset(pw);
+				break;
+			default:
+				break;
+			}
+
+			lde_send_delete_klabel(fn, fnh);
+			fnh->remote_label = NO_LABEL;
+		}
+	}
+
+	lde_address_list_free(ln);
+
+	fec_clear(&ln->recv_map, lde_map_free);
+	fec_clear(&ln->sent_map, lde_map_free);
+	fec_clear(&ln->recv_req, free);
+	fec_clear(&ln->sent_req, free);
+	fec_clear(&ln->sent_wdraw, free);
+
+	RB_REMOVE(nbr_tree, &lde_nbrs, ln);
+
+	free(ln);
+}
+
+static struct lde_nbr *
+lde_nbr_find(uint32_t peerid)
+{
+	struct lde_nbr		 ln;
+
+	ln.peerid = peerid;
+
+	return (RB_FIND(nbr_tree, &lde_nbrs, &ln));
+}
+
+struct lde_nbr *
+lde_nbr_find_by_lsrid(struct in_addr addr)
+{
+	struct lde_nbr		*ln;
+
+	RB_FOREACH(ln, nbr_tree, &lde_nbrs)
+		if (ln->id.s_addr == addr.s_addr)
+			return (ln);
+
+	return (NULL);
+}
+
+struct lde_nbr *
+lde_nbr_find_by_addr(int af, union ldpd_addr *addr)
+{
+	struct lde_nbr		*ln;
+
+	RB_FOREACH(ln, nbr_tree, &lde_nbrs)
+		if (lde_address_find(ln, af, addr) != NULL)
+			return (ln);
+
+	return (NULL);
+}
+
+static void
+lde_nbr_clear(void)
+{
+	struct lde_nbr	*ln;
+
+	 while ((ln = RB_ROOT(&lde_nbrs)) != NULL)
+		lde_nbr_del(ln);
+}
+
+struct lde_map *
+lde_map_add(struct lde_nbr *ln, struct fec_node *fn, int sent)
+{
+	struct lde_map  *me;
+
+	me = calloc(1, sizeof(*me));
+	if (me == NULL)
+		fatal(__func__);
+
+	me->fec = fn->fec;
+	me->nexthop = ln;
+
+	if (sent) {
+		LIST_INSERT_HEAD(&fn->upstream, me, entry);
+		if (fec_insert(&ln->sent_map, &me->fec))
+			log_warnx("failed to add %s to sent map",
+			    log_fec(&me->fec));
+			/* XXX on failure more cleanup is needed */
+	} else {
+		LIST_INSERT_HEAD(&fn->downstream, me, entry);
+		if (fec_insert(&ln->recv_map, &me->fec))
+			log_warnx("failed to add %s to recv map",
+			    log_fec(&me->fec));
+	}
+
+	return (me);
+}
+
+void
+lde_map_del(struct lde_nbr *ln, struct lde_map *me, int sent)
+{
+	if (sent)
+		fec_remove(&ln->sent_map, &me->fec);
+	else
+		fec_remove(&ln->recv_map, &me->fec);
+
+	lde_map_free(me);
+}
+
+static void
+lde_map_free(void *ptr)
+{
+	struct lde_map	*map = ptr;
+
+	LIST_REMOVE(map, entry);
+	free(map);
+}
+
+struct lde_req *
+lde_req_add(struct lde_nbr *ln, struct fec *fec, int sent)
+{
+	struct fec_tree	*t;
+	struct lde_req	*lre;
+
+	t = sent ? &ln->sent_req : &ln->recv_req;
+
+	lre = calloc(1, sizeof(*lre));
+	if (lre != NULL) {
+		lre->fec = *fec;
+
+		if (fec_insert(t, &lre->fec)) {
+			log_warnx("failed to add %s/%u to %s req",
+			    log_fec(&lre->fec), sent ? "sent" : "recv");
+			free(lre);
+			return (NULL);
+		}
+	}
+
+	return (lre);
+}
+
+void
+lde_req_del(struct lde_nbr *ln, struct lde_req *lre, int sent)
+{
+	if (sent)
+		fec_remove(&ln->sent_req, &lre->fec);
+	else
+		fec_remove(&ln->recv_req, &lre->fec);
+
+	free(lre);
+}
+
+struct lde_wdraw *
+lde_wdraw_add(struct lde_nbr *ln, struct fec_node *fn)
+{
+	struct lde_wdraw  *lw;
+
+	lw = calloc(1, sizeof(*lw));
+	if (lw == NULL)
+		fatal(__func__);
+
+	lw->fec = fn->fec;
+
+	if (fec_insert(&ln->sent_wdraw, &lw->fec))
+		log_warnx("failed to add %s to sent wdraw",
+		    log_fec(&lw->fec));
+
+	return (lw);
+}
+
+void
+lde_wdraw_del(struct lde_nbr *ln, struct lde_wdraw *lw)
+{
+	fec_remove(&ln->sent_wdraw, &lw->fec);
+	free(lw);
+}
+
+void
+lde_change_egress_label(int af, int was_implicit)
+{
+	struct lde_nbr	*ln;
+	struct fec	*f;
+	struct fec_node	*fn;
+
+	RB_FOREACH(ln, nbr_tree, &lde_nbrs) {
+		/* explicit withdraw */
+		if (was_implicit)
+			lde_send_labelwithdraw(ln, NULL, MPLS_LABEL_IMPLNULL);
+		else {
+			if (ln->v4_enabled)
+				lde_send_labelwithdraw(ln, NULL,
+				    MPLS_LABEL_IPV4NULL);
+			if (ln->v6_enabled)
+				lde_send_labelwithdraw(ln, NULL,
+				    MPLS_LABEL_IPV6NULL);
+		}
+
+		/* advertise new label of connected prefixes */
+		RB_FOREACH(f, fec_tree, &ft) {
+			fn = (struct fec_node *)f;
+			if (fn->local_label > MPLS_LABEL_RESERVED_MAX)
+				continue;
+
+			switch (af) {
+			case AF_INET:
+				if (fn->fec.type != FEC_TYPE_IPV4)
+					continue;
+				break;
+			case AF_INET6:
+				if (fn->fec.type != FEC_TYPE_IPV6)
+					continue;
+				break;
+			default:
+				fatalx("lde_change_egress_label: unknown af");
+			}
+
+			fn->local_label = egress_label(fn->fec.type);
+			lde_send_labelmapping(ln, fn, 0);
+		}
+
+		lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END, ln->peerid, 0,
+		    NULL, 0);
+	}
+}
+
+static int
+lde_address_add(struct lde_nbr *ln, struct lde_addr *lde_addr)
+{
+	struct lde_addr		*new;
+
+	if (lde_address_find(ln, lde_addr->af, &lde_addr->addr) != NULL)
+		return (-1);
+
+	if ((new = calloc(1, sizeof(*new))) == NULL)
+		fatal(__func__);
+
+	new->af = lde_addr->af;
+	new->addr = lde_addr->addr;
+	TAILQ_INSERT_TAIL(&ln->addr_list, new, entry);
+
+	return (0);
+}
+
+static int
+lde_address_del(struct lde_nbr *ln, struct lde_addr *lde_addr)
+{
+	lde_addr = lde_address_find(ln, lde_addr->af, &lde_addr->addr);
+	if (lde_addr == NULL)
+		return (-1);
+
+	TAILQ_REMOVE(&ln->addr_list, lde_addr, entry);
+	free(lde_addr);
+
+	return (0);
+}
+
+struct lde_addr *
+lde_address_find(struct lde_nbr *ln, int af, union ldpd_addr *addr)
+{
+	struct lde_addr		*lde_addr;
+
+	TAILQ_FOREACH(lde_addr, &ln->addr_list, entry)
+		if (lde_addr->af == af &&
+		    ldp_addrcmp(af, &lde_addr->addr, addr) == 0)
+			return (lde_addr);
+
+	return (NULL);
+}
+
+static void
+lde_address_list_free(struct lde_nbr *ln)
+{
+	struct lde_addr		*lde_addr;
+
+	while ((lde_addr = TAILQ_FIRST(&ln->addr_list)) != NULL) {
+		TAILQ_REMOVE(&ln->addr_list, lde_addr, entry);
+		free(lde_addr);
+	}
+}
diff --git a/ldpd/lde.h b/ldpd/lde.h
new file mode 100644
index 0000000..e1d0f89
--- /dev/null
+++ b/ldpd/lde.h
@@ -0,0 +1,198 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ * Copyright (c) 2004, 2005 Esben Norby <norby@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _LDE_H_
+#define _LDE_H_
+
+#include "openbsd-queue.h"
+#include "openbsd-tree.h"
+
+enum fec_type {
+	FEC_TYPE_IPV4,
+	FEC_TYPE_IPV6,
+	FEC_TYPE_PWID
+};
+
+struct fec {
+	RB_ENTRY(fec)		entry;
+	enum fec_type		type;
+	union {
+		struct {
+			struct in_addr	prefix;
+			uint8_t		prefixlen;
+		} ipv4;
+		struct {
+			struct in6_addr	prefix;
+			uint8_t		prefixlen;
+		} ipv6;
+		struct {
+			uint16_t	type;
+			uint32_t	pwid;
+			struct in_addr	lsr_id;
+		} pwid;
+	} u;
+};
+RB_HEAD(fec_tree, fec);
+RB_PROTOTYPE(fec_tree, fec, entry, fec_compare)
+
+/* request entries */
+struct lde_req {
+	struct fec		fec;
+	uint32_t		msgid;
+};
+
+/* mapping entries */
+struct lde_map {
+	struct fec		 fec;
+	LIST_ENTRY(lde_map)	 entry;
+	struct lde_nbr		*nexthop;
+	struct map		 map;
+};
+
+/* withdraw entries */
+struct lde_wdraw {
+	struct fec		 fec;
+	uint32_t		 label;
+};
+
+/* Addresses belonging to neighbor */
+struct lde_addr {
+	TAILQ_ENTRY(lde_addr)	 entry;
+	int			 af;
+	union ldpd_addr		 addr;
+};
+
+/* just the info LDE needs */
+struct lde_nbr {
+	RB_ENTRY(lde_nbr)	 entry;
+	uint32_t		 peerid;
+	struct in_addr		 id;
+	int			 v4_enabled;	/* announce/process v4 msgs */
+	int			 v6_enabled;	/* announce/process v6 msgs */
+	struct fec_tree		 recv_req;
+	struct fec_tree		 sent_req;
+	struct fec_tree		 recv_map;
+	struct fec_tree		 sent_map;
+	struct fec_tree		 sent_wdraw;
+	TAILQ_HEAD(, lde_addr)	 addr_list;
+};
+RB_HEAD(nbr_tree, lde_nbr);
+RB_PROTOTYPE(nbr_tree, lde_nbr, entry, lde_nbr_compare)
+
+struct fec_nh {
+	LIST_ENTRY(fec_nh)	 entry;
+	int			 af;
+	union ldpd_addr		 nexthop;
+	uint32_t		 remote_label;
+};
+
+struct fec_node {
+	struct fec		 fec;
+
+	LIST_HEAD(, fec_nh)	 nexthops;	/* fib nexthops */
+	LIST_HEAD(, lde_map)	 downstream;	/* recv mappings */
+	LIST_HEAD(, lde_map)	 upstream;	/* sent mappings */
+
+	uint32_t		 local_label;
+	void			*data;		/* fec specific data */
+};
+
+#define LDE_GC_INTERVAL 300
+
+extern struct ldpd_conf	*ldeconf;
+extern struct fec_tree	 ft;
+extern struct nbr_tree	 lde_nbrs;
+extern struct thread	*gc_timer;
+
+/* lde.c */
+pid_t		 lde(void);
+int		 lde_imsg_compose_ldpe(int, uint32_t, pid_t, void *, uint16_t);
+uint32_t	 lde_assign_label(void);
+void		 lde_send_change_klabel(struct fec_node *, struct fec_nh *);
+void		 lde_send_delete_klabel(struct fec_node *, struct fec_nh *);
+void		 lde_fec2map(struct fec *, struct map *);
+void		 lde_map2fec(struct map *, struct in_addr, struct fec *);
+void		 lde_send_labelmapping(struct lde_nbr *, struct fec_node *,
+		    int);
+void		 lde_send_labelwithdraw(struct lde_nbr *, struct fec_node *,
+		    uint32_t);
+void		 lde_send_labelwithdraw_all(struct fec_node *, uint32_t);
+void		 lde_send_labelrelease(struct lde_nbr *, struct fec_node *,
+		    uint32_t);
+void		 lde_send_notification(uint32_t, uint32_t, uint32_t, uint16_t);
+struct lde_nbr	*lde_nbr_find_by_lsrid(struct in_addr);
+struct lde_nbr	*lde_nbr_find_by_addr(int, union ldpd_addr *);
+struct lde_map	*lde_map_add(struct lde_nbr *, struct fec_node *, int);
+void		 lde_map_del(struct lde_nbr *, struct lde_map *, int);
+struct lde_req	*lde_req_add(struct lde_nbr *, struct fec *, int);
+void		 lde_req_del(struct lde_nbr *, struct lde_req *, int);
+struct lde_wdraw *lde_wdraw_add(struct lde_nbr *, struct fec_node *);
+void		 lde_wdraw_del(struct lde_nbr *, struct lde_wdraw *);
+void		 lde_change_egress_label(int, int);
+struct lde_addr	*lde_address_find(struct lde_nbr *, int,
+		    union ldpd_addr *);
+
+/* lde_lib.c */
+void		 fec_init(struct fec_tree *);
+struct fec	*fec_find(struct fec_tree *, struct fec *);
+int		 fec_insert(struct fec_tree *, struct fec *);
+int		 fec_remove(struct fec_tree *, struct fec *);
+void		 fec_clear(struct fec_tree *, void (*)(void *));
+void		 rt_dump(pid_t);
+void		 fec_snap(struct lde_nbr *);
+void		 fec_tree_clear(void);
+struct fec_nh	*fec_nh_find(struct fec_node *, int, union ldpd_addr *);
+uint32_t	 egress_label(enum fec_type);
+void		 lde_kernel_insert(struct fec *, int, union ldpd_addr *, int, void *);
+void		 lde_kernel_remove(struct fec *, int, union ldpd_addr *);
+void		 lde_check_mapping(struct map *, struct lde_nbr *);
+void		 lde_check_request(struct map *, struct lde_nbr *);
+void		 lde_check_release(struct map *, struct lde_nbr *);
+void		 lde_check_release_wcard(struct map *, struct lde_nbr *);
+void		 lde_check_withdraw(struct map *, struct lde_nbr *);
+void		 lde_check_withdraw_wcard(struct map *, struct lde_nbr *);
+int		 lde_gc_timer(struct thread *);
+void		 lde_gc_start_timer(void);
+void		 lde_gc_stop_timer(void);
+
+/* l2vpn.c */
+struct l2vpn	*l2vpn_new(const char *);
+struct l2vpn	*l2vpn_find(struct ldpd_conf *, const char *);
+void		 l2vpn_del(struct l2vpn *);
+void		 l2vpn_init(struct l2vpn *);
+struct l2vpn_if	*l2vpn_if_new(struct l2vpn *, struct kif *);
+struct l2vpn_if	*l2vpn_if_find(struct l2vpn *, unsigned int);
+struct l2vpn_if	*l2vpn_if_find_name(struct l2vpn *, const char *);
+struct l2vpn_pw	*l2vpn_pw_new(struct l2vpn *, struct kif *);
+struct l2vpn_pw *l2vpn_pw_find(struct l2vpn *, unsigned int);
+struct l2vpn_pw *l2vpn_pw_find_name(struct l2vpn *, const char *);
+void		 l2vpn_pw_init(struct l2vpn_pw *);
+void		 l2vpn_pw_exit(struct l2vpn_pw *);
+void		 l2vpn_pw_reset(struct l2vpn_pw *);
+int		 l2vpn_pw_ok(struct l2vpn_pw *, struct fec_nh *);
+int		 l2vpn_pw_negotiate(struct lde_nbr *, struct fec_node *,
+		    struct map *);
+void		 l2vpn_send_pw_status(uint32_t, uint32_t, struct fec *);
+void		 l2vpn_recv_pw_status(struct lde_nbr *, struct notify_msg *);
+void		 l2vpn_sync_pws(int, union ldpd_addr *);
+void		 l2vpn_pw_ctl(pid_t);
+void		 l2vpn_binding_ctl(pid_t);
+
+#endif	/* _LDE_H_ */
diff --git a/ldpd/lde_lib.c b/ldpd/lde_lib.c
new file mode 100644
index 0000000..d49bfd2
--- /dev/null
+++ b/ldpd/lde_lib.c
@@ -0,0 +1,772 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "lde.h"
+#include "log.h"
+
+#include "mpls.h"
+
+static __inline int	 fec_compare(struct fec *, struct fec *);
+static int		 lde_nbr_is_nexthop(struct fec_node *,
+			    struct lde_nbr *);
+static void		 fec_free(void *);
+static struct fec_node	*fec_add(struct fec *fec);
+static struct fec_nh	*fec_nh_add(struct fec_node *, int, union ldpd_addr *);
+static void		 fec_nh_del(struct fec_nh *);
+
+RB_GENERATE(fec_tree, fec, entry, fec_compare)
+
+struct fec_tree		 ft = RB_INITIALIZER(&ft);
+struct thread		*gc_timer;
+
+/* FEC tree functions */
+void
+fec_init(struct fec_tree *fh)
+{
+	RB_INIT(fh);
+}
+
+static __inline int
+fec_compare(struct fec *a, struct fec *b)
+{
+	if (a->type < b->type)
+		return (-1);
+	if (a->type > b->type)
+		return (1);
+
+	switch (a->type) {
+	case FEC_TYPE_IPV4:
+		if (ntohl(a->u.ipv4.prefix.s_addr) <
+		    ntohl(b->u.ipv4.prefix.s_addr))
+			return (-1);
+		if (ntohl(a->u.ipv4.prefix.s_addr) >
+		    ntohl(b->u.ipv4.prefix.s_addr))
+			return (1);
+		if (a->u.ipv4.prefixlen < b->u.ipv4.prefixlen)
+			return (-1);
+		if (a->u.ipv4.prefixlen > b->u.ipv4.prefixlen)
+			return (1);
+		return (0);
+	case FEC_TYPE_IPV6:
+		if (memcmp(&a->u.ipv6.prefix, &b->u.ipv6.prefix,
+		    sizeof(struct in6_addr)) < 0)
+			return (-1);
+		if (memcmp(&a->u.ipv6.prefix, &b->u.ipv6.prefix,
+		    sizeof(struct in6_addr)) > 0)
+			return (1);
+		if (a->u.ipv6.prefixlen < b->u.ipv6.prefixlen)
+			return (-1);
+		if (a->u.ipv6.prefixlen > b->u.ipv6.prefixlen)
+			return (1);
+		return (0);
+	case FEC_TYPE_PWID:
+		if (a->u.pwid.type < b->u.pwid.type)
+			return (-1);
+		if (a->u.pwid.type > b->u.pwid.type)
+			return (1);
+		if (a->u.pwid.pwid < b->u.pwid.pwid)
+			return (-1);
+		if (a->u.pwid.pwid > b->u.pwid.pwid)
+			return (1);
+		if (ntohl(a->u.pwid.lsr_id.s_addr) <
+		    ntohl(b->u.pwid.lsr_id.s_addr))
+			return (-1);
+		if (ntohl(a->u.pwid.lsr_id.s_addr) >
+		    ntohl(b->u.pwid.lsr_id.s_addr))
+			return (1);
+		return (0);
+	}
+
+	return (-1);
+}
+
+struct fec *
+fec_find(struct fec_tree *fh, struct fec *f)
+{
+	return (RB_FIND(fec_tree, fh, f));
+}
+
+int
+fec_insert(struct fec_tree *fh, struct fec *f)
+{
+	if (RB_INSERT(fec_tree, fh, f) != NULL)
+		return (-1);
+	return (0);
+}
+
+int
+fec_remove(struct fec_tree *fh, struct fec *f)
+{
+	if (RB_REMOVE(fec_tree, fh, f) == NULL) {
+		log_warnx("%s failed for %s", __func__, log_fec(f));
+		return (-1);
+	}
+	return (0);
+}
+
+void
+fec_clear(struct fec_tree *fh, void (*free_cb)(void *))
+{
+	struct fec	*f;
+
+	while ((f = RB_ROOT(fh)) != NULL) {
+		fec_remove(fh, f);
+		free_cb(f);
+	}
+}
+
+/* routing table functions */
+static int
+lde_nbr_is_nexthop(struct fec_node *fn, struct lde_nbr *ln)
+{
+	struct fec_nh		*fnh;
+
+	LIST_FOREACH(fnh, &fn->nexthops, entry)
+		if (lde_address_find(ln, fnh->af, &fnh->nexthop))
+			return (1);
+
+	return (0);
+}
+
+void
+rt_dump(pid_t pid)
+{
+	struct fec		*f;
+	struct fec_node		*fn;
+	struct lde_map		*me;
+	static struct ctl_rt	 rtctl;
+
+	RB_FOREACH(f, fec_tree, &ft) {
+		fn = (struct fec_node *)f;
+		if (fn->local_label == NO_LABEL &&
+		    LIST_EMPTY(&fn->downstream))
+			continue;
+
+		rtctl.first = 1;
+		switch (fn->fec.type) {
+		case FEC_TYPE_IPV4:
+			rtctl.af = AF_INET;
+			rtctl.prefix.v4 = fn->fec.u.ipv4.prefix;
+			rtctl.prefixlen = fn->fec.u.ipv4.prefixlen;
+			break;
+		case FEC_TYPE_IPV6:
+			rtctl.af = AF_INET6;
+			rtctl.prefix.v6 = fn->fec.u.ipv6.prefix;
+			rtctl.prefixlen = fn->fec.u.ipv6.prefixlen;
+			break;
+		default:
+			continue;
+		}
+
+		rtctl.local_label = fn->local_label;
+		LIST_FOREACH(me, &fn->downstream, entry) {
+			rtctl.in_use = lde_nbr_is_nexthop(fn, me->nexthop);
+			rtctl.nexthop = me->nexthop->id;
+			rtctl.remote_label = me->map.label;
+
+			lde_imsg_compose_ldpe(IMSG_CTL_SHOW_LIB, 0, pid,
+			    &rtctl, sizeof(rtctl));
+			rtctl.first = 0;
+		}
+		if (LIST_EMPTY(&fn->downstream)) {
+			rtctl.in_use = 0;
+			rtctl.nexthop.s_addr = INADDR_ANY;
+			rtctl.remote_label = NO_LABEL;
+
+			lde_imsg_compose_ldpe(IMSG_CTL_SHOW_LIB, 0, pid,
+			    &rtctl, sizeof(rtctl));
+		}
+	}
+}
+
+void
+fec_snap(struct lde_nbr *ln)
+{
+	struct fec	*f;
+	struct fec_node	*fn;
+
+	RB_FOREACH(f, fec_tree, &ft) {
+		fn = (struct fec_node *)f;
+		if (fn->local_label == NO_LABEL)
+			continue;
+
+		lde_send_labelmapping(ln, fn, 0);
+	}
+
+	lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END, ln->peerid, 0, NULL, 0);
+}
+
+static void
+fec_free(void *arg)
+{
+	struct fec_node	*fn = arg;
+	struct fec_nh	*fnh;
+
+	while ((fnh = LIST_FIRST(&fn->nexthops)))
+		fec_nh_del(fnh);
+	if (!LIST_EMPTY(&fn->downstream))
+		log_warnx("%s: fec %s downstream list not empty", __func__,
+		    log_fec(&fn->fec));
+	if (!LIST_EMPTY(&fn->upstream))
+		log_warnx("%s: fec %s upstream list not empty", __func__,
+		    log_fec(&fn->fec));
+
+	free(fn);
+}
+
+void
+fec_tree_clear(void)
+{
+	fec_clear(&ft, fec_free);
+}
+
+static struct fec_node *
+fec_add(struct fec *fec)
+{
+	struct fec_node	*fn;
+
+	fn = calloc(1, sizeof(*fn));
+	if (fn == NULL)
+		fatal(__func__);
+
+	fn->fec = *fec;
+	fn->local_label = NO_LABEL;
+	LIST_INIT(&fn->upstream);
+	LIST_INIT(&fn->downstream);
+	LIST_INIT(&fn->nexthops);
+
+	if (fec_insert(&ft, &fn->fec))
+		log_warnx("failed to add %s to ft tree",
+		    log_fec(&fn->fec));
+
+	return (fn);
+}
+
+struct fec_nh *
+fec_nh_find(struct fec_node *fn, int af, union ldpd_addr *nexthop)
+{
+	struct fec_nh	*fnh;
+
+	LIST_FOREACH(fnh, &fn->nexthops, entry)
+		if (fnh->af == af &&
+		    ldp_addrcmp(af, &fnh->nexthop, nexthop) == 0)
+			return (fnh);
+
+	return (NULL);
+}
+
+static struct fec_nh *
+fec_nh_add(struct fec_node *fn, int af, union ldpd_addr *nexthop)
+{
+	struct fec_nh	*fnh;
+
+	fnh = calloc(1, sizeof(*fnh));
+	if (fnh == NULL)
+		fatal(__func__);
+
+	fnh->af = af;
+	fnh->nexthop = *nexthop;
+	fnh->remote_label = NO_LABEL;
+	LIST_INSERT_HEAD(&fn->nexthops, fnh, entry);
+
+	return (fnh);
+}
+
+static void
+fec_nh_del(struct fec_nh *fnh)
+{
+	LIST_REMOVE(fnh, entry);
+	free(fnh);
+}
+
+uint32_t
+egress_label(enum fec_type fec_type)
+{
+	switch (fec_type) {
+	case FEC_TYPE_IPV4:
+		if (!(ldeconf->ipv4.flags & F_LDPD_AF_EXPNULL))
+			return (MPLS_LABEL_IMPLNULL);
+		return (MPLS_LABEL_IPV4NULL);
+	case FEC_TYPE_IPV6:
+		if (!(ldeconf->ipv6.flags & F_LDPD_AF_EXPNULL))
+			return (MPLS_LABEL_IMPLNULL);
+		return (MPLS_LABEL_IPV6NULL);
+	default:
+		log_warnx("%s: unexpected fec type", __func__);
+	}
+
+	return (NO_LABEL);
+}
+
+void
+lde_kernel_insert(struct fec *fec, int af, union ldpd_addr *nexthop,
+    int connected, void *data)
+{
+	struct fec_node		*fn;
+	struct fec_nh		*fnh;
+	struct lde_map		*me;
+	struct lde_nbr		*ln;
+
+	fn = (struct fec_node *)fec_find(&ft, fec);
+	if (fn == NULL)
+		fn = fec_add(fec);
+	if (fec_nh_find(fn, af, nexthop) != NULL)
+		return;
+
+	log_debug("lde add fec %s nexthop %s",
+	    log_fec(&fn->fec), log_addr(af, nexthop));
+
+	if (fn->fec.type == FEC_TYPE_PWID)
+		fn->data = data;
+
+	if (fn->local_label == NO_LABEL) {
+		if (connected)
+			fn->local_label = egress_label(fn->fec.type);
+		else
+			fn->local_label = lde_assign_label();
+
+		/* FEC.1: perform lsr label distribution procedure */
+		RB_FOREACH(ln, nbr_tree, &lde_nbrs)
+			lde_send_labelmapping(ln, fn, 1);
+	}
+
+	fnh = fec_nh_add(fn, af, nexthop);
+	lde_send_change_klabel(fn, fnh);
+
+	switch (fn->fec.type) {
+	case FEC_TYPE_IPV4:
+	case FEC_TYPE_IPV6:
+		ln = lde_nbr_find_by_addr(af, &fnh->nexthop);
+		break;
+	case FEC_TYPE_PWID:
+		ln = lde_nbr_find_by_lsrid(fn->fec.u.pwid.lsr_id);
+		break;
+	default:
+		ln = NULL;
+		break;
+	}
+
+	if (ln) {
+		/* FEC.2  */
+		me = (struct lde_map *)fec_find(&ln->recv_map, &fn->fec);
+		if (me)
+			/* FEC.5 */
+			lde_check_mapping(&me->map, ln);
+	}
+}
+
+void
+lde_kernel_remove(struct fec *fec, int af, union ldpd_addr *nexthop)
+{
+	struct fec_node		*fn;
+	struct fec_nh		*fnh;
+
+	fn = (struct fec_node *)fec_find(&ft, fec);
+	if (fn == NULL)
+		/* route lost */
+		return;
+	fnh = fec_nh_find(fn, af, nexthop);
+	if (fnh == NULL)
+		/* route lost */
+		return;
+
+	log_debug("lde remove fec %s nexthop %s",
+	    log_fec(&fn->fec), log_addr(af, nexthop));
+
+	lde_send_delete_klabel(fn, fnh);
+	fec_nh_del(fnh);
+	if (LIST_EMPTY(&fn->nexthops)) {
+		lde_send_labelwithdraw_all(fn, NO_LABEL);
+		fn->local_label = NO_LABEL;
+		if (fn->fec.type == FEC_TYPE_PWID)
+			fn->data = NULL;
+	}
+}
+
+void
+lde_check_mapping(struct map *map, struct lde_nbr *ln)
+{
+	struct fec		 fec;
+	struct fec_node		*fn;
+	struct fec_nh		*fnh;
+	struct lde_req		*lre;
+	struct lde_map		*me;
+	struct l2vpn_pw		*pw;
+	int			 msgsource = 0;
+
+	lde_map2fec(map, ln->id, &fec);
+	fn = (struct fec_node *)fec_find(&ft, &fec);
+	if (fn == NULL)
+		fn = fec_add(&fec);
+
+	/* LMp.1: first check if we have a pending request running */
+	lre = (struct lde_req *)fec_find(&ln->sent_req, &fn->fec);
+	if (lre)
+		/* LMp.2: delete record of outstanding label request */
+		lde_req_del(ln, lre, 1);
+
+	/* RFC 4447 control word and status tlv negotiation */
+	if (map->type == MAP_TYPE_PWID && l2vpn_pw_negotiate(ln, fn, map))
+		return;
+
+	/*
+	 * LMp.3 - LMp.8: Loop detection LMp.3 - unecessary for frame-mode
+	 * mpls networks
+	 */
+
+	/* LMp.9 */
+	me = (struct lde_map *)fec_find(&ln->recv_map, &fn->fec);
+	if (me) {
+		/* LMp.10 */
+		if (me->map.label != map->label && lre == NULL) {
+			/* LMp.10a */
+			lde_send_labelrelease(ln, fn, me->map.label);
+
+			/*
+			 * Can not use lde_nbr_find_by_addr() because there's
+			 * the possibility of multipath.
+			 */
+			LIST_FOREACH(fnh, &fn->nexthops, entry) {
+				if (lde_address_find(ln, fnh->af,
+				    &fnh->nexthop) == NULL)
+					continue;
+
+				lde_send_delete_klabel(fn, fnh);
+				fnh->remote_label = NO_LABEL;
+			}
+		}
+	}
+
+	/*
+	 * LMp.11 - 12: consider multiple nexthops in order to
+	 * support multipath
+	 */
+	LIST_FOREACH(fnh, &fn->nexthops, entry) {
+		/* LMp.15: install FEC in FIB */
+		switch (fec.type) {
+		case FEC_TYPE_IPV4:
+		case FEC_TYPE_IPV6:
+			if (!lde_address_find(ln, fnh->af, &fnh->nexthop))
+				continue;
+
+			fnh->remote_label = map->label;
+			lde_send_change_klabel(fn, fnh);
+			break;
+		case FEC_TYPE_PWID:
+			pw = (struct l2vpn_pw *) fn->data;
+			if (pw == NULL)
+				continue;
+
+			pw->remote_group = map->fec.pwid.group_id;
+			if (map->flags & F_MAP_PW_IFMTU)
+				pw->remote_mtu = map->fec.pwid.ifmtu;
+			if (map->flags & F_MAP_PW_STATUS)
+				pw->remote_status = map->pw_status;
+			fnh->remote_label = map->label;
+			if (l2vpn_pw_ok(pw, fnh))
+				lde_send_change_klabel(fn, fnh);
+			break;
+		default:
+			break;
+		}
+
+		msgsource = 1;
+	}
+	/* LMp.13 & LMp.16: Record the mapping from this peer */
+	if (me == NULL)
+		me = lde_map_add(ln, fn, 0);
+	me->map = *map;
+
+	if (msgsource == 0)
+		/* LMp.13: just return since we use liberal lbl retention */
+		return;
+
+	/*
+	 * LMp.17 - LMp.27 are unnecessary since we don't need to implement
+	 * loop detection. LMp.28 - LMp.30 are unnecessary because we are
+	 * merging capable.
+	 */
+}
+
+void
+lde_check_request(struct map *map, struct lde_nbr *ln)
+{
+	struct fec	 fec;
+	struct lde_req	*lre;
+	struct fec_node	*fn;
+	struct fec_nh	*fnh;
+
+	/* TODO LRq.1: loop detection */
+
+	/* LRq.2: is there a next hop for fec? */
+	lde_map2fec(map, ln->id, &fec);
+	fn = (struct fec_node *)fec_find(&ft, &fec);
+	if (fn == NULL || LIST_EMPTY(&fn->nexthops)) {
+		lde_send_notification(ln->peerid, S_NO_ROUTE, map->messageid,
+		    htons(MSG_TYPE_LABELREQUEST));
+		return;
+	}
+
+	/* LRq.3: is MsgSource the next hop? */
+	LIST_FOREACH(fnh, &fn->nexthops, entry) {
+		switch (fec.type) {
+		case FEC_TYPE_IPV4:
+		case FEC_TYPE_IPV6:
+			if (!lde_address_find(ln, fnh->af, &fnh->nexthop))
+				continue;
+
+			lde_send_notification(ln->peerid, S_LOOP_DETECTED,
+			    map->messageid, htons(MSG_TYPE_LABELREQUEST));
+			return;
+		default:
+			break;
+		}
+	}
+
+	/* LRq.6: first check if we have a pending request running */
+	lre = (struct lde_req *)fec_find(&ln->recv_req, &fn->fec);
+	if (lre != NULL)
+		/* LRq.7: duplicate request */
+		return;
+
+	/* LRq.8: record label request */
+	lre = lde_req_add(ln, &fn->fec, 0);
+	if (lre != NULL)
+		lre->msgid = map->messageid;
+
+	/* LRq.9: perform LSR label distribution */
+	lde_send_labelmapping(ln, fn, 1);
+
+	/*
+	 * LRq.10: do nothing (Request Never) since we use liberal
+	 * label retention.
+	 * LRq.11 - 12 are unnecessary since we are merging capable.
+	 */
+}
+
+void
+lde_check_release(struct map *map, struct lde_nbr *ln)
+{
+	struct fec		 fec;
+	struct fec_node		*fn;
+	struct lde_wdraw	*lw;
+	struct lde_map		*me;
+
+	/* TODO group wildcard */
+	if (map->type == MAP_TYPE_PWID && !(map->flags & F_MAP_PW_ID))
+		return;
+
+	lde_map2fec(map, ln->id, &fec);
+	fn = (struct fec_node *)fec_find(&ft, &fec);
+	/* LRl.1: does FEC match a known FEC? */
+	if (fn == NULL)
+		return;
+
+	/* LRl.3: first check if we have a pending withdraw running */
+	lw = (struct lde_wdraw *)fec_find(&ln->sent_wdraw, &fn->fec);
+	if (lw && (map->label == NO_LABEL ||
+	    (lw->label != NO_LABEL && map->label == lw->label))) {
+		/* LRl.4: delete record of outstanding label withdraw */
+		lde_wdraw_del(ln, lw);
+	}
+
+	/* LRl.6: check sent map list and remove it if available */
+	me = (struct lde_map *)fec_find(&ln->sent_map, &fn->fec);
+	if (me && (map->label == NO_LABEL || map->label == me->map.label))
+		lde_map_del(ln, me, 1);
+
+	/*
+	 * LRl.11 - 13 are unnecessary since we remove the label from
+	 * forwarding/switching as soon as the FEC is unreachable.
+	 */
+}
+
+void
+lde_check_release_wcard(struct map *map, struct lde_nbr *ln)
+{
+	struct fec		*f;
+	struct fec_node		*fn;
+	struct lde_wdraw	*lw;
+	struct lde_map		*me;
+
+	RB_FOREACH(f, fec_tree, &ft) {
+		fn = (struct fec_node *)f;
+
+		/* LRl.3: first check if we have a pending withdraw running */
+		lw = (struct lde_wdraw *)fec_find(&ln->sent_wdraw, &fn->fec);
+		if (lw && (map->label == NO_LABEL ||
+		    (lw->label != NO_LABEL && map->label == lw->label))) {
+			/* LRl.4: delete record of outstanding lbl withdraw */
+			lde_wdraw_del(ln, lw);
+		}
+
+		/* LRl.6: check sent map list and remove it if available */
+		me = (struct lde_map *)fec_find(&ln->sent_map, &fn->fec);
+		if (me &&
+		    (map->label == NO_LABEL || map->label == me->map.label))
+			lde_map_del(ln, me, 1);
+
+		/*
+		 * LRl.11 - 13 are unnecessary since we remove the label from
+		 * forwarding/switching as soon as the FEC is unreachable.
+		 */
+	}
+}
+
+void
+lde_check_withdraw(struct map *map, struct lde_nbr *ln)
+{
+	struct fec		 fec;
+	struct fec_node		*fn;
+	struct fec_nh		*fnh;
+	struct lde_map		*me;
+	struct l2vpn_pw		*pw;
+
+	/* TODO group wildcard */
+	if (map->type == MAP_TYPE_PWID && !(map->flags & F_MAP_PW_ID))
+		return;
+
+	lde_map2fec(map, ln->id, &fec);
+	fn = (struct fec_node *)fec_find(&ft, &fec);
+	if (fn == NULL)
+		fn = fec_add(&fec);
+
+	/* LWd.1: remove label from forwarding/switching use */
+	LIST_FOREACH(fnh, &fn->nexthops, entry) {
+		switch (fec.type) {
+		case FEC_TYPE_IPV4:
+		case FEC_TYPE_IPV6:
+			if (!lde_address_find(ln, fnh->af, &fnh->nexthop))
+				continue;
+			break;
+		case FEC_TYPE_PWID:
+			pw = (struct l2vpn_pw *) fn->data;
+			if (pw == NULL)
+				continue;
+			break;
+		default:
+			break;
+		}
+		lde_send_delete_klabel(fn, fnh);
+		fnh->remote_label = NO_LABEL;
+	}
+
+	/* LWd.2: send label release */
+	lde_send_labelrelease(ln, fn, map->label);
+
+	/* LWd.3: check previously received label mapping */
+	me = (struct lde_map *)fec_find(&ln->recv_map, &fn->fec);
+	if (me && (map->label == NO_LABEL || map->label == me->map.label))
+		/* LWd.4: remove record of previously received lbl mapping */
+		lde_map_del(ln, me, 0);
+}
+
+void
+lde_check_withdraw_wcard(struct map *map, struct lde_nbr *ln)
+{
+	struct fec	*f;
+	struct fec_node	*fn;
+	struct fec_nh	*fnh;
+	struct lde_map	*me;
+
+	/* LWd.2: send label release */
+	lde_send_labelrelease(ln, NULL, map->label);
+
+	RB_FOREACH(f, fec_tree, &ft) {
+		fn = (struct fec_node *)f;
+
+		/* LWd.1: remove label from forwarding/switching use */
+		LIST_FOREACH(fnh, &fn->nexthops, entry) {
+			switch (f->type) {
+			case FEC_TYPE_IPV4:
+			case FEC_TYPE_IPV6:
+				if (!lde_address_find(ln, fnh->af,
+				    &fnh->nexthop))
+					continue;
+				break;
+			case FEC_TYPE_PWID:
+				if (f->u.pwid.lsr_id.s_addr != ln->id.s_addr)
+					continue;
+				break;
+			default:
+				break;
+			}
+			lde_send_delete_klabel(fn, fnh);
+			fnh->remote_label = NO_LABEL;
+		}
+
+		/* LWd.3: check previously received label mapping */
+		me = (struct lde_map *)fec_find(&ln->recv_map, &fn->fec);
+		if (me && (map->label == NO_LABEL ||
+		    map->label == me->map.label))
+			/*
+			 * LWd.4: remove record of previously received
+			 * label mapping
+			 */
+			lde_map_del(ln, me, 0);
+	}
+}
+
+/* gabage collector timer: timer to remove dead entries from the LIB */
+
+/* ARGSUSED */
+int
+lde_gc_timer(struct thread *thread)
+{
+	struct fec	*fec, *safe;
+	struct fec_node	*fn;
+	int		 count = 0;
+
+	RB_FOREACH_SAFE(fec, fec_tree, &ft, safe) {
+		fn = (struct fec_node *) fec;
+
+		if (!LIST_EMPTY(&fn->nexthops) ||
+		    !LIST_EMPTY(&fn->downstream) ||
+		    !LIST_EMPTY(&fn->upstream))
+			continue;
+
+		fec_remove(&ft, &fn->fec);
+		free(fn);
+		count++;
+	}
+
+	if (count > 0)
+		log_debug("%s: %u entries removed", __func__, count);
+
+	lde_gc_start_timer();
+
+	return (0);
+}
+
+void
+lde_gc_start_timer(void)
+{
+	THREAD_TIMER_OFF(gc_timer);
+	gc_timer = thread_add_timer(master, lde_gc_timer, NULL,
+	    LDE_GC_INTERVAL);
+}
+
+void
+lde_gc_stop_timer(void)
+{
+	THREAD_TIMER_OFF(gc_timer);
+}
diff --git a/ldpd/ldp.h b/ldpd/ldp.h
new file mode 100644
index 0000000..b7e68ea
--- /dev/null
+++ b/ldpd/ldp.h
@@ -0,0 +1,298 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* LDP protocol definitions */
+
+#ifndef _LDP_H_
+#define _LDP_H_
+
+/* misc */
+#define LDP_VERSION		1
+#define LDP_PORT		646
+#define LDP_MAX_LEN		4096
+
+/* All Routers on this Subnet group multicast addresses */
+#define AllRouters_v4		"224.0.0.2"
+#define AllRouters_v6		"ff02::2"
+
+#define LINK_DFLT_HOLDTIME	15
+#define TARGETED_DFLT_HOLDTIME	45
+#define MIN_HOLDTIME		3
+#define MAX_HOLDTIME		0xffff
+#define	INFINITE_HOLDTIME	0xffff
+
+#define DEFAULT_KEEPALIVE	180
+#define MIN_KEEPALIVE		3
+#define MAX_KEEPALIVE		0xffff
+#define KEEPALIVE_PER_PERIOD	3
+
+#define	DEFAULT_HELLO_INTERVAL	5
+#define	MIN_HELLO_INTERVAL	1
+#define	MAX_HELLO_INTERVAL	0xffff
+
+#define	INIT_DELAY_TMR		15
+#define	MAX_DELAY_TMR		120
+
+#define	MIN_PWID_ID		1
+#define	MAX_PWID_ID		0xffffffff
+
+#define	DEFAULT_L2VPN_MTU	1500
+#define	MIN_L2VPN_MTU		512
+#define	MAX_L2VPN_MTU		0xffff
+
+/* LDP message types */
+#define MSG_TYPE_NOTIFICATION	0x0001
+#define MSG_TYPE_HELLO		0x0100
+#define MSG_TYPE_INIT		0x0200
+#define MSG_TYPE_KEEPALIVE	0x0201
+#define MSG_TYPE_ADDR		0x0300
+#define MSG_TYPE_ADDRWITHDRAW	0x0301
+#define MSG_TYPE_LABELMAPPING	0x0400
+#define MSG_TYPE_LABELREQUEST	0x0401
+#define MSG_TYPE_LABELWITHDRAW	0x0402
+#define MSG_TYPE_LABELRELEASE	0x0403
+#define MSG_TYPE_LABELABORTREQ	0x0404
+
+/* LDP TLV types */
+#define TLV_TYPE_FEC		0x0100
+#define TLV_TYPE_ADDRLIST	0x0101
+#define TLV_TYPE_HOPCOUNT	0x0103
+#define TLV_TYPE_PATHVECTOR	0x0104
+#define TLV_TYPE_GENERICLABEL	0x0200
+#define TLV_TYPE_ATMLABEL	0x0201
+#define TLV_TYPE_FRLABEL	0x0202
+#define TLV_TYPE_STATUS		0x0300
+#define TLV_TYPE_EXTSTATUS	0x0301
+#define TLV_TYPE_RETURNEDPDU	0x0302
+#define TLV_TYPE_RETURNEDMSG	0x0303
+#define TLV_TYPE_COMMONHELLO	0x0400
+#define TLV_TYPE_IPV4TRANSADDR	0x0401
+#define TLV_TYPE_CONFIG		0x0402
+#define TLV_TYPE_IPV6TRANSADDR	0x0403
+#define TLV_TYPE_COMMONSESSION	0x0500
+#define TLV_TYPE_ATMSESSIONPAR	0x0501
+#define TLV_TYPE_FRSESSION	0x0502
+#define TLV_TYPE_LABELREQUEST	0x0600
+/* RFC 4447 */
+#define TLV_TYPE_PW_STATUS	0x096A
+#define TLV_TYPE_PW_IF_PARAM	0x096B
+#define TLV_TYPE_PW_GROUP_ID	0x096C
+/* RFC 7552 */
+#define TLV_TYPE_DUALSTACK	0x8701
+
+/* LDP header */
+struct ldp_hdr {
+	uint16_t	version;
+	uint16_t	length;
+	uint32_t	lsr_id;
+	uint16_t	lspace_id;
+} __attribute__ ((packed));
+
+#define	LDP_HDR_SIZE		10	/* actual size of the LDP header */
+#define	LDP_HDR_PDU_LEN		6	/* minimum "PDU Length" */
+#define LDP_HDR_DEAD_LEN	4
+
+/* TLV record */
+struct tlv {
+	uint16_t	type;
+	uint16_t	length;
+};
+#define	TLV_HDR_LEN		4
+
+struct ldp_msg {
+	uint16_t	type;
+	uint16_t	length;
+	uint32_t	msgid;
+	/* Mandatory Parameters */
+	/* Optional Parameters */
+} __attribute__ ((packed));
+
+#define LDP_MSG_SIZE		8	/* minimum size of LDP message */
+#define LDP_MSG_LEN		4	/* minimum "Message Length" */
+#define LDP_MSG_DEAD_LEN	4
+
+#define	UNKNOWN_FLAG		0x8000
+#define	FORWARD_FLAG		0xc000
+
+struct hello_prms_tlv {
+	uint16_t	type;
+	uint16_t	length;
+	uint16_t	holdtime;
+	uint16_t	flags;
+};
+
+#define TARGETED_HELLO		0x8000
+#define REQUEST_TARG_HELLO	0x4000
+
+struct hello_prms_opt4_tlv {
+	uint16_t	type;
+	uint16_t	length;
+	uint32_t	value;
+};
+
+struct hello_prms_opt16_tlv {
+	uint16_t	type;
+	uint16_t	length;
+	uint8_t		value[16];
+};
+
+#define DUAL_STACK_LDPOV4	4
+#define DUAL_STACK_LDPOV6	6
+
+#define F_HELLO_TLV_RCVD_ADDR	0x01
+#define F_HELLO_TLV_RCVD_CONF	0x02
+#define F_HELLO_TLV_RCVD_DS	0x04
+
+#define	S_SUCCESS	0x00000000
+#define	S_BAD_LDP_ID	0x80000001
+#define	S_BAD_PROTO_VER	0x80000002
+#define	S_BAD_PDU_LEN	0x80000003
+#define	S_UNKNOWN_MSG	0x00000004
+#define	S_BAD_MSG_LEN	0x80000005
+#define	S_UNKNOWN_TLV	0x00000006
+#define	S_BAD_TLV_LEN	0x80000007
+#define	S_BAD_TLV_VAL	0x80000008
+#define	S_HOLDTIME_EXP	0x80000009
+#define	S_SHUTDOWN	0x8000000A
+#define	S_LOOP_DETECTED	0x0000000B
+#define	S_UNKNOWN_FEC	0x0000000C
+#define	S_NO_ROUTE	0x0000000D
+#define	S_NO_LABEL_RES	0x0000000E
+#define	S_AVAILABLE	0x0000000F
+#define	S_NO_HELLO	0x80000010
+#define	S_PARM_ADV_MODE	0x80000011
+#define	S_MAX_PDU_LEN	0x80000012
+#define	S_PARM_L_RANGE	0x80000013
+#define	S_KEEPALIVE_TMR	0x80000014
+#define	S_LAB_REQ_ABRT	0x00000015
+#define	S_MISS_MSG	0x00000016
+#define	S_UNSUP_ADDR	0x00000017
+#define	S_KEEPALIVE_BAD	0x80000018
+#define	S_INTERN_ERR	0x80000019
+/* RFC 4447 */
+#define S_ILLEGAL_CBIT	0x00000024
+#define S_WRONG_CBIT	0x00000025
+#define S_INCPT_BITRATE	0x00000026
+#define S_CEP_MISCONF	0x00000027
+#define S_PW_STATUS	0x00000028
+#define S_UNASSIGN_TAI	0x00000029
+#define S_MISCONF_ERR	0x0000002A
+#define S_WITHDRAW_MTHD	0x0000002B
+/* RFC 7552 */
+#define	S_TRANS_MISMTCH	0x80000032
+#define	S_DS_NONCMPLNCE	0x80000033
+
+struct sess_prms_tlv {
+	uint16_t	type;
+	uint16_t	length;
+	uint16_t	proto_version;
+	uint16_t	keepalive_time;
+	uint8_t		reserved;
+	uint8_t		pvlim;
+	uint16_t	max_pdu_len;
+	uint32_t	lsr_id;
+	uint16_t	lspace_id;
+} __attribute__ ((packed));
+
+#define SESS_PRMS_SIZE		18
+
+struct status_tlv {
+	uint16_t	type;
+	uint16_t	length;
+	uint32_t	status_code;
+	uint32_t	msg_id;
+	uint16_t	msg_type;
+} __attribute__ ((packed));
+
+#define STATUS_SIZE		14
+#define STATUS_TLV_LEN		10
+#define	STATUS_FATAL		0x80000000
+
+#define	AF_IPV4			0x1
+#define	AF_IPV6			0x2
+
+struct address_list_tlv {
+	uint16_t	type;
+	uint16_t	length;
+	uint16_t	family;
+	/* address entries */
+} __attribute__ ((packed));
+
+#define FEC_ELM_WCARD_LEN	1
+#define FEC_ELM_PREFIX_MIN_LEN	4
+#define FEC_PWID_ELM_MIN_LEN	8
+
+#define	MAP_TYPE_WILDCARD	0x01
+#define	MAP_TYPE_PREFIX		0x02
+#define	MAP_TYPE_PWID		0x80
+#define	MAP_TYPE_GENPWID	0x81
+
+#define CONTROL_WORD_FLAG	0x8000
+#define PW_TYPE_ETHERNET_TAGGED	0x0004
+#define PW_TYPE_ETHERNET	0x0005
+#define DEFAULT_PW_TYPE		PW_TYPE_ETHERNET
+
+/* RFC 4447 Sub-TLV record */
+struct subtlv {
+	uint8_t		type;
+	uint8_t		length;
+};
+#define	SUBTLV_HDR_LEN		2
+
+#define SUBTLV_IFMTU		0x01
+#define SUBTLV_VLANID		0x06
+
+#define FEC_SUBTLV_IFMTU_LEN	4
+#define FEC_SUBTLV_VLANID_LEN	4
+
+struct label_tlv {
+	uint16_t	type;
+	uint16_t	length;
+	uint32_t	label;
+};
+
+#define LABEL_TLV_LEN		8
+
+struct reqid_tlv {
+	uint16_t	type;
+	uint16_t	length;
+	uint32_t	reqid;
+};
+
+#define REQID_TLV_LEN		8
+
+struct pw_status_tlv {
+	uint16_t	type;
+	uint16_t	length;
+	uint32_t	value;
+};
+
+#define PW_STATUS_TLV_LEN	8
+
+#define PW_FORWARDING		0
+#define PW_NOT_FORWARDING	(1 << 0)
+#define PW_LOCAL_RX_FAULT	(1 << 1)
+#define PW_LOCAL_TX_FAULT	(1 << 2)
+#define PW_PSN_RX_FAULT		(1 << 3)
+#define PW_PSN_TX_FAULT		(1 << 4)
+
+#define	NO_LABEL		UINT_MAX
+
+#endif /* !_LDP_H_ */
diff --git a/ldpd/ldp_vty.h b/ldpd/ldp_vty.h
new file mode 100644
index 0000000..b5ad649
--- /dev/null
+++ b/ldpd/ldp_vty.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2016 by Open Source Routing.
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#ifndef _LDP_VTY_H_
+#define _LDP_VTY_H_
+
+#include "vty.h"
+
+extern struct cmd_node ldp_node;
+extern struct cmd_node ldp_ipv4_node;
+extern struct cmd_node ldp_ipv6_node;
+extern struct cmd_node ldp_ipv4_iface_node;
+extern struct cmd_node ldp_ipv6_iface_node;
+extern struct cmd_node ldp_l2vpn_node;
+extern struct cmd_node ldp_pseudowire_node;
+
+union ldpd_addr;
+int	 ldp_get_address(const char *, int *, union ldpd_addr *);
+int	 ldp_config_write(struct vty *);
+int	 ldp_l2vpn_config_write(struct vty *);
+int	 ldp_vty_mpls_ldp (struct vty *, struct vty_arg *[]);
+int	 ldp_vty_address_family (struct vty *, struct vty_arg *[]);
+int	 ldp_vty_disc_holdtime(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_disc_interval(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_targeted_hello_accept(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_session_holdtime(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_interface(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_trans_addr(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_neighbor_targeted(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_explicit_null(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_router_id(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_ds_cisco_interop(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_trans_pref_ipv4(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_neighbor_password(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_l2vpn(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_l2vpn_bridge(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_l2vpn_mtu(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_l2vpn_pwtype(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_l2vpn_interface(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_l2vpn_pseudowire(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_l2vpn_pw_cword(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_l2vpn_pw_nbr_addr(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_l2vpn_pw_nbr_id(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_l2vpn_pw_pwid(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_l2vpn_pw_pwstatus(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_show_binding(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_show_discovery(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_show_interface(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_show_neighbor(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_show_atom_binding(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_show_atom_vc(struct vty *, struct vty_arg *[]);
+int	 ldp_vty_clear_nbr(struct vty *, struct vty_arg *[]);
+
+void	 ldp_vty_init(void);
+void	 ldp_vty_if_init(void);
+
+#endif	/* _LDP_VTY_H_ */
diff --git a/ldpd/ldp_vty.xml b/ldpd/ldp_vty.xml
new file mode 100644
index 0000000..d49d94e
--- /dev/null
+++ b/ldpd/ldp_vty.xml
@@ -0,0 +1,324 @@
+<?xml version="1.0"?>
+<file init="ldp_vty_init" cmdprefix="ldp" header="ldp_vty.h">
+  <!-- address-family -->
+  <options name="address-family">
+    <option name="ipv4" help="IPv4 Address Family"/>
+    <option name="ipv6" help="IPv6 Address Family"/>
+  </options>
+
+  <!-- ipv4/ipv6 address -->
+  <options name="addr">
+    <option input="ipv4" help="IPv4 address"/>
+    <option input="ipv6" help="IPv6 address"/>
+  </options>
+
+  <!-- pseudowire control-word options -->
+  <options name="cword">
+    <option name="exclude" help="Exclude control-word in pseudowire packets"/>
+    <option name="include" help="Include control-word in pseudowire packets"/>
+  </options>
+
+  <!-- pseudowire types -->
+  <options name="pwtype">
+    <option name="ethernet" help="Ethernet (type 5)"/>
+    <option name="ethernet-tagged" help="Ethernet-tagged (type 4)"/>
+  </options>
+
+  <!-- shared subtrees -->
+  <subtree name="discovery_link">
+    <option name="discovery" help="Configure discovery parameters">
+      <option name="hello" arg="hello_type" help="LDP Link Hellos">
+        <option name="holdtime" help="Hello holdtime">
+          <option input="disc_time" arg="seconds" help="Time (seconds) - 65535 implies infinite" function="ldp_vty_disc_holdtime"/>
+        </option>
+        <option name="interval" help="Hello interval">
+          <option input="disc_time" arg="seconds" help="Time (seconds)" function="ldp_vty_disc_interval"/>
+        </option>
+      </option>
+    </option>
+  </subtree>
+
+  <subtree name="discovery_targeted">
+    <option name="discovery" help="Configure discovery parameters">
+      <option name="targeted-hello" arg="hello_type" help="LDP Targeted Hellos">
+        <option name="holdtime" help="Targeted hello holdtime">
+          <option input="disc_time" arg="seconds" help="Time (seconds) - 65535 implies infinite" function="ldp_vty_disc_holdtime"/>
+        </option>
+        <option name="interval" help="Targeted hello interval">
+          <option input="disc_time" arg="seconds" help="Time (seconds)" function="ldp_vty_disc_interval"/>
+        </option>
+      </option>
+    </option>
+  </subtree>
+
+  <subtree name="session_holdtime">
+    <option name="session" help="Configure session parameters">
+      <option name="holdtime" help="Configure session holdtime">
+        <option input="session_time" arg="seconds" help="Time (seconds)" function="ldp_vty_session_holdtime"/>
+      </option>
+    </option>
+  </subtree>
+
+  <subtree name="af_common">
+    <include subtree="discovery_link"/>
+    <include subtree="discovery_targeted"/>
+    <option name="discovery" help="Configure discovery parameters">
+      <option name="targeted-hello" arg="hello_type" help="LDP Targeted Hellos">
+        <option name="accept" help="Accept and respond to targeted hellos" function="ldp_vty_targeted_hello_accept"/>
+      </option>
+    </option>
+    <option name="label" help="Configure label control and policies">
+      <option name="local" help="Configure local label control and policies">
+        <option name="advertise" help="Configure outbound label advertisement control">
+          <option name="explicit-null" help="Configure explicit-null advertisement" function="ldp_vty_explicit_null"/>
+        </option>
+      </option>
+    </option>
+    <include subtree="session_holdtime"/>
+    <option name="interface" help="Enable LDP on an interface and enter interface submode">
+      <option input="ifname" arg="ifname" help="Interface's name" function="ldp_vty_interface"/>
+    </option>
+  </subtree>
+
+  <!-- global -->
+  <subtree name="__global">
+    <option name="mpls" help="Global MPLS configuration subcommands">
+      <option name="ldp" help="Label Distribution Protocol" function="ldp_vty_mpls_ldp"/>
+    </option>
+    <option name="l2vpn" help="Configure l2vpn commands">
+      <option input="word" arg="name" help="L2VPN name">
+        <option name="type" help="L2VPN type">
+          <option name="vpls" help="Virtual Private LAN Service" function="ldp_vty_l2vpn"/>
+        </option>
+      </option>
+    </option>
+  </subtree>
+  <tree name="global">
+    <include subtree="__global"/>
+    <option name="no" arg="no" help="Negate a command or set its defaults">
+        <include subtree="__global"/>
+    </option>
+  </tree>
+
+  <!-- ldp node -->
+  <subtree name="__ldp_node">
+    <option name="address-family" help="Configure Address Family and its parameters">
+      <option name="ipv4" arg="address-family" help="IPv4" function="ldp_vty_address_family"/>
+      <option name="ipv6" arg="address-family" help="IPv6" function="ldp_vty_address_family"/>
+    </option>
+    <include subtree="discovery_link"/>
+    <include subtree="discovery_targeted"/>
+    <option name="dual-stack" help="Configure dual stack parameters">
+      <option name="transport-connection" help="Configure TCP transport parameters">
+        <option name="prefer" help="Configure prefered address family for TCP transport connection with neighbor">
+          <option name="ipv4" help="IPv4" function="ldp_vty_trans_pref_ipv4"/>
+        </option>
+      </option>
+      <option name="cisco-interop" help="Use Cisco non-compliant format to send and interpret the Dual-Stack capability TLV" function="ldp_vty_ds_cisco_interop"/>
+    </option>
+    <option name="neighbor" help="Configure neighbor parameters">
+      <option input="ipv4" arg="lsr_id" help="LDP Id of neighbor">
+        <option name="password" help="Configure password for MD5 authentication">
+          <option input="word" arg="password" help="The password" function="ldp_vty_neighbor_password"/>
+        </option>
+        <include subtree="session_holdtime"/>
+      </option>
+    </option>
+    <option name="router-id" help="Configure router Id">
+      <option input="ipv4" arg="addr" help="LSR Id (in form of an IPv4 address)" function="ldp_vty_router_id"/>
+    </option>
+  </subtree>
+  <tree name="ldp_node">
+    <include subtree="__ldp_node"/>
+    <option name="no" arg="no" help="Negate a command or set its defaults">
+        <include subtree="__ldp_node"/>
+    </option>
+  </tree>
+
+  <!-- address-family ipv4 -->
+  <subtree name="__ldp_ipv4_node">
+    <include subtree="af_common"/>
+    <option name="discovery" help="Configure discovery parameters">
+      <option name="transport-address" help="Specify transport address for TCP connection">
+        <option input="ipv4" arg="addr" help="IP address to be used as transport address" function="ldp_vty_trans_addr"/>
+      </option>
+     </option>
+     <option name="neighbor" help="Configure neighbor parameters">
+       <option input="ipv4" arg="addr" help="IP address of neighbor">
+         <option name="targeted" help="Establish targeted session" function="ldp_vty_neighbor_targeted"/>
+       </option>
+     </option>
+  </subtree>
+  <tree name="ldp_ipv4_node">
+    <include subtree="__ldp_ipv4_node"/>
+    <option name="no" arg="no" help="Negate a command or set its defaults">
+      <include subtree="__ldp_ipv4_node"/>
+    </option>
+  </tree>
+
+  <!-- address-family ipv6 -->
+  <subtree name="__ldp_ipv6_node">
+    <include subtree="af_common"/>
+    <option name="discovery" help="Configure discovery parameters">
+      <option name="transport-address" help="Specify transport address for TCP connection">
+        <option input="ipv6" arg="addr" help="IPv6 address to be used as transport address" function="ldp_vty_trans_addr"/>
+      </option>
+    </option>
+     <option name="neighbor" help="Configure neighbor parameters">
+       <option input="ipv6" arg="addr" help="IPv6 address of neighbor">
+         <option name="targeted" help="Establish targeted session" function="ldp_vty_neighbor_targeted"/>
+       </option>
+     </option>
+  </subtree>
+  <tree name="ldp_ipv6_node">
+    <include subtree="__ldp_ipv6_node"/>
+    <option name="no" arg="no" help="Negate a command or set its defaults">
+      <include subtree="__ldp_ipv6_node"/>
+    </option>
+  </tree>
+
+  <!-- ldp ipv4 interface node -->
+  <subtree name="__ldp_ipv4_iface_node">
+    <include subtree="discovery_link"/>
+  </subtree>
+  <tree name="ldp_ipv4_iface_node">
+    <include subtree="__ldp_ipv4_iface_node"/>
+    <option name="no" arg="no" help="Negate a command or set its defaults">
+      <include subtree="__ldp_ipv4_iface_node"/>
+    </option>
+  </tree>
+
+  <!-- ldp ipv6 interface node -->
+  <subtree name="__ldp_ipv6_iface_node">
+    <include subtree="discovery_link"/>
+  </subtree>
+  <tree name="ldp_ipv6_iface_node">
+    <include subtree="__ldp_ipv6_iface_node"/>
+    <option name="no" arg="no" help="Negate a command or set its defaults">
+      <include subtree="__ldp_ipv6_iface_node"/>
+    </option>
+  </tree>
+
+  <!-- l2vpn -->
+  <subtree name="__ldp_l2vpn">
+    <option name="bridge" help="Bridge interface">
+      <option input="ifname" arg="ifname" help="Interface's name" function="ldp_vty_l2vpn_bridge"/>
+    </option>
+    <option name="mtu" help="set Maximum Transmission Unit">
+      <option input="mtu" arg="mtu" help="Maximum Transmission Unit value" function="ldp_vty_l2vpn_mtu"/>
+    </option>
+    <option name="member" help="L2VPN member configuration">
+      <option name="interface" help="Local interface">
+        <option input="ifname" arg="ifname" help="Interface's name" function="ldp_vty_l2vpn_interface"/>
+      </option>
+      <option name="pseudowire" help="Pseudowire interface">
+        <option input="ifname" arg="ifname" help="Interface's name" function="ldp_vty_l2vpn_pseudowire"/>
+      </option>
+    </option>
+    <option name="vc" help="Virtual Circuit options">
+      <option name="type" help="Virtual Circuit type to use">
+        <select options="pwtype" arg="type" function="ldp_vty_l2vpn_pwtype"/>
+      </option>
+    </option>
+  </subtree>
+  <tree name="ldp_l2vpn">
+    <include subtree="__ldp_l2vpn"/>
+    <option name="no" arg="no" help="Negate a command or set its defaults">
+      <include subtree="__ldp_l2vpn"/>
+    </option>
+  </tree>
+
+  <!-- l2vpn pseudowire -->
+  <subtree name="__ldp_pseudowire">
+    <option name="control-word" help="Control-word options">
+      <select options="cword" arg="preference" function="ldp_vty_l2vpn_pw_cword"/>
+    </option>
+    <option name="neighbor" help="Remote endpoint configuration">
+      <option name="address" help="Specify the IPv4 or IPv6 address of the remote endpoint">
+        <select options="addr" arg="addr" function="ldp_vty_l2vpn_pw_nbr_addr"/>
+      </option>
+      <option name="lsr-id" help="Specify the LSR-ID of the remote endpoint">
+        <option input="ipv4" arg="lsr-id" help="IPv4 address" function="ldp_vty_l2vpn_pw_nbr_id"/>
+      </option>
+    </option>
+    <option name="pw-id" help="Set the Virtual Circuit ID">
+      <option input="pwid" arg="pwid" help="Virtual Circuit ID value" function="ldp_vty_l2vpn_pw_pwid"/>
+    </option>
+    <option name="pw-status" help="Configure PW status">
+      <option name="disable" help="Disable PW status" function="ldp_vty_l2vpn_pw_pwstatus"/>
+    </option>
+  </subtree>
+  <tree name="ldp_pseudowire">
+    <include subtree="__ldp_pseudowire"/>
+    <option name="no" arg="no" help="Negate a command or set its defaults">
+      <include subtree="__ldp_pseudowire"/>
+    </option>
+  </tree>
+
+  <!-- exec mode commands -->
+  <subtree name="ldp_show_af">
+    <option name="binding" help="Label Information Base (LIB) information" function="ldp_vty_show_binding"/>
+    <option name="discovery" help="Discovery Hello Information" function="ldp_vty_show_discovery"/>
+    <option name="interface" help="interface information" function="ldp_vty_show_interface"/>
+  </subtree>
+  <tree name="ldp_exec">
+    <option name="show" help="Show running system information">
+      <option name="mpls" help="MPLS information">
+        <option name="ldp" help="Label Distribution Protocol">
+          <option name="neighbor" help="Neighbor information" function="ldp_vty_show_neighbor"/>
+          <include subtree="ldp_show_af"/>
+          <select options="address-family" arg="address-family">
+            <include subtree="ldp_show_af"/>
+          </select>
+        </option>
+      </option>
+      <option name="l2vpn" help="Show information about Layer2 VPN">
+        <option name="atom" help="Show Any Transport over MPLS information">
+          <option name="binding" help="Show AToM label binding information" function="ldp_vty_show_atom_binding"/>
+          <option name="vc" help="Show AToM virtual circuit information" function="ldp_vty_show_atom_vc"/>
+        </option>
+      </option>
+    </option>
+    <option name="clear" help="Reset functions">
+      <option name="mpls" help="Reset MPLS statistical information">
+        <option name="ldp" help="Clear LDP state">
+          <option name="neighbor" help="Clear LDP neighbor sessions" function="ldp_vty_clear_nbr">
+            <select options="addr" arg="addr" function="ldp_vty_clear_nbr"/>
+          </option>
+        </option>
+      </option>
+    </option>
+  </tree>
+
+  <!-- nodes -->
+  <node name="CONFIG">
+    <include tree="global"/>
+  </node>
+  <node install="1" config_write="ldp_config_write" name="LDP">
+    <include tree="ldp_node"/>
+  </node>
+  <node install="1" config_write="NULL" name="LDP_IPV4">
+    <include tree="ldp_ipv4_node"/>
+  </node>
+  <node install="1" config_write="NULL" name="LDP_IPV6">
+    <include tree="ldp_ipv6_node"/>
+  </node>
+  <node install="1" config_write="NULL" name="LDP_IPV4_IFACE">
+    <include tree="ldp_ipv4_iface_node"/>
+  </node>
+  <node install="1" config_write="NULL" name="LDP_IPV6_IFACE">
+    <include tree="ldp_ipv6_iface_node"/>
+  </node>
+  <node install="1" config_write="ldp_l2vpn_config_write" name="LDP_L2VPN">
+    <include tree="ldp_l2vpn"/>
+  </node>
+  <node install="1" config_write="NULL" name="LDP_PSEUDOWIRE">
+    <include tree="ldp_pseudowire"/>
+  </node>
+  <node name="ENABLE">
+    <include tree="ldp_exec"/>
+  </node>
+  <node name="VIEW">
+    <include tree="ldp_exec"/>
+  </node>
+</file>
diff --git a/ldpd/ldp_vty_cmds.c b/ldpd/ldp_vty_cmds.c
new file mode 100644
index 0000000..1fcac26
--- /dev/null
+++ b/ldpd/ldp_vty_cmds.c
@@ -0,0 +1,1282 @@
+/* Auto-generated from ldp_vty.xml. */
+/* Do not edit! */
+
+#include <zebra.h>
+
+#include "command.h"
+#include "vty.h"
+#include "ldp_vty.h"
+
+DEFUN (ldp_mpls_ldp,
+       ldp_mpls_ldp_cmd,
+       "mpls ldp",
+       "Global MPLS configuration subcommands\n"
+       "Label Distribution Protocol\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_mpls_ldp (vty, args);
+}
+
+DEFUN (ldp_l2vpn_word_type_vpls,
+       ldp_l2vpn_word_type_vpls_cmd,
+       "l2vpn WORD type vpls",
+       "Configure l2vpn commands\n"
+       "L2VPN name\n"
+       "L2VPN type\n"
+       "Virtual Private LAN Service\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "name", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn (vty, args);
+}
+
+DEFUN (ldp_no_mpls_ldp,
+       ldp_no_mpls_ldp_cmd,
+       "no mpls ldp",
+       "Negate a command or set its defaults\n"
+       "Global MPLS configuration subcommands\n"
+       "Label Distribution Protocol\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      NULL
+    };
+  return ldp_vty_mpls_ldp (vty, args);
+}
+
+DEFUN (ldp_no_l2vpn_word_type_vpls,
+       ldp_no_l2vpn_word_type_vpls_cmd,
+       "no l2vpn WORD type vpls",
+       "Negate a command or set its defaults\n"
+       "Configure l2vpn commands\n"
+       "L2VPN name\n"
+       "L2VPN type\n"
+       "Virtual Private LAN Service\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "name", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn (vty, args);
+}
+
+DEFUN (ldp_address_family_ipv4,
+       ldp_address_family_ipv4_cmd,
+       "address-family ipv4",
+       "Configure Address Family and its parameters\n"
+       "IPv4\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "address-family", .value = "ipv4" },
+      NULL
+    };
+  return ldp_vty_address_family (vty, args);
+}
+
+DEFUN (ldp_address_family_ipv6,
+       ldp_address_family_ipv6_cmd,
+       "address-family ipv6",
+       "Configure Address Family and its parameters\n"
+       "IPv6\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "address-family", .value = "ipv6" },
+      NULL
+    };
+  return ldp_vty_address_family (vty, args);
+}
+
+DEFUN (ldp_discovery_hello_holdtime_disc_time,
+       ldp_discovery_hello_holdtime_disc_time_cmd,
+       "discovery hello holdtime <1-65535>",
+       "Configure discovery parameters\n"
+       "LDP Link Hellos\n"
+       "Hello holdtime\n"
+       "Time (seconds) - 65535 implies infinite\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "hello_type", .value = "hello" },
+      &(struct vty_arg) { .name = "seconds", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_disc_holdtime (vty, args);
+}
+
+DEFUN (ldp_discovery_hello_interval_disc_time,
+       ldp_discovery_hello_interval_disc_time_cmd,
+       "discovery hello interval <1-65535>",
+       "Configure discovery parameters\n"
+       "LDP Link Hellos\n"
+       "Hello interval\n"
+       "Time (seconds)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "hello_type", .value = "hello" },
+      &(struct vty_arg) { .name = "seconds", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_disc_interval (vty, args);
+}
+
+DEFUN (ldp_discovery_targeted_hello_holdtime_disc_time,
+       ldp_discovery_targeted_hello_holdtime_disc_time_cmd,
+       "discovery targeted-hello holdtime <1-65535>",
+       "Configure discovery parameters\n"
+       "LDP Targeted Hellos\n"
+       "Targeted hello holdtime\n"
+       "Time (seconds) - 65535 implies infinite\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "hello_type", .value = "targeted-hello" },
+      &(struct vty_arg) { .name = "seconds", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_disc_holdtime (vty, args);
+}
+
+DEFUN (ldp_discovery_targeted_hello_interval_disc_time,
+       ldp_discovery_targeted_hello_interval_disc_time_cmd,
+       "discovery targeted-hello interval <1-65535>",
+       "Configure discovery parameters\n"
+       "LDP Targeted Hellos\n"
+       "Targeted hello interval\n"
+       "Time (seconds)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "hello_type", .value = "targeted-hello" },
+      &(struct vty_arg) { .name = "seconds", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_disc_interval (vty, args);
+}
+
+DEFUN (ldp_dual_stack_transport_connection_prefer_ipv4,
+       ldp_dual_stack_transport_connection_prefer_ipv4_cmd,
+       "dual-stack transport-connection prefer ipv4",
+       "Configure dual stack parameters\n"
+       "Configure TCP transport parameters\n"
+       "Configure prefered address family for TCP transport connection with neighbor\n"
+       "IPv4\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_trans_pref_ipv4 (vty, args);
+}
+
+DEFUN (ldp_dual_stack_cisco_interop,
+       ldp_dual_stack_cisco_interop_cmd,
+       "dual-stack cisco-interop",
+       "Configure dual stack parameters\n"
+       "Use Cisco non-compliant format to send and interpret the Dual-Stack capability TLV\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_ds_cisco_interop (vty, args);
+}
+
+DEFUN (ldp_neighbor_ipv4_password_word,
+       ldp_neighbor_ipv4_password_word_cmd,
+       "neighbor A.B.C.D password WORD",
+       "Configure neighbor parameters\n"
+       "LDP Id of neighbor\n"
+       "Configure password for MD5 authentication\n"
+       "The password\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "lsr_id", .value = argv[0] },
+      &(struct vty_arg) { .name = "password", .value = argv[1] },
+      NULL
+    };
+  return ldp_vty_neighbor_password (vty, args);
+}
+
+DEFUN (ldp_neighbor_ipv4_session_holdtime_session_time,
+       ldp_neighbor_ipv4_session_holdtime_session_time_cmd,
+       "neighbor A.B.C.D session holdtime <15-65535>",
+       "Configure neighbor parameters\n"
+       "LDP Id of neighbor\n"
+       "Configure session parameters\n"
+       "Configure session holdtime\n"
+       "Time (seconds)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "lsr_id", .value = argv[0] },
+      &(struct vty_arg) { .name = "seconds", .value = argv[1] },
+      NULL
+    };
+  return ldp_vty_session_holdtime (vty, args);
+}
+
+DEFUN (ldp_router_id_ipv4,
+       ldp_router_id_ipv4_cmd,
+       "router-id A.B.C.D",
+       "Configure router Id\n"
+       "LSR Id (in form of an IPv4 address)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_router_id (vty, args);
+}
+
+DEFUN (ldp_no_address_family_ipv4,
+       ldp_no_address_family_ipv4_cmd,
+       "no address-family ipv4",
+       "Negate a command or set its defaults\n"
+       "Configure Address Family and its parameters\n"
+       "IPv4\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "address-family", .value = "ipv4" },
+      NULL
+    };
+  return ldp_vty_address_family (vty, args);
+}
+
+DEFUN (ldp_no_address_family_ipv6,
+       ldp_no_address_family_ipv6_cmd,
+       "no address-family ipv6",
+       "Negate a command or set its defaults\n"
+       "Configure Address Family and its parameters\n"
+       "IPv6\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "address-family", .value = "ipv6" },
+      NULL
+    };
+  return ldp_vty_address_family (vty, args);
+}
+
+DEFUN (ldp_no_discovery_hello_holdtime_disc_time,
+       ldp_no_discovery_hello_holdtime_disc_time_cmd,
+       "no discovery hello holdtime <1-65535>",
+       "Negate a command or set its defaults\n"
+       "Configure discovery parameters\n"
+       "LDP Link Hellos\n"
+       "Hello holdtime\n"
+       "Time (seconds) - 65535 implies infinite\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "hello_type", .value = "hello" },
+      &(struct vty_arg) { .name = "seconds", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_disc_holdtime (vty, args);
+}
+
+DEFUN (ldp_no_discovery_hello_interval_disc_time,
+       ldp_no_discovery_hello_interval_disc_time_cmd,
+       "no discovery hello interval <1-65535>",
+       "Negate a command or set its defaults\n"
+       "Configure discovery parameters\n"
+       "LDP Link Hellos\n"
+       "Hello interval\n"
+       "Time (seconds)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "hello_type", .value = "hello" },
+      &(struct vty_arg) { .name = "seconds", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_disc_interval (vty, args);
+}
+
+DEFUN (ldp_no_discovery_targeted_hello_holdtime_disc_time,
+       ldp_no_discovery_targeted_hello_holdtime_disc_time_cmd,
+       "no discovery targeted-hello holdtime <1-65535>",
+       "Negate a command or set its defaults\n"
+       "Configure discovery parameters\n"
+       "LDP Targeted Hellos\n"
+       "Targeted hello holdtime\n"
+       "Time (seconds) - 65535 implies infinite\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "hello_type", .value = "targeted-hello" },
+      &(struct vty_arg) { .name = "seconds", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_disc_holdtime (vty, args);
+}
+
+DEFUN (ldp_no_discovery_targeted_hello_interval_disc_time,
+       ldp_no_discovery_targeted_hello_interval_disc_time_cmd,
+       "no discovery targeted-hello interval <1-65535>",
+       "Negate a command or set its defaults\n"
+       "Configure discovery parameters\n"
+       "LDP Targeted Hellos\n"
+       "Targeted hello interval\n"
+       "Time (seconds)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "hello_type", .value = "targeted-hello" },
+      &(struct vty_arg) { .name = "seconds", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_disc_interval (vty, args);
+}
+
+DEFUN (ldp_no_dual_stack_transport_connection_prefer_ipv4,
+       ldp_no_dual_stack_transport_connection_prefer_ipv4_cmd,
+       "no dual-stack transport-connection prefer ipv4",
+       "Negate a command or set its defaults\n"
+       "Configure dual stack parameters\n"
+       "Configure TCP transport parameters\n"
+       "Configure prefered address family for TCP transport connection with neighbor\n"
+       "IPv4\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      NULL
+    };
+  return ldp_vty_trans_pref_ipv4 (vty, args);
+}
+
+DEFUN (ldp_no_dual_stack_cisco_interop,
+       ldp_no_dual_stack_cisco_interop_cmd,
+       "no dual-stack cisco-interop",
+       "Negate a command or set its defaults\n"
+       "Configure dual stack parameters\n"
+       "Use Cisco non-compliant format to send and interpret the Dual-Stack capability TLV\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      NULL
+    };
+  return ldp_vty_ds_cisco_interop (vty, args);
+}
+
+DEFUN (ldp_no_neighbor_ipv4_password_word,
+       ldp_no_neighbor_ipv4_password_word_cmd,
+       "no neighbor A.B.C.D password WORD",
+       "Negate a command or set its defaults\n"
+       "Configure neighbor parameters\n"
+       "LDP Id of neighbor\n"
+       "Configure password for MD5 authentication\n"
+       "The password\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "lsr_id", .value = argv[0] },
+      &(struct vty_arg) { .name = "password", .value = argv[1] },
+      NULL
+    };
+  return ldp_vty_neighbor_password (vty, args);
+}
+
+DEFUN (ldp_no_neighbor_ipv4_session_holdtime_session_time,
+       ldp_no_neighbor_ipv4_session_holdtime_session_time_cmd,
+       "no neighbor A.B.C.D session holdtime <15-65535>",
+       "Negate a command or set its defaults\n"
+       "Configure neighbor parameters\n"
+       "LDP Id of neighbor\n"
+       "Configure session parameters\n"
+       "Configure session holdtime\n"
+       "Time (seconds)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "lsr_id", .value = argv[0] },
+      &(struct vty_arg) { .name = "seconds", .value = argv[1] },
+      NULL
+    };
+  return ldp_vty_session_holdtime (vty, args);
+}
+
+DEFUN (ldp_no_router_id_ipv4,
+       ldp_no_router_id_ipv4_cmd,
+       "no router-id A.B.C.D",
+       "Negate a command or set its defaults\n"
+       "Configure router Id\n"
+       "LSR Id (in form of an IPv4 address)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_router_id (vty, args);
+}
+
+DEFUN (ldp_discovery_targeted_hello_accept,
+       ldp_discovery_targeted_hello_accept_cmd,
+       "discovery targeted-hello accept",
+       "Configure discovery parameters\n"
+       "LDP Targeted Hellos\n"
+       "Accept and respond to targeted hellos\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "hello_type", .value = "targeted-hello" },
+      NULL
+    };
+  return ldp_vty_targeted_hello_accept (vty, args);
+}
+
+DEFUN (ldp_label_local_advertise_explicit_null,
+       ldp_label_local_advertise_explicit_null_cmd,
+       "label local advertise explicit-null",
+       "Configure label control and policies\n"
+       "Configure local label control and policies\n"
+       "Configure outbound label advertisement control\n"
+       "Configure explicit-null advertisement\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_explicit_null (vty, args);
+}
+
+DEFUN (ldp_session_holdtime_session_time,
+       ldp_session_holdtime_session_time_cmd,
+       "session holdtime <15-65535>",
+       "Configure session parameters\n"
+       "Configure session holdtime\n"
+       "Time (seconds)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "seconds", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_session_holdtime (vty, args);
+}
+
+DEFUN (ldp_interface_ifname,
+       ldp_interface_ifname_cmd,
+       "interface IFNAME",
+       "Enable LDP on an interface and enter interface submode\n"
+       "Interface's name\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "ifname", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_interface (vty, args);
+}
+
+DEFUN (ldp_discovery_transport_address_ipv4,
+       ldp_discovery_transport_address_ipv4_cmd,
+       "discovery transport-address A.B.C.D",
+       "Configure discovery parameters\n"
+       "Specify transport address for TCP connection\n"
+       "IP address to be used as transport address\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_trans_addr (vty, args);
+}
+
+DEFUN (ldp_neighbor_ipv4_targeted,
+       ldp_neighbor_ipv4_targeted_cmd,
+       "neighbor A.B.C.D targeted",
+       "Configure neighbor parameters\n"
+       "IP address of neighbor\n"
+       "Establish targeted session\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_neighbor_targeted (vty, args);
+}
+
+DEFUN (ldp_no_discovery_targeted_hello_accept,
+       ldp_no_discovery_targeted_hello_accept_cmd,
+       "no discovery targeted-hello accept",
+       "Negate a command or set its defaults\n"
+       "Configure discovery parameters\n"
+       "LDP Targeted Hellos\n"
+       "Accept and respond to targeted hellos\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "hello_type", .value = "targeted-hello" },
+      NULL
+    };
+  return ldp_vty_targeted_hello_accept (vty, args);
+}
+
+DEFUN (ldp_no_label_local_advertise_explicit_null,
+       ldp_no_label_local_advertise_explicit_null_cmd,
+       "no label local advertise explicit-null",
+       "Negate a command or set its defaults\n"
+       "Configure label control and policies\n"
+       "Configure local label control and policies\n"
+       "Configure outbound label advertisement control\n"
+       "Configure explicit-null advertisement\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      NULL
+    };
+  return ldp_vty_explicit_null (vty, args);
+}
+
+DEFUN (ldp_no_session_holdtime_session_time,
+       ldp_no_session_holdtime_session_time_cmd,
+       "no session holdtime <15-65535>",
+       "Negate a command or set its defaults\n"
+       "Configure session parameters\n"
+       "Configure session holdtime\n"
+       "Time (seconds)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "seconds", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_session_holdtime (vty, args);
+}
+
+DEFUN (ldp_no_interface_ifname,
+       ldp_no_interface_ifname_cmd,
+       "no interface IFNAME",
+       "Negate a command or set its defaults\n"
+       "Enable LDP on an interface and enter interface submode\n"
+       "Interface's name\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "ifname", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_interface (vty, args);
+}
+
+DEFUN (ldp_no_discovery_transport_address_ipv4,
+       ldp_no_discovery_transport_address_ipv4_cmd,
+       "no discovery transport-address A.B.C.D",
+       "Negate a command or set its defaults\n"
+       "Configure discovery parameters\n"
+       "Specify transport address for TCP connection\n"
+       "IP address to be used as transport address\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_trans_addr (vty, args);
+}
+
+DEFUN (ldp_no_neighbor_ipv4_targeted,
+       ldp_no_neighbor_ipv4_targeted_cmd,
+       "no neighbor A.B.C.D targeted",
+       "Negate a command or set its defaults\n"
+       "Configure neighbor parameters\n"
+       "IP address of neighbor\n"
+       "Establish targeted session\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_neighbor_targeted (vty, args);
+}
+
+DEFUN (ldp_discovery_transport_address_ipv6,
+       ldp_discovery_transport_address_ipv6_cmd,
+       "discovery transport-address X:X::X:X",
+       "Configure discovery parameters\n"
+       "Specify transport address for TCP connection\n"
+       "IPv6 address to be used as transport address\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_trans_addr (vty, args);
+}
+
+DEFUN (ldp_neighbor_ipv6_targeted,
+       ldp_neighbor_ipv6_targeted_cmd,
+       "neighbor X:X::X:X targeted",
+       "Configure neighbor parameters\n"
+       "IPv6 address of neighbor\n"
+       "Establish targeted session\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_neighbor_targeted (vty, args);
+}
+
+DEFUN (ldp_no_discovery_transport_address_ipv6,
+       ldp_no_discovery_transport_address_ipv6_cmd,
+       "no discovery transport-address X:X::X:X",
+       "Negate a command or set its defaults\n"
+       "Configure discovery parameters\n"
+       "Specify transport address for TCP connection\n"
+       "IPv6 address to be used as transport address\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_trans_addr (vty, args);
+}
+
+DEFUN (ldp_no_neighbor_ipv6_targeted,
+       ldp_no_neighbor_ipv6_targeted_cmd,
+       "no neighbor X:X::X:X targeted",
+       "Negate a command or set its defaults\n"
+       "Configure neighbor parameters\n"
+       "IPv6 address of neighbor\n"
+       "Establish targeted session\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_neighbor_targeted (vty, args);
+}
+
+DEFUN (ldp_bridge_ifname,
+       ldp_bridge_ifname_cmd,
+       "bridge IFNAME",
+       "Bridge interface\n"
+       "Interface's name\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "ifname", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_bridge (vty, args);
+}
+
+DEFUN (ldp_mtu_mtu,
+       ldp_mtu_mtu_cmd,
+       "mtu <1500-9180>",
+       "set Maximum Transmission Unit\n"
+       "Maximum Transmission Unit value\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "mtu", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_mtu (vty, args);
+}
+
+DEFUN (ldp_member_interface_ifname,
+       ldp_member_interface_ifname_cmd,
+       "member interface IFNAME",
+       "L2VPN member configuration\n"
+       "Local interface\n"
+       "Interface's name\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "ifname", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_interface (vty, args);
+}
+
+DEFUN (ldp_member_pseudowire_ifname,
+       ldp_member_pseudowire_ifname_cmd,
+       "member pseudowire IFNAME",
+       "L2VPN member configuration\n"
+       "Pseudowire interface\n"
+       "Interface's name\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "ifname", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pseudowire (vty, args);
+}
+
+DEFUN (ldp_vc_type_pwtype,
+       ldp_vc_type_pwtype_cmd,
+       "vc type (ethernet|ethernet-tagged)",
+       "Virtual Circuit options\n"
+       "Virtual Circuit type to use\n"
+       "Ethernet (type 5)\n"
+       "Ethernet-tagged (type 4)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "type", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pwtype (vty, args);
+}
+
+DEFUN (ldp_no_bridge_ifname,
+       ldp_no_bridge_ifname_cmd,
+       "no bridge IFNAME",
+       "Negate a command or set its defaults\n"
+       "Bridge interface\n"
+       "Interface's name\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "ifname", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_bridge (vty, args);
+}
+
+DEFUN (ldp_no_mtu_mtu,
+       ldp_no_mtu_mtu_cmd,
+       "no mtu <1500-9180>",
+       "Negate a command or set its defaults\n"
+       "set Maximum Transmission Unit\n"
+       "Maximum Transmission Unit value\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "mtu", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_mtu (vty, args);
+}
+
+DEFUN (ldp_no_member_interface_ifname,
+       ldp_no_member_interface_ifname_cmd,
+       "no member interface IFNAME",
+       "Negate a command or set its defaults\n"
+       "L2VPN member configuration\n"
+       "Local interface\n"
+       "Interface's name\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "ifname", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_interface (vty, args);
+}
+
+DEFUN (ldp_no_member_pseudowire_ifname,
+       ldp_no_member_pseudowire_ifname_cmd,
+       "no member pseudowire IFNAME",
+       "Negate a command or set its defaults\n"
+       "L2VPN member configuration\n"
+       "Pseudowire interface\n"
+       "Interface's name\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "ifname", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pseudowire (vty, args);
+}
+
+DEFUN (ldp_no_vc_type_pwtype,
+       ldp_no_vc_type_pwtype_cmd,
+       "no vc type (ethernet|ethernet-tagged)",
+       "Negate a command or set its defaults\n"
+       "Virtual Circuit options\n"
+       "Virtual Circuit type to use\n"
+       "Ethernet (type 5)\n"
+       "Ethernet-tagged (type 4)\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "type", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pwtype (vty, args);
+}
+
+DEFUN (ldp_control_word_cword,
+       ldp_control_word_cword_cmd,
+       "control-word (exclude|include)",
+       "Control-word options\n"
+       "Exclude control-word in pseudowire packets\n"
+       "Include control-word in pseudowire packets\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "preference", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pw_cword (vty, args);
+}
+
+DEFUN (ldp_neighbor_address_addr,
+       ldp_neighbor_address_addr_cmd,
+       "neighbor address (A.B.C.D|X:X::X:X)",
+       "Remote endpoint configuration\n"
+       "Specify the IPv4 or IPv6 address of the remote endpoint\n"
+       "IPv4 address\n"
+       "IPv6 address\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pw_nbr_addr (vty, args);
+}
+
+DEFUN (ldp_neighbor_lsr_id_ipv4,
+       ldp_neighbor_lsr_id_ipv4_cmd,
+       "neighbor lsr-id A.B.C.D",
+       "Remote endpoint configuration\n"
+       "Specify the LSR-ID of the remote endpoint\n"
+       "IPv4 address\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "lsr-id", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pw_nbr_id (vty, args);
+}
+
+DEFUN (ldp_pw_id_pwid,
+       ldp_pw_id_pwid_cmd,
+       "pw-id <1-4294967295>",
+       "Set the Virtual Circuit ID\n"
+       "Virtual Circuit ID value\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "pwid", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pw_pwid (vty, args);
+}
+
+DEFUN (ldp_pw_status_disable,
+       ldp_pw_status_disable_cmd,
+       "pw-status disable",
+       "Configure PW status\n"
+       "Disable PW status\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_l2vpn_pw_pwstatus (vty, args);
+}
+
+DEFUN (ldp_no_control_word_cword,
+       ldp_no_control_word_cword_cmd,
+       "no control-word (exclude|include)",
+       "Negate a command or set its defaults\n"
+       "Control-word options\n"
+       "Exclude control-word in pseudowire packets\n"
+       "Include control-word in pseudowire packets\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "preference", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pw_cword (vty, args);
+}
+
+DEFUN (ldp_no_neighbor_address_addr,
+       ldp_no_neighbor_address_addr_cmd,
+       "no neighbor address (A.B.C.D|X:X::X:X)",
+       "Negate a command or set its defaults\n"
+       "Remote endpoint configuration\n"
+       "Specify the IPv4 or IPv6 address of the remote endpoint\n"
+       "IPv4 address\n"
+       "IPv6 address\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pw_nbr_addr (vty, args);
+}
+
+DEFUN (ldp_no_neighbor_lsr_id_ipv4,
+       ldp_no_neighbor_lsr_id_ipv4_cmd,
+       "no neighbor lsr-id A.B.C.D",
+       "Negate a command or set its defaults\n"
+       "Remote endpoint configuration\n"
+       "Specify the LSR-ID of the remote endpoint\n"
+       "IPv4 address\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "lsr-id", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pw_nbr_id (vty, args);
+}
+
+DEFUN (ldp_no_pw_id_pwid,
+       ldp_no_pw_id_pwid_cmd,
+       "no pw-id <1-4294967295>",
+       "Negate a command or set its defaults\n"
+       "Set the Virtual Circuit ID\n"
+       "Virtual Circuit ID value\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      &(struct vty_arg) { .name = "pwid", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_l2vpn_pw_pwid (vty, args);
+}
+
+DEFUN (ldp_no_pw_status_disable,
+       ldp_no_pw_status_disable_cmd,
+       "no pw-status disable",
+       "Negate a command or set its defaults\n"
+       "Configure PW status\n"
+       "Disable PW status\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "no", .value = "no" },
+      NULL
+    };
+  return ldp_vty_l2vpn_pw_pwstatus (vty, args);
+}
+
+DEFUN (ldp_show_mpls_ldp_neighbor,
+       ldp_show_mpls_ldp_neighbor_cmd,
+       "show mpls ldp neighbor",
+       "Show running system information\n"
+       "MPLS information\n"
+       "Label Distribution Protocol\n"
+       "Neighbor information\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_show_neighbor (vty, args);
+}
+
+DEFUN (ldp_show_mpls_ldp_binding,
+       ldp_show_mpls_ldp_binding_cmd,
+       "show mpls ldp binding",
+       "Show running system information\n"
+       "MPLS information\n"
+       "Label Distribution Protocol\n"
+       "Label Information Base (LIB) information\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_show_binding (vty, args);
+}
+
+DEFUN (ldp_show_mpls_ldp_discovery,
+       ldp_show_mpls_ldp_discovery_cmd,
+       "show mpls ldp discovery",
+       "Show running system information\n"
+       "MPLS information\n"
+       "Label Distribution Protocol\n"
+       "Discovery Hello Information\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_show_discovery (vty, args);
+}
+
+DEFUN (ldp_show_mpls_ldp_interface,
+       ldp_show_mpls_ldp_interface_cmd,
+       "show mpls ldp interface",
+       "Show running system information\n"
+       "MPLS information\n"
+       "Label Distribution Protocol\n"
+       "interface information\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_show_interface (vty, args);
+}
+
+DEFUN (ldp_show_mpls_ldp_address_family_binding,
+       ldp_show_mpls_ldp_address_family_binding_cmd,
+       "show mpls ldp (ipv4|ipv6) binding",
+       "Show running system information\n"
+       "MPLS information\n"
+       "Label Distribution Protocol\n"
+       "IPv4 Address Family\n"
+       "IPv6 Address Family\n"
+       "Label Information Base (LIB) information\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "address-family", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_show_binding (vty, args);
+}
+
+DEFUN (ldp_show_mpls_ldp_address_family_discovery,
+       ldp_show_mpls_ldp_address_family_discovery_cmd,
+       "show mpls ldp (ipv4|ipv6) discovery",
+       "Show running system information\n"
+       "MPLS information\n"
+       "Label Distribution Protocol\n"
+       "IPv4 Address Family\n"
+       "IPv6 Address Family\n"
+       "Discovery Hello Information\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "address-family", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_show_discovery (vty, args);
+}
+
+DEFUN (ldp_show_mpls_ldp_address_family_interface,
+       ldp_show_mpls_ldp_address_family_interface_cmd,
+       "show mpls ldp (ipv4|ipv6) interface",
+       "Show running system information\n"
+       "MPLS information\n"
+       "Label Distribution Protocol\n"
+       "IPv4 Address Family\n"
+       "IPv6 Address Family\n"
+       "interface information\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "address-family", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_show_interface (vty, args);
+}
+
+DEFUN (ldp_show_l2vpn_atom_binding,
+       ldp_show_l2vpn_atom_binding_cmd,
+       "show l2vpn atom binding",
+       "Show running system information\n"
+       "Show information about Layer2 VPN\n"
+       "Show Any Transport over MPLS information\n"
+       "Show AToM label binding information\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_show_atom_binding (vty, args);
+}
+
+DEFUN (ldp_show_l2vpn_atom_vc,
+       ldp_show_l2vpn_atom_vc_cmd,
+       "show l2vpn atom vc",
+       "Show running system information\n"
+       "Show information about Layer2 VPN\n"
+       "Show Any Transport over MPLS information\n"
+       "Show AToM virtual circuit information\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_show_atom_vc (vty, args);
+}
+
+DEFUN (ldp_clear_mpls_ldp_neighbor,
+       ldp_clear_mpls_ldp_neighbor_cmd,
+       "clear mpls ldp neighbor",
+       "Reset functions\n"
+       "Reset MPLS statistical information\n"
+       "Clear LDP state\n"
+       "Clear LDP neighbor sessions\n")
+{
+  struct vty_arg *args[] = { NULL };
+  return ldp_vty_clear_nbr (vty, args);
+}
+
+DEFUN (ldp_clear_mpls_ldp_neighbor_addr,
+       ldp_clear_mpls_ldp_neighbor_addr_cmd,
+       "clear mpls ldp neighbor (A.B.C.D|X:X::X:X)",
+       "Reset functions\n"
+       "Reset MPLS statistical information\n"
+       "Clear LDP state\n"
+       "Clear LDP neighbor sessions\n"
+       "IPv4 address\n"
+       "IPv6 address\n")
+{
+  struct vty_arg *args[] =
+    {
+      &(struct vty_arg) { .name = "addr", .value = argv[0] },
+      NULL
+    };
+  return ldp_vty_clear_nbr (vty, args);
+}
+
+void
+ldp_vty_init (void)
+{
+  install_element (CONFIG_NODE, &ldp_mpls_ldp_cmd);
+  install_element (CONFIG_NODE, &ldp_l2vpn_word_type_vpls_cmd);
+  install_element (CONFIG_NODE, &ldp_no_mpls_ldp_cmd);
+  install_element (CONFIG_NODE, &ldp_no_l2vpn_word_type_vpls_cmd);
+  install_node (&ldp_node, ldp_config_write);
+  install_default (LDP_NODE);
+  install_element (LDP_NODE, &ldp_address_family_ipv4_cmd);
+  install_element (LDP_NODE, &ldp_address_family_ipv6_cmd);
+  install_element (LDP_NODE, &ldp_discovery_hello_holdtime_disc_time_cmd);
+  install_element (LDP_NODE, &ldp_discovery_hello_interval_disc_time_cmd);
+  install_element (LDP_NODE, &ldp_discovery_targeted_hello_holdtime_disc_time_cmd);
+  install_element (LDP_NODE, &ldp_discovery_targeted_hello_interval_disc_time_cmd);
+  install_element (LDP_NODE, &ldp_dual_stack_transport_connection_prefer_ipv4_cmd);
+  install_element (LDP_NODE, &ldp_dual_stack_cisco_interop_cmd);
+  install_element (LDP_NODE, &ldp_neighbor_ipv4_password_word_cmd);
+  install_element (LDP_NODE, &ldp_neighbor_ipv4_session_holdtime_session_time_cmd);
+  install_element (LDP_NODE, &ldp_router_id_ipv4_cmd);
+  install_element (LDP_NODE, &ldp_no_address_family_ipv4_cmd);
+  install_element (LDP_NODE, &ldp_no_address_family_ipv6_cmd);
+  install_element (LDP_NODE, &ldp_no_discovery_hello_holdtime_disc_time_cmd);
+  install_element (LDP_NODE, &ldp_no_discovery_hello_interval_disc_time_cmd);
+  install_element (LDP_NODE, &ldp_no_discovery_targeted_hello_holdtime_disc_time_cmd);
+  install_element (LDP_NODE, &ldp_no_discovery_targeted_hello_interval_disc_time_cmd);
+  install_element (LDP_NODE, &ldp_no_dual_stack_transport_connection_prefer_ipv4_cmd);
+  install_element (LDP_NODE, &ldp_no_dual_stack_cisco_interop_cmd);
+  install_element (LDP_NODE, &ldp_no_neighbor_ipv4_password_word_cmd);
+  install_element (LDP_NODE, &ldp_no_neighbor_ipv4_session_holdtime_session_time_cmd);
+  install_element (LDP_NODE, &ldp_no_router_id_ipv4_cmd);
+  install_node (&ldp_ipv4_node, NULL);
+  install_default (LDP_IPV4_NODE);
+  install_element (LDP_IPV4_NODE, &ldp_discovery_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_discovery_hello_interval_disc_time_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_discovery_targeted_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_discovery_targeted_hello_interval_disc_time_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_discovery_targeted_hello_accept_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_label_local_advertise_explicit_null_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_session_holdtime_session_time_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_interface_ifname_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_discovery_transport_address_ipv4_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_neighbor_ipv4_targeted_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_no_discovery_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_no_discovery_hello_interval_disc_time_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_no_discovery_targeted_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_no_discovery_targeted_hello_interval_disc_time_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_no_discovery_targeted_hello_accept_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_no_label_local_advertise_explicit_null_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_no_session_holdtime_session_time_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_no_interface_ifname_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_no_discovery_transport_address_ipv4_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_no_neighbor_ipv4_targeted_cmd);
+  install_node (&ldp_ipv6_node, NULL);
+  install_default (LDP_IPV6_NODE);
+  install_element (LDP_IPV6_NODE, &ldp_discovery_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_discovery_hello_interval_disc_time_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_discovery_targeted_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_discovery_targeted_hello_interval_disc_time_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_discovery_targeted_hello_accept_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_label_local_advertise_explicit_null_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_session_holdtime_session_time_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_interface_ifname_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_discovery_transport_address_ipv6_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_neighbor_ipv6_targeted_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_no_discovery_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_no_discovery_hello_interval_disc_time_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_no_discovery_targeted_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_no_discovery_targeted_hello_interval_disc_time_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_no_discovery_targeted_hello_accept_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_no_label_local_advertise_explicit_null_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_no_session_holdtime_session_time_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_no_interface_ifname_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_no_discovery_transport_address_ipv6_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_no_neighbor_ipv6_targeted_cmd);
+  install_node (&ldp_ipv4_iface_node, NULL);
+  install_default (LDP_IPV4_IFACE_NODE);
+  install_element (LDP_IPV4_IFACE_NODE, &ldp_discovery_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV4_IFACE_NODE, &ldp_discovery_hello_interval_disc_time_cmd);
+  install_element (LDP_IPV4_IFACE_NODE, &ldp_no_discovery_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV4_IFACE_NODE, &ldp_no_discovery_hello_interval_disc_time_cmd);
+  install_node (&ldp_ipv6_iface_node, NULL);
+  install_default (LDP_IPV6_IFACE_NODE);
+  install_element (LDP_IPV6_IFACE_NODE, &ldp_discovery_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV6_IFACE_NODE, &ldp_discovery_hello_interval_disc_time_cmd);
+  install_element (LDP_IPV6_IFACE_NODE, &ldp_no_discovery_hello_holdtime_disc_time_cmd);
+  install_element (LDP_IPV6_IFACE_NODE, &ldp_no_discovery_hello_interval_disc_time_cmd);
+  install_node (&ldp_l2vpn_node, ldp_l2vpn_config_write);
+  install_default (LDP_L2VPN_NODE);
+  install_element (LDP_L2VPN_NODE, &ldp_bridge_ifname_cmd);
+  install_element (LDP_L2VPN_NODE, &ldp_mtu_mtu_cmd);
+  install_element (LDP_L2VPN_NODE, &ldp_member_interface_ifname_cmd);
+  install_element (LDP_L2VPN_NODE, &ldp_member_pseudowire_ifname_cmd);
+  install_element (LDP_L2VPN_NODE, &ldp_vc_type_pwtype_cmd);
+  install_element (LDP_L2VPN_NODE, &ldp_no_bridge_ifname_cmd);
+  install_element (LDP_L2VPN_NODE, &ldp_no_mtu_mtu_cmd);
+  install_element (LDP_L2VPN_NODE, &ldp_no_member_interface_ifname_cmd);
+  install_element (LDP_L2VPN_NODE, &ldp_no_member_pseudowire_ifname_cmd);
+  install_element (LDP_L2VPN_NODE, &ldp_no_vc_type_pwtype_cmd);
+  install_node (&ldp_pseudowire_node, NULL);
+  install_default (LDP_PSEUDOWIRE_NODE);
+  install_element (LDP_PSEUDOWIRE_NODE, &ldp_control_word_cword_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &ldp_neighbor_address_addr_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &ldp_neighbor_lsr_id_ipv4_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &ldp_pw_id_pwid_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &ldp_pw_status_disable_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &ldp_no_control_word_cword_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &ldp_no_neighbor_address_addr_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &ldp_no_neighbor_lsr_id_ipv4_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &ldp_no_pw_id_pwid_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &ldp_no_pw_status_disable_cmd);
+  install_element (ENABLE_NODE, &ldp_show_mpls_ldp_neighbor_cmd);
+  install_element (ENABLE_NODE, &ldp_show_mpls_ldp_binding_cmd);
+  install_element (ENABLE_NODE, &ldp_show_mpls_ldp_discovery_cmd);
+  install_element (ENABLE_NODE, &ldp_show_mpls_ldp_interface_cmd);
+  install_element (ENABLE_NODE, &ldp_show_mpls_ldp_address_family_binding_cmd);
+  install_element (ENABLE_NODE, &ldp_show_mpls_ldp_address_family_discovery_cmd);
+  install_element (ENABLE_NODE, &ldp_show_mpls_ldp_address_family_interface_cmd);
+  install_element (ENABLE_NODE, &ldp_show_l2vpn_atom_binding_cmd);
+  install_element (ENABLE_NODE, &ldp_show_l2vpn_atom_vc_cmd);
+  install_element (ENABLE_NODE, &ldp_clear_mpls_ldp_neighbor_cmd);
+  install_element (ENABLE_NODE, &ldp_clear_mpls_ldp_neighbor_addr_cmd);
+  install_element (VIEW_NODE, &ldp_show_mpls_ldp_neighbor_cmd);
+  install_element (VIEW_NODE, &ldp_show_mpls_ldp_binding_cmd);
+  install_element (VIEW_NODE, &ldp_show_mpls_ldp_discovery_cmd);
+  install_element (VIEW_NODE, &ldp_show_mpls_ldp_interface_cmd);
+  install_element (VIEW_NODE, &ldp_show_mpls_ldp_address_family_binding_cmd);
+  install_element (VIEW_NODE, &ldp_show_mpls_ldp_address_family_discovery_cmd);
+  install_element (VIEW_NODE, &ldp_show_mpls_ldp_address_family_interface_cmd);
+  install_element (VIEW_NODE, &ldp_show_l2vpn_atom_binding_cmd);
+  install_element (VIEW_NODE, &ldp_show_l2vpn_atom_vc_cmd);
+  install_element (VIEW_NODE, &ldp_clear_mpls_ldp_neighbor_cmd);
+  install_element (VIEW_NODE, &ldp_clear_mpls_ldp_neighbor_addr_cmd);
+}
\ No newline at end of file
diff --git a/ldpd/ldp_vty_conf.c b/ldpd/ldp_vty_conf.c
new file mode 100644
index 0000000..f7fe164
--- /dev/null
+++ b/ldpd/ldp_vty_conf.c
@@ -0,0 +1,1545 @@
+/*
+ * Copyright (C) 2016 by Open Source Routing.
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "lde.h"
+#include "log.h"
+
+#include "command.h"
+#include "if.h"
+#include "vty.h"
+#include "ldp_vty.h"
+
+static int	 interface_config_write(struct vty *);
+static void	 ldp_af_iface_config_write(struct vty *, int);
+static void	 ldp_af_config_write(struct vty *, int, struct ldpd_conf *,
+		    struct ldpd_af_conf *);
+static void	 ldp_l2vpn_pw_config_write(struct vty *, struct l2vpn_pw *);
+static int	 ldp_vty_get_af(struct vty *);
+static int	 ldp_iface_is_configured(struct ldpd_conf *, const char *);
+static int	 ldp_vty_nbr_session_holdtime(struct vty *, struct vty_arg *[]);
+static int	 ldp_vty_af_session_holdtime(struct vty *, struct vty_arg *[]);
+
+static char	 vty_ifname[IF_NAMESIZE];
+static char	 vty_l2vpn_name[L2VPN_NAME_LEN];
+static char	 vty_pw_ifname[IF_NAMESIZE];
+
+static struct cmd_node interface_node =
+{
+	INTERFACE_NODE,
+	"%s(config-if)# ",
+	1
+};
+
+struct cmd_node ldp_node =
+{
+	LDP_NODE,
+	"%s(config-ldp)# ",
+	1,
+};
+
+struct cmd_node ldp_ipv4_node =
+{
+	LDP_IPV4_NODE,
+	"%s(config-ldp-af)# ",
+	1,
+};
+
+struct cmd_node ldp_ipv6_node =
+{
+	LDP_IPV6_NODE,
+	"%s(config-ldp-af)# ",
+	1,
+};
+
+struct cmd_node ldp_ipv4_iface_node =
+{
+	LDP_IPV4_IFACE_NODE,
+	"%s(config-ldp-af-if)# ",
+	1,
+};
+
+struct cmd_node ldp_ipv6_iface_node =
+{
+	LDP_IPV6_IFACE_NODE,
+	"%s(config-ldp-af-if)# ",
+	1,
+};
+
+struct cmd_node ldp_l2vpn_node =
+{
+	LDP_L2VPN_NODE,
+	"%s(config-l2vpn)# ",
+	1,
+};
+
+struct cmd_node ldp_pseudowire_node =
+{
+	LDP_PSEUDOWIRE_NODE,
+	"%s(config-l2vpn-pw)# ",
+	1,
+};
+
+int
+ldp_get_address(const char *str, int *af, union ldpd_addr *addr)
+{
+	memset(addr, 0, sizeof(*addr));
+
+	if (inet_pton(AF_INET, str, &addr->v4) == 1) {
+		*af = AF_INET;
+		return (0);
+	}
+
+	if (inet_pton(AF_INET6, str, &addr->v6) == 1) {
+		*af = AF_INET6;
+		return (0);
+	}
+
+	return (-1);
+}
+
+static int
+interface_config_write(struct vty *vty)
+{
+	struct listnode		*node;
+	struct interface	*ifp;
+	int			 write = 0;
+
+	for (ALL_LIST_ELEMENTS_RO(iflist, node, ifp)) {
+		vty_out(vty, "!%s", VTY_NEWLINE);
+		vty_out(vty, "interface %s%s", ifp->name, VTY_NEWLINE);
+		if (ifp->desc)
+			vty_out(vty, " description %s%s", ifp->desc,
+			    VTY_NEWLINE);
+
+		write++;
+	}
+
+	return (write);
+}
+
+static void
+ldp_af_iface_config_write(struct vty *vty, int af)
+{
+	struct iface		*iface;
+	struct iface_af		*ia;
+
+	LIST_FOREACH(iface, &ldpd_conf->iface_list, entry) {
+		ia = iface_af_get(iface, af);
+		if (!ia->enabled)
+			continue;
+
+		vty_out(vty, "  !%s", VTY_NEWLINE);
+		vty_out(vty, "  interface %s%s", iface->name, VTY_NEWLINE);
+
+		if (ia->hello_holdtime != LINK_DFLT_HOLDTIME &&
+		    ia->hello_holdtime != 0)
+			vty_out(vty, "   discovery hello holdtime %u%s",
+			    ia->hello_holdtime, VTY_NEWLINE);
+		if (ia->hello_interval != DEFAULT_HELLO_INTERVAL &&
+		    ia->hello_interval != 0)
+			vty_out(vty, "   discovery hello interval %u%s",
+			    ia->hello_interval, VTY_NEWLINE);
+	}
+}
+
+static void
+ldp_af_config_write(struct vty *vty, int af, struct ldpd_conf *conf,
+    struct ldpd_af_conf *af_conf)
+{
+	struct tnbr		*tnbr;
+
+	if (!(af_conf->flags & F_LDPD_AF_ENABLED))
+		return;
+
+	vty_out(vty, " !%s", VTY_NEWLINE);
+	vty_out(vty, " address-family %s%s", af_name(af), VTY_NEWLINE);
+
+	if (af_conf->lhello_holdtime != LINK_DFLT_HOLDTIME &&
+	    af_conf->lhello_holdtime != 0 )
+		vty_out(vty, "  discovery hello holdtime %u%s",
+		    af_conf->lhello_holdtime, VTY_NEWLINE);
+	if (af_conf->lhello_interval != DEFAULT_HELLO_INTERVAL &&
+	    af_conf->lhello_interval != 0)
+		vty_out(vty, "  discovery hello interval %u%s",
+		    af_conf->lhello_interval, VTY_NEWLINE);
+
+	if (af_conf->flags & F_LDPD_AF_THELLO_ACCEPT)
+		vty_out(vty, "  discovery targeted-hello accept%s",
+		    VTY_NEWLINE);
+
+	if (af_conf->thello_holdtime != TARGETED_DFLT_HOLDTIME &&
+	    af_conf->thello_holdtime != 0)
+		vty_out(vty, "  discovery targeted-hello holdtime %u%s",
+		    af_conf->thello_holdtime, VTY_NEWLINE);
+	if (af_conf->thello_interval != DEFAULT_HELLO_INTERVAL &&
+	    af_conf->thello_interval != 0)
+		vty_out(vty, "  discovery targeted-hello interval %u%s",
+		    af_conf->thello_interval, VTY_NEWLINE);
+
+	if (ldp_addrisset(af, &af_conf->trans_addr))
+		vty_out(vty, "  discovery transport-address %s%s",
+		    log_addr(af, &af_conf->trans_addr), VTY_NEWLINE);
+	else
+		vty_out(vty, "  ! Incomplete config, specify a discovery "
+		    "transport-address%s", VTY_NEWLINE);
+
+	if (af_conf->flags & F_LDPD_AF_EXPNULL)
+		vty_out(vty, "  label local advertise explicit-null%s",
+		    VTY_NEWLINE);
+
+	if (af_conf->keepalive != DEFAULT_KEEPALIVE)
+		vty_out(vty, "  session holdtime %u%s", af_conf->keepalive,
+		    VTY_NEWLINE);
+
+	LIST_FOREACH(tnbr, &ldpd_conf->tnbr_list, entry) {
+		if (tnbr->af == af && (tnbr->flags & F_TNBR_CONFIGURED)) {
+			vty_out(vty, "  !%s", VTY_NEWLINE);
+			vty_out(vty, "  neighbor %s targeted%s",
+			    log_addr(tnbr->af, &tnbr->addr), VTY_NEWLINE);
+		}
+	}
+
+	ldp_af_iface_config_write(vty, af);
+
+	vty_out(vty, "  !%s", VTY_NEWLINE);
+}
+
+int
+ldp_config_write(struct vty *vty)
+{
+	struct nbr_params	*nbrp;
+
+	if (!(ldpd_conf->flags & F_LDPD_ENABLED))
+		return (0);
+
+	vty_out(vty, "mpls ldp%s", VTY_NEWLINE);
+
+	if (ldpd_conf->rtr_id.s_addr != 0)
+		vty_out(vty, " router-id %s%s",
+		    inet_ntoa(ldpd_conf->rtr_id), VTY_NEWLINE);
+
+	if (ldpd_conf->lhello_holdtime != LINK_DFLT_HOLDTIME &&
+	    ldpd_conf->lhello_holdtime != 0)
+		vty_out(vty, " discovery hello holdtime %u%s",
+		    ldpd_conf->lhello_holdtime, VTY_NEWLINE);
+	if (ldpd_conf->lhello_interval != DEFAULT_HELLO_INTERVAL &&
+	    ldpd_conf->lhello_interval != 0)
+		vty_out(vty, " discovery hello interval %u%s",
+		    ldpd_conf->lhello_interval, VTY_NEWLINE);
+
+	if (ldpd_conf->thello_holdtime != TARGETED_DFLT_HOLDTIME &&
+	    ldpd_conf->thello_holdtime != 0)
+		vty_out(vty, " discovery targeted-hello holdtime %u%s",
+		    ldpd_conf->thello_holdtime, VTY_NEWLINE);
+	if (ldpd_conf->thello_interval != DEFAULT_HELLO_INTERVAL &&
+	    ldpd_conf->thello_interval != 0)
+		vty_out(vty, " discovery targeted-hello interval %u%s",
+		    ldpd_conf->thello_interval, VTY_NEWLINE);
+
+	if (ldpd_conf->trans_pref == DUAL_STACK_LDPOV4)
+		vty_out(vty, " dual-stack transport-connection prefer ipv4%s",
+		    VTY_NEWLINE);
+
+	if (ldpd_conf->flags & F_LDPD_DS_CISCO_INTEROP)
+		vty_out(vty, " dual-stack cisco-interop%s", VTY_NEWLINE);
+
+	LIST_FOREACH(nbrp, &ldpd_conf->nbrp_list, entry) {
+		if (nbrp->flags & F_NBRP_KEEPALIVE)
+			vty_out(vty, " neighbor %s keepalive %u%s",
+			    inet_ntoa(nbrp->lsr_id), nbrp->keepalive,
+			    VTY_NEWLINE);
+
+		if (nbrp->auth.method == AUTH_MD5SIG)
+			vty_out(vty, " neighbor %s password %s%s",
+			    inet_ntoa(nbrp->lsr_id), nbrp->auth.md5key,
+			    VTY_NEWLINE);
+	}
+
+	ldp_af_config_write(vty, AF_INET, ldpd_conf, &ldpd_conf->ipv4);
+	ldp_af_config_write(vty, AF_INET6, ldpd_conf, &ldpd_conf->ipv6);
+	vty_out(vty, " !%s", VTY_NEWLINE);
+	vty_out(vty, "!%s", VTY_NEWLINE);
+
+	return (1);
+}
+
+static void
+ldp_l2vpn_pw_config_write(struct vty *vty, struct l2vpn_pw *pw)
+{
+	int	 missing_lsrid = 0;
+	int	 missing_pwid = 0;
+
+	vty_out(vty, " !%s", VTY_NEWLINE);
+	vty_out(vty, " member pseudowire %s%s", pw->ifname, VTY_NEWLINE);
+
+	if (pw->lsr_id.s_addr != INADDR_ANY)
+		vty_out(vty, "  neighbor lsr-id %s%s", inet_ntoa(pw->lsr_id),
+		    VTY_NEWLINE);
+	else
+		missing_lsrid = 1;
+
+	if (pw->flags & F_PW_STATIC_NBR_ADDR)
+		vty_out(vty, "  neighbor address %s%s", log_addr(pw->af,
+		    &pw->addr), VTY_NEWLINE);
+
+	if (pw->pwid != 0)
+		vty_out(vty, "  pw-id %u%s", pw->pwid, VTY_NEWLINE);
+	else
+		missing_pwid = 1;
+
+	if (!(pw->flags & F_PW_CWORD_CONF))
+		vty_out(vty, "  control-word exclude%s", VTY_NEWLINE);
+
+	if (!(pw->flags & F_PW_STATUSTLV_CONF))
+		vty_out(vty, "  pw-status disable%s", VTY_NEWLINE);
+
+	if (missing_lsrid)
+		vty_out(vty, "  ! Incomplete config, specify a neighbor "
+		    "lsr-id%s", VTY_NEWLINE);
+	if (missing_pwid)
+		vty_out(vty, "  ! Incomplete config, specify a pw-id%s",
+		    VTY_NEWLINE);
+}
+
+int
+ldp_l2vpn_config_write(struct vty *vty)
+{
+	struct l2vpn		*l2vpn;
+	struct l2vpn_if		*lif;
+	struct l2vpn_pw		*pw;
+
+	LIST_FOREACH(l2vpn, &ldpd_conf->l2vpn_list, entry) {
+		vty_out(vty, "l2vpn %s type vpls%s", l2vpn->name, VTY_NEWLINE);
+
+		if (l2vpn->pw_type != DEFAULT_PW_TYPE)
+			vty_out(vty, " vc type ethernet-tagged%s", VTY_NEWLINE);
+
+		if (l2vpn->mtu != DEFAULT_L2VPN_MTU)
+			vty_out(vty, " mtu %u%s", l2vpn->mtu, VTY_NEWLINE);
+
+		if (l2vpn->br_ifname[0] != '\0')
+			vty_out(vty, " bridge %s%s", l2vpn->br_ifname,
+			    VTY_NEWLINE);
+
+		LIST_FOREACH(lif, &l2vpn->if_list, entry)
+			vty_out(vty, " member interface %s%s", lif->ifname,
+			    VTY_NEWLINE);
+
+		LIST_FOREACH(pw, &l2vpn->pw_list, entry)
+			ldp_l2vpn_pw_config_write(vty, pw);
+		LIST_FOREACH(pw, &l2vpn->pw_inactive_list, entry)
+			ldp_l2vpn_pw_config_write(vty, pw);
+
+		vty_out(vty, " !%s", VTY_NEWLINE);
+		vty_out(vty, "!%s", VTY_NEWLINE);
+	}
+
+	return (0);
+}
+
+static int
+ldp_vty_get_af(struct vty *vty)
+{
+	switch (vty->node) {
+	case LDP_IPV4_NODE:
+	case LDP_IPV4_IFACE_NODE:
+		return (AF_INET);
+	case LDP_IPV6_NODE:
+	case LDP_IPV6_IFACE_NODE:
+		return (AF_INET6);
+	default:
+		fatalx("ldp_vty_get_af: unexpected node");
+	}
+}
+
+static int
+ldp_iface_is_configured(struct ldpd_conf *xconf, const char *ifname)
+{
+	struct l2vpn	*l2vpn;
+
+	if (if_lookup_name(xconf, ifname))
+		return (1);
+
+	LIST_FOREACH(l2vpn, &xconf->l2vpn_list, entry) {
+		if (l2vpn_if_find_name(l2vpn, ifname))
+			return (1);
+		if (l2vpn_pw_find_name(l2vpn, ifname))
+			return (1);
+	}
+
+	return (0);
+}
+
+int
+ldp_vty_mpls_ldp(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	int			 disable;
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+
+	if (disable)
+		ldp_reset_main_conf(vty_conf);
+	else {
+		vty->node = LDP_NODE;
+		vty_conf->flags |= F_LDPD_ENABLED;
+	}
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_address_family(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct ldpd_af_conf	*af_conf;
+	int			 af;
+ 	const char		*af_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	af_str = vty_get_arg_value(args, "address-family");
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	if (strcmp(af_str, "ipv4") == 0) {
+		af = AF_INET;
+		af_conf = &vty_conf->ipv4;
+	} else if (strcmp(af_str, "ipv6") == 0) {
+		af = AF_INET6;
+		af_conf = &vty_conf->ipv6;
+	} else
+		return (CMD_WARNING);
+
+	if (disable) {
+		ldp_reset_af_conf(vty_conf, af);
+		ldp_reload(vty_conf);
+		return (CMD_SUCCESS);
+	}
+
+	switch (af) {
+	case AF_INET:
+		vty->node = LDP_IPV4_NODE;
+		break;
+	case AF_INET6:
+		vty->node = LDP_IPV6_NODE;
+		break;
+	default:
+		fatalx("ldp_vty_address_family: unknown af");
+	}
+	af_conf->flags |= F_LDPD_AF_ENABLED;
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_disc_holdtime(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct ldpd_af_conf	*af_conf;
+	struct iface		*iface;
+	struct iface_af		*ia;
+	int			 af;
+	char			*ep;
+	long int		 secs;
+	enum hello_type		 hello_type;
+	const char		*seconds_str;
+	const char		*hello_type_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	seconds_str = vty_get_arg_value(args, "seconds");
+	hello_type_str = vty_get_arg_value(args, "hello_type");
+
+	secs = strtol(seconds_str, &ep, 10);
+	if (*ep != '\0' || secs < MIN_HOLDTIME || secs > MAX_HOLDTIME) {
+		vty_out(vty, "%% Invalid holdtime%s", VTY_NEWLINE);
+		return (CMD_WARNING);
+	}
+
+	if (hello_type_str[0] == 'h')
+		hello_type = HELLO_LINK;
+	else
+		hello_type = HELLO_TARGETED;
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+
+	switch (vty->node) {
+	case LDP_NODE:
+		if (disable) {
+			switch (hello_type) {
+			case HELLO_LINK:
+				vty_conf->lhello_holdtime = LINK_DFLT_HOLDTIME;
+				break;
+			case HELLO_TARGETED:
+				vty_conf->thello_holdtime =
+				    TARGETED_DFLT_HOLDTIME;
+				break;
+			}
+		} else {
+			switch (hello_type) {
+			case HELLO_LINK:
+				vty_conf->lhello_holdtime = secs;
+				break;
+			case HELLO_TARGETED:
+				vty_conf->thello_holdtime = secs;
+				break;
+			}
+		}
+		break;
+	case LDP_IPV4_NODE:
+	case LDP_IPV6_NODE:
+		af = ldp_vty_get_af(vty);
+		af_conf = ldp_af_conf_get(vty_conf, af);
+
+		if (disable) {
+			switch (hello_type) {
+			case HELLO_LINK:
+				af_conf->lhello_holdtime = 0;
+				break;
+			case HELLO_TARGETED:
+				af_conf->thello_holdtime = 0;
+				break;
+			}
+		} else {
+			switch (hello_type) {
+			case HELLO_LINK:
+				af_conf->lhello_holdtime = secs;
+				break;
+			case HELLO_TARGETED:
+				af_conf->thello_holdtime = secs;
+				break;
+			}
+		}
+		break;
+	case LDP_IPV4_IFACE_NODE:
+	case LDP_IPV6_IFACE_NODE:
+		af = ldp_vty_get_af(vty);
+		iface = if_lookup_name(vty_conf, vty_ifname);
+		ia = iface_af_get(iface, af);
+
+		if (disable)
+			ia->hello_holdtime = 0;
+		else
+			ia->hello_holdtime = secs;
+		break;
+	default:
+		fatalx("ldp_vty_disc_holdtime: unexpected node");
+	}
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_disc_interval(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct ldpd_af_conf	*af_conf;
+	struct iface		*iface;
+	struct iface_af		*ia;
+	int			 af;
+	char			*ep;
+	long int		 secs;
+	enum hello_type		 hello_type;
+	const char		*seconds_str;
+	const char		*hello_type_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	seconds_str = vty_get_arg_value(args, "seconds");
+	hello_type_str = vty_get_arg_value(args, "hello_type");
+
+	secs = strtol(seconds_str, &ep, 10);
+	if (*ep != '\0' || secs < MIN_HOLDTIME || secs > MAX_HOLDTIME) {
+		vty_out(vty, "%% Invalid interval%s", VTY_NEWLINE);
+		return (CMD_WARNING);
+	}
+
+	if (hello_type_str[0] == 'h')
+		hello_type = HELLO_LINK;
+	else
+		hello_type = HELLO_TARGETED;
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+
+	switch (vty->node) {
+	case LDP_NODE:
+		if (disable) {
+			switch (hello_type) {
+			case HELLO_LINK:
+				vty_conf->lhello_interval = LINK_DFLT_HOLDTIME;
+				break;
+			case HELLO_TARGETED:
+				vty_conf->thello_interval =
+				    TARGETED_DFLT_HOLDTIME;
+				break;
+			}
+		} else {
+			switch (hello_type) {
+			case HELLO_LINK:
+				vty_conf->lhello_interval = secs;
+				break;
+			case HELLO_TARGETED:
+				vty_conf->thello_interval = secs;
+				break;
+			}
+		}
+		break;
+	case LDP_IPV4_NODE:
+	case LDP_IPV6_NODE:
+		af = ldp_vty_get_af(vty);
+		af_conf = ldp_af_conf_get(vty_conf, af);
+
+		if (disable) {
+			switch (hello_type) {
+			case HELLO_LINK:
+				af_conf->lhello_interval = 0;
+				break;
+			case HELLO_TARGETED:
+				af_conf->thello_interval = 0;
+				break;
+			}
+		} else {
+			switch (hello_type) {
+			case HELLO_LINK:
+				af_conf->lhello_interval = secs;
+				break;
+			case HELLO_TARGETED:
+				af_conf->thello_interval = secs;
+				break;
+			}
+		}
+		break;
+	case LDP_IPV4_IFACE_NODE:
+	case LDP_IPV6_IFACE_NODE:
+		af = ldp_vty_get_af(vty);
+		iface = if_lookup_name(vty_conf, vty_ifname);
+		ia = iface_af_get(iface, af);
+
+		if (disable)
+			ia->hello_interval = 0;
+		else
+			ia->hello_interval = secs;
+		break;
+	default:
+		fatalx("ldp_vty_disc_interval: unexpected node");
+	}
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_targeted_hello_accept(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct ldpd_af_conf	*af_conf;
+	int			 af;
+	int			 disable;
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+
+	af = ldp_vty_get_af(vty);
+	af_conf = ldp_af_conf_get(vty_conf, af);
+
+	if (disable)
+		af_conf->flags &= ~F_LDPD_AF_THELLO_ACCEPT;
+	else
+		af_conf->flags |= F_LDPD_AF_THELLO_ACCEPT;
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+static int
+ldp_vty_nbr_session_holdtime(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	char			*ep;
+	long int		 secs;
+	struct in_addr		 lsr_id;
+	struct nbr_params	*nbrp;
+	const char		*seconds_str;
+	const char		*lsr_id_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	seconds_str = vty_get_arg_value(args, "seconds");
+	lsr_id_str = vty_get_arg_value(args, "lsr_id");
+
+	if (inet_pton(AF_INET, lsr_id_str, &lsr_id) != 1 ||
+	    bad_addr_v4(lsr_id)) {
+		vty_out(vty, "%% Malformed address%s", VTY_NEWLINE);
+		return (CMD_WARNING);
+	}
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	nbrp = nbr_params_find(vty_conf, lsr_id);
+
+	secs = strtol(seconds_str, &ep, 10);
+	if (*ep != '\0' || secs < MIN_KEEPALIVE || secs > MAX_KEEPALIVE) {
+		vty_out(vty, "%% Invalid holdtime%s", VTY_NEWLINE);
+		goto cancel;
+	}
+
+	if (disable) {
+		if (nbrp == NULL)
+			goto cancel;
+
+		nbrp->keepalive = 0;
+		nbrp->flags &= ~F_NBRP_KEEPALIVE;
+	} else {
+		if (nbrp == NULL) {
+			nbrp = nbr_params_new(lsr_id);
+			LIST_INSERT_HEAD(&vty_conf->nbrp_list, nbrp, entry);
+		} else if (nbrp->keepalive == secs)
+			goto cancel;
+
+		nbrp->keepalive = secs;
+		nbrp->flags |= F_NBRP_KEEPALIVE;
+	}
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+
+cancel:
+	ldp_clear_config(vty_conf);
+	return (CMD_SUCCESS);
+}
+
+static int
+ldp_vty_af_session_holdtime(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct ldpd_af_conf	*af_conf;
+	int			 af;
+	char			*ep;
+	long int		 secs;
+	const char		*seconds_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	seconds_str = vty_get_arg_value(args, "seconds");
+
+	secs = strtol(seconds_str, &ep, 10);
+	if (*ep != '\0' || secs < MIN_KEEPALIVE || secs > MAX_KEEPALIVE) {
+		vty_out(vty, "%% Invalid holdtime%s", VTY_NEWLINE);
+		return (CMD_SUCCESS);
+	}
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	af = ldp_vty_get_af(vty);
+	af_conf = ldp_af_conf_get(vty_conf, af);
+
+	if (disable)
+		af_conf->keepalive = DEFAULT_KEEPALIVE;
+	else
+		af_conf->keepalive = secs;
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_session_holdtime(struct vty *vty, struct vty_arg *args[])
+{
+	switch (vty->node) {
+	case LDP_NODE:
+		return (ldp_vty_nbr_session_holdtime(vty, args));
+	case LDP_IPV4_NODE:
+	case LDP_IPV6_NODE:
+		return (ldp_vty_af_session_holdtime(vty, args));
+	default:
+		fatalx("ldp_vty_session_holdtime: unexpected node");
+	}
+}
+
+int
+ldp_vty_interface(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	int			 af;
+	struct iface		*iface;
+	struct iface_af		*ia;
+	struct interface	*ifp;
+	struct kif		 kif;
+	const char		*ifname;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	ifname = vty_get_arg_value(args, "ifname");
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	af = ldp_vty_get_af(vty);
+	iface = if_lookup_name(vty_conf, ifname);
+
+	if (disable) {
+		if (iface == NULL)
+			goto cancel;
+
+		ia = iface_af_get(iface, af);
+		if (ia->enabled == 0)
+			goto cancel;
+
+		ia->enabled = 0;
+		ldp_reload(vty_conf);
+		return (CMD_SUCCESS);
+	}
+
+	switch (af) {
+	case AF_INET:
+		vty->node = LDP_IPV4_IFACE_NODE;
+		break;
+	case AF_INET6:
+		vty->node = LDP_IPV6_IFACE_NODE;
+		break;
+	default:
+		break;
+	}
+	strlcpy(vty_ifname, ifname, sizeof(vty_ifname));
+
+	if (iface == NULL) {
+		if (ldp_iface_is_configured(vty_conf, ifname)) {
+			vty_out(vty, "%% Interface is already in use%s",
+			    VTY_NEWLINE);
+			goto cancel;
+		}
+
+		ifp = if_lookup_by_name(ifname);
+		memset(&kif, 0, sizeof(kif));
+		strlcpy(kif.ifname, ifname, sizeof(kif.ifname));
+		if (ifp) {
+			kif.ifindex = ifp->ifindex;
+			kif.flags = ifp->flags;
+		}
+		iface = if_new(&kif);
+
+		ia = iface_af_get(iface, af);
+		ia->enabled = 1;
+		LIST_INSERT_HEAD(&vty_conf->iface_list, iface, entry);
+	} else {
+		memset(&kif, 0, sizeof(kif));
+		strlcpy(kif.ifname, ifname, sizeof(kif.ifname));
+
+		ia = iface_af_get(iface, af);
+		if (ia->enabled)
+			goto cancel;
+		ia->enabled = 1;
+	}
+
+	ldp_reload(vty_conf);
+	return (CMD_SUCCESS);
+
+cancel:
+	ldp_clear_config(vty_conf);
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_trans_addr(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct ldpd_af_conf	*af_conf;
+	int			 af;
+	const char		*addr_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	addr_str = vty_get_arg_value(args, "addr");
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	af = ldp_vty_get_af(vty);
+	af_conf = ldp_af_conf_get(vty_conf, af);
+
+	if (disable)
+		memset(&af_conf->trans_addr, 0, sizeof(af_conf->trans_addr));
+	else {
+		if (inet_pton(af, addr_str, &af_conf->trans_addr) != 1 ||
+		    bad_addr(af, &af_conf->trans_addr)) {
+			vty_out(vty, "%% Malformed address%s", VTY_NEWLINE);
+			goto cancel;
+		}
+	}
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+
+cancel:
+	ldp_clear_config(vty_conf);
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_neighbor_targeted(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	int			 af;
+	union ldpd_addr		 addr;
+	struct tnbr		*tnbr;
+	const char		*addr_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	addr_str = vty_get_arg_value(args, "addr");
+
+	af = ldp_vty_get_af(vty);
+
+	if (inet_pton(af, addr_str, &addr) != 1 ||
+	    bad_addr(af, &addr)) {
+		vty_out(vty, "%% Malformed address%s", VTY_NEWLINE);
+		return (CMD_WARNING);
+	}
+	if (af == AF_INET6 &&  IN6_IS_SCOPE_EMBED(&addr.v6)) {
+		vty_out(vty, "%% Address can not be link-local%s", VTY_NEWLINE);
+		return (CMD_WARNING);
+	}
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	tnbr = tnbr_find(vty_conf, af, &addr);
+
+	if (disable) {
+		if (tnbr == NULL || !(tnbr->flags & F_TNBR_CONFIGURED))
+			goto cancel;
+
+		LIST_REMOVE(tnbr, entry);
+		free(tnbr);
+		ldp_reload(vty_conf);
+		return (CMD_SUCCESS);
+	}
+
+	if (tnbr && (tnbr->flags & F_TNBR_CONFIGURED))
+		goto cancel;
+
+	tnbr = tnbr_new(af, &addr);
+	tnbr->flags |= F_TNBR_CONFIGURED;
+	LIST_INSERT_HEAD(&vty_conf->tnbr_list, tnbr, entry);
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+
+cancel:
+	ldp_clear_config(vty_conf);
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_explicit_null(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct ldpd_af_conf	*af_conf;
+	int			 af;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	af = ldp_vty_get_af(vty);
+	af_conf = ldp_af_conf_get(vty_conf, af);
+
+	if (disable)
+		af_conf->flags &= ~F_LDPD_AF_EXPNULL;
+	else
+		af_conf->flags |= F_LDPD_AF_EXPNULL;
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_router_id(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	const char		*addr_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	addr_str = vty_get_arg_value(args, "addr");
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+
+	if (disable)
+		vty_conf->rtr_id.s_addr = INADDR_ANY;
+	else {
+		if (inet_pton(AF_INET, addr_str, &vty_conf->rtr_id) != 1 ||
+		    bad_addr_v4(vty_conf->rtr_id)) {
+			vty_out(vty, "%% Malformed address%s", VTY_NEWLINE);
+			goto cancel;
+		}
+	}
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+
+cancel:
+	ldp_clear_config(vty_conf);
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_ds_cisco_interop(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+
+	if (disable)
+		vty_conf->flags &= ~F_LDPD_DS_CISCO_INTEROP;
+	else
+		vty_conf->flags |= F_LDPD_DS_CISCO_INTEROP;
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_trans_pref_ipv4(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+
+	if (disable)
+		vty_conf->trans_pref = DUAL_STACK_LDPOV6;
+	else
+		vty_conf->trans_pref = DUAL_STACK_LDPOV4;
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_neighbor_password(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct in_addr		 lsr_id;
+	size_t			 password_len;
+	struct nbr_params	*nbrp;
+	const char		*lsr_id_str;
+	const char		*password_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	lsr_id_str = vty_get_arg_value(args, "lsr_id");
+	password_str = vty_get_arg_value(args, "password");
+
+	if (inet_pton(AF_INET, lsr_id_str, &lsr_id) != 1 ||
+	    bad_addr_v4(lsr_id)) {
+		vty_out(vty, "%% Malformed address%s", VTY_NEWLINE);
+		return (CMD_WARNING);
+	}
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	nbrp = nbr_params_find(vty_conf, lsr_id);
+
+	if (disable) {
+		if (nbrp == NULL)
+			goto cancel;
+
+		memset(&nbrp->auth, 0, sizeof(nbrp->auth));
+		nbrp->auth.method = AUTH_NONE;
+	} else {
+		if (nbrp == NULL) {
+			nbrp = nbr_params_new(lsr_id);
+			LIST_INSERT_HEAD(&vty_conf->nbrp_list, nbrp, entry);
+		} else if (nbrp->auth.method == AUTH_MD5SIG &&
+		    strcmp(nbrp->auth.md5key, password_str) == 0)
+			goto cancel;
+
+		password_len = strlcpy(nbrp->auth.md5key, password_str,
+		    sizeof(nbrp->auth.md5key));
+		if (password_len >= sizeof(nbrp->auth.md5key))
+			vty_out(vty, "%% password has been truncated to %zu "
+			    "characters.", sizeof(nbrp->auth.md5key) - 1);
+		nbrp->auth.md5key_len = password_len;
+		nbrp->auth.method = AUTH_MD5SIG;
+	}
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+
+cancel:
+	ldp_clear_config(vty_conf);
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_l2vpn(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct l2vpn		*l2vpn;
+	const char		*name_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	name_str = vty_get_arg_value(args, "name");
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	l2vpn = l2vpn_find(vty_conf, name_str);
+
+	if (disable) {
+		if (l2vpn == NULL)
+			goto cancel;
+
+		ldp_clear_l2vpn_config(l2vpn);
+		ldp_reload(vty_conf);
+		return (CMD_SUCCESS);
+	}
+
+	vty->node = LDP_L2VPN_NODE;
+	strlcpy(vty_l2vpn_name, name_str, sizeof(vty_l2vpn_name));
+	if (l2vpn)
+		goto cancel;
+
+	l2vpn = l2vpn_new(name_str);
+	l2vpn->type = L2VPN_TYPE_VPLS;
+	LIST_INSERT_HEAD(&vty_conf->l2vpn_list, l2vpn, entry);
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+
+cancel:
+	ldp_clear_config(vty_conf);
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_l2vpn_bridge(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct l2vpn		*l2vpn;
+	const char		*ifname;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	ifname = vty_get_arg_value(args, "ifname");
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	l2vpn = l2vpn_find(vty_conf, vty_l2vpn_name);
+
+	if (disable)
+		memset(l2vpn->br_ifname, 0, sizeof(l2vpn->br_ifname));
+	else
+		strlcpy(l2vpn->br_ifname, ifname, sizeof(l2vpn->br_ifname));
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_l2vpn_mtu(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct l2vpn		*l2vpn;
+	char			*ep;
+	int			 mtu;
+	const char		*mtu_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	mtu_str = vty_get_arg_value(args, "mtu");
+
+	mtu = strtol(mtu_str, &ep, 10);
+	if (*ep != '\0' || mtu < MIN_L2VPN_MTU || mtu > MAX_L2VPN_MTU) {
+		vty_out(vty, "%% Invalid MTU%s", VTY_NEWLINE);
+		return (CMD_WARNING);
+	}
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	l2vpn = l2vpn_find(vty_conf, vty_l2vpn_name);
+
+	if (disable)
+		l2vpn->mtu = DEFAULT_L2VPN_MTU;
+	else
+		l2vpn->mtu = mtu;
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_l2vpn_pwtype(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct l2vpn		*l2vpn;
+	int			 pw_type;
+	const char		*type_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	type_str = vty_get_arg_value(args, "type");
+
+	if (strcmp(type_str, "ethernet") == 0)
+		pw_type = PW_TYPE_ETHERNET;
+	else
+		pw_type = PW_TYPE_ETHERNET_TAGGED;
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	l2vpn = l2vpn_find(vty_conf, vty_l2vpn_name);
+
+	if (disable)
+		l2vpn->pw_type = DEFAULT_PW_TYPE;
+	else
+		l2vpn->pw_type = pw_type;
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_l2vpn_interface(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct l2vpn		*l2vpn;
+	struct l2vpn_if		*lif;
+	struct interface	*ifp;
+	struct kif		 kif;
+	const char		*ifname;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	ifname = vty_get_arg_value(args, "ifname");
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	l2vpn = l2vpn_find(vty_conf, vty_l2vpn_name);
+	lif = l2vpn_if_find_name(l2vpn, ifname);
+
+	if (disable) {
+		if (lif == NULL)
+			goto cancel;
+
+		LIST_REMOVE(lif, entry);
+		free(lif);
+		ldp_reload(vty_conf);
+		return (CMD_SUCCESS);
+	}
+
+	if (lif)
+		goto cancel;
+
+	if (ldp_iface_is_configured(vty_conf, ifname)) {
+		vty_out(vty, "%% Interface is already in use%s", VTY_NEWLINE);
+		goto cancel;
+	}
+
+	ifp = if_lookup_by_name(ifname);
+	memset(&kif, 0, sizeof(kif));
+	strlcpy(kif.ifname, ifname, sizeof(kif.ifname));
+	if (ifp) {
+		kif.ifindex = ifp->ifindex;
+		kif.flags = ifp->flags;
+	}
+
+	lif = l2vpn_if_new(l2vpn, &kif);
+	LIST_INSERT_HEAD(&l2vpn->if_list, lif, entry);
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+
+cancel:
+	ldp_clear_config(vty_conf);
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_l2vpn_pseudowire(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct l2vpn		*l2vpn;
+	struct l2vpn_pw		*pw;
+	struct interface	*ifp;
+	struct kif		 kif;
+	const char		*ifname;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	ifname = vty_get_arg_value(args, "ifname");
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	l2vpn = l2vpn_find(vty_conf, vty_l2vpn_name);
+	pw = l2vpn_pw_find_name(l2vpn, ifname);
+
+	if (disable) {
+		if (pw == NULL)
+			goto cancel;
+
+		LIST_REMOVE(pw, entry);
+		free(pw);
+		ldp_reload(vty_conf);
+		return (CMD_SUCCESS);
+	}
+
+	if (pw) {
+		vty->node = LDP_PSEUDOWIRE_NODE;
+		strlcpy(vty_pw_ifname, ifname, sizeof(vty_pw_ifname));
+		goto cancel;
+	}
+
+	if (ldp_iface_is_configured(vty_conf, ifname)) {
+		vty_out(vty, "%% Interface is already in use%s", VTY_NEWLINE);
+		goto cancel;
+	}
+
+	ifp = if_lookup_by_name(ifname);
+	memset(&kif, 0, sizeof(kif));
+	strlcpy(kif.ifname, ifname, sizeof(kif.ifname));
+	if (ifp) {
+		kif.ifindex = ifp->ifindex;
+		kif.flags = ifp->flags;
+	}
+
+	pw = l2vpn_pw_new(l2vpn, &kif);
+	pw->flags = F_PW_STATUSTLV_CONF|F_PW_CWORD_CONF;
+	LIST_INSERT_HEAD(&l2vpn->pw_inactive_list, pw, entry);
+
+	ldp_reload(vty_conf);
+
+	vty->node = LDP_PSEUDOWIRE_NODE;
+	strlcpy(vty_pw_ifname, ifname, sizeof(vty_pw_ifname));
+	return (CMD_SUCCESS);
+
+cancel:
+	ldp_clear_config(vty_conf);
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_l2vpn_pw_cword(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct l2vpn		*l2vpn;
+	struct l2vpn_pw		*pw;
+	const char		*preference_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	preference_str = vty_get_arg_value(args, "preference");
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	l2vpn = l2vpn_find(vty_conf, vty_l2vpn_name);
+	pw = l2vpn_pw_find_name(l2vpn, vty_pw_ifname);
+
+	if (disable)
+		pw->flags |= F_PW_CWORD_CONF;
+	else {
+		if (preference_str[0] == 'e')
+			pw->flags &= ~F_PW_CWORD_CONF;
+		else
+			pw->flags |= F_PW_CWORD_CONF;
+	}
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_l2vpn_pw_nbr_addr(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct l2vpn		*l2vpn;
+	struct l2vpn_pw		*pw;
+	int			 af;
+	union ldpd_addr		 addr;
+	const char		*addr_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	addr_str = vty_get_arg_value(args, "addr");
+
+	if (ldp_get_address(addr_str, &af, &addr) == -1 ||
+	    bad_addr(af, &addr)) {
+		vty_out(vty, "%% Malformed address%s", VTY_NEWLINE);
+		return (CMD_WARNING);
+	}
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	l2vpn = l2vpn_find(vty_conf, vty_l2vpn_name);
+	pw = l2vpn_pw_find_name(l2vpn, vty_pw_ifname);
+
+	if (disable) {
+		pw->af = AF_UNSPEC;
+		memset(&pw->addr, 0, sizeof(pw->addr));
+		pw->flags &= ~F_PW_STATIC_NBR_ADDR;
+
+		if (pw->lsr_id.s_addr != INADDR_ANY) {
+			pw->af = AF_INET;
+			pw->addr.v4 = pw->lsr_id;
+		}
+	} else {
+		pw->af = af;
+		pw->addr = addr;
+		pw->flags |= F_PW_STATIC_NBR_ADDR;
+	}
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_l2vpn_pw_nbr_id(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct l2vpn		*l2vpn;
+	struct l2vpn_pw		*pw;
+	struct in_addr		 lsr_id;
+	const char		*lsr_id_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	lsr_id_str = vty_get_arg_value(args, "lsr-id");
+
+	if (inet_pton(AF_INET, lsr_id_str, &lsr_id) != 1 ||
+	    bad_addr_v4(lsr_id)) {
+		vty_out(vty, "%% Malformed address%s", VTY_NEWLINE);
+		return (CMD_WARNING);
+	}
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	l2vpn = l2vpn_find(vty_conf, vty_l2vpn_name);
+	pw = l2vpn_pw_find_name(l2vpn, vty_pw_ifname);
+
+	if (disable) {
+		pw->lsr_id.s_addr = INADDR_ANY;
+		if (!(pw->flags & F_PW_STATIC_NBR_ADDR)) {
+			pw->af = AF_UNSPEC;
+			memset(&pw->addr, 0, sizeof(pw->addr));
+		}
+	} else {
+		pw->lsr_id = lsr_id;
+		if (!(pw->flags & F_PW_STATIC_NBR_ADDR)) {
+			pw->af = AF_INET;
+			pw->addr.v4 = lsr_id;
+		}
+	}
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_l2vpn_pw_pwid(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct l2vpn		*l2vpn;
+	struct l2vpn_pw		*pw;
+	char			*ep;
+	uint32_t		 pwid;
+	const char		*pwid_str;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+	pwid_str = vty_get_arg_value(args, "pwid");
+
+	pwid = strtol(pwid_str, &ep, 10);
+	if (*ep != '\0' || pwid < MIN_PWID_ID || pwid > MAX_PWID_ID) {
+		vty_out(vty, "%% Invalid pw-id%s", VTY_NEWLINE);
+		return (CMD_WARNING);
+	}
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	l2vpn = l2vpn_find(vty_conf, vty_l2vpn_name);
+	pw = l2vpn_pw_find_name(l2vpn, vty_pw_ifname);
+
+	if (disable)
+		pw->pwid = 0;
+	else
+		pw->pwid = pwid;
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+int
+ldp_vty_l2vpn_pw_pwstatus(struct vty *vty, struct vty_arg *args[])
+{
+	struct ldpd_conf	*vty_conf;
+	struct l2vpn		*l2vpn;
+	struct l2vpn_pw		*pw;
+	int			 disable;
+
+	disable = (vty_get_arg_value(args, "no")) ? 1 : 0;
+
+	vty_conf = ldp_dup_config(ldpd_conf);
+	l2vpn = l2vpn_find(vty_conf, vty_l2vpn_name);
+	pw = l2vpn_pw_find_name(l2vpn, vty_pw_ifname);
+
+	if (disable)
+		pw->flags |= F_PW_STATUSTLV_CONF;
+	else
+		pw->flags &= ~F_PW_STATUSTLV_CONF;
+
+	ldp_reload(vty_conf);
+
+	return (CMD_SUCCESS);
+}
+
+void
+ldp_vty_if_init(void)
+{
+	/* Install interface node. */
+	install_node (&interface_node, interface_config_write);
+
+	install_element(CONFIG_NODE, &interface_cmd);
+	install_element(CONFIG_NODE, &no_interface_cmd);
+	install_default(INTERFACE_NODE);
+
+	/* "description" commands. */
+	install_element(INTERFACE_NODE, &interface_desc_cmd);
+	install_element(INTERFACE_NODE, &no_interface_desc_cmd);
+}
diff --git a/ldpd/ldp_vty_exec.c b/ldpd/ldp_vty_exec.c
new file mode 100644
index 0000000..50b2904
--- /dev/null
+++ b/ldpd/ldp_vty_exec.c
@@ -0,0 +1,813 @@
+/*
+ * Copyright (C) 2016 by Open Source Routing.
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <zebra.h>
+#include <sys/un.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "lde.h"
+#include "log.h"
+#include "ldp_vty.h"
+
+#include "command.h"
+#include "vty.h"
+#include "mpls.h"
+
+enum show_command {
+	SHOW_DISC,
+	SHOW_IFACE,
+	SHOW_NBR,
+	SHOW_LIB,
+	SHOW_L2VPN_PW,
+	SHOW_L2VPN_BINDING
+};
+
+struct show_filter {
+	int		family;
+	union ldpd_addr	addr;
+	uint8_t		prefixlen;
+};
+
+struct vty_adj {
+	TAILQ_ENTRY(vty_adj)	 entry;
+	struct ctl_adj		 a;
+};
+TAILQ_HEAD(vty_adj_list, vty_adj);
+
+struct vty_adj_if {
+	TAILQ_ENTRY(vty_adj_if)	 entry;
+	char			 name[IF_NAMESIZE];
+	struct vty_adj_list	 adj_list;
+};
+
+struct vty_adj_tnbr {
+	TAILQ_ENTRY(vty_adj_tnbr) entry;
+	int			 af;
+	union ldpd_addr		 addr;
+	struct vty_adj_list	 adj_list;
+};
+
+static char		*print_label(char **, uint32_t);
+static const char	*print_pw_type(uint16_t);
+static const char	*print_time(time_t);
+static int		 show_interface_msg(struct vty *, struct imsg *,
+			    struct show_filter *);
+static void		 show_discovery_adj(struct vty *, struct vty_adj_list *);
+static int		 show_discovery_msg(struct vty *, struct imsg *,
+			    struct show_filter *);
+static void		 show_nbr_adj(struct vty *, struct vty_adj_list *);
+static int		 show_nbr_msg(struct vty *, struct imsg *,
+			    struct show_filter *);
+static int		 show_lib_msg(struct vty *, struct imsg *,
+			    struct show_filter *);
+static int		 show_l2vpn_binding_msg(struct vty *, struct imsg *);
+static int		 show_l2vpn_pw_msg(struct vty *, struct imsg *);
+static int		 ldp_vty_connect(struct imsgbuf *);
+static int		 ldp_vty_dispatch(struct vty *, struct imsgbuf *,
+			    enum show_command, struct show_filter *);
+static int		 ldp_vty_get_af(const char *, int *);
+
+static struct vty_adj_list vty_nbr_v4adjs = TAILQ_HEAD_INITIALIZER(vty_nbr_v4adjs);
+static struct vty_adj_list vty_nbr_v6adjs = TAILQ_HEAD_INITIALIZER(vty_nbr_v6adjs);
+static TAILQ_HEAD(, vty_adj_if) vty_ifaces = TAILQ_HEAD_INITIALIZER(vty_ifaces);
+static TAILQ_HEAD(, vty_adj_tnbr) vty_tnbrs = TAILQ_HEAD_INITIALIZER(vty_tnbrs);
+
+static char *
+print_label(char **string, uint32_t label)
+{
+	if (label == NO_LABEL) {
+		if (asprintf(string, "-") == -1)
+			fatal("print_label");
+	} else if (label == MPLS_LABEL_IMPLNULL) {
+		if (asprintf(string, "imp-null") == -1)
+			fatal("print_label");
+	} else if (label == MPLS_LABEL_IPV4NULL ||
+	    label == MPLS_LABEL_IPV6NULL) {
+		if (asprintf(string, "exp-null") == -1)
+			fatal("print_label");
+	} else {
+		if (asprintf(string, "%u", label) == -1)
+			fatal("print_label");
+	}
+
+	return (*string);
+}
+
+static const char *
+print_pw_type(uint16_t pw_type)
+{
+	static char buf[64];
+
+	switch (pw_type) {
+	case PW_TYPE_ETHERNET_TAGGED:
+		return ("Eth Tagged");
+	case PW_TYPE_ETHERNET:
+		return ("Ethernet");
+	default:
+		snprintf(buf, sizeof(buf), "[%0x]", pw_type);
+		return (buf);
+	}
+}
+
+#define	TF_BUFS	8
+#define	TF_LEN	9
+static const char *
+print_time(time_t t)
+{
+	char		*buf;
+	static char	 tfbuf[TF_BUFS][TF_LEN];	/* ring buffer */
+	static int	 idx = 0;
+	unsigned int	 sec, min, hrs, day, week;
+
+	buf = tfbuf[idx++];
+	if (idx == TF_BUFS)
+		idx = 0;
+
+	week = t;
+
+	sec = week % 60;
+	week /= 60;
+	min = week % 60;
+	week /= 60;
+	hrs = week % 24;
+	week /= 24;
+	day = week % 7;
+	week /= 7;
+
+	if (week > 0)
+		snprintf(buf, TF_LEN, "%02uw%01ud%02uh", week, day, hrs);
+	else if (day > 0)
+		snprintf(buf, TF_LEN, "%01ud%02uh%02um", day, hrs, min);
+	else
+		snprintf(buf, TF_LEN, "%02u:%02u:%02u", hrs, min, sec);
+
+	return (buf);
+}
+
+static int
+show_interface_msg(struct vty *vty, struct imsg *imsg,
+    struct show_filter *filter)
+{
+	struct ctl_iface	*iface;
+	char			*timers;
+
+	switch (imsg->hdr.type) {
+	case IMSG_CTL_SHOW_INTERFACE:
+		iface = imsg->data;
+
+		if (filter->family != AF_UNSPEC && filter->family != iface->af)
+			break;
+
+		if (asprintf(&timers, "%u/%u", iface->hello_interval,
+		    iface->hello_holdtime) == -1)
+			fatal("show_interface_msg");
+
+		vty_out(vty, "%-4s %-11s %-6s %-8s %-12s %3u%s",
+		    af_name(iface->af), iface->name,
+		    if_state_name(iface->state), iface->uptime == 0 ?
+		    "00:00:00" : print_time(iface->uptime), timers,
+		    iface->adj_cnt, VTY_NEWLINE);
+		free(timers);
+		break;
+	case IMSG_CTL_END:
+		vty_out(vty, "%s", VTY_NEWLINE);
+		return (1);
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+static void
+show_discovery_adj(struct vty *vty, struct vty_adj_list *list)
+{
+	struct vty_adj		*vadj;
+
+	while ((vadj = TAILQ_FIRST(list)) != NULL) {
+		vty_out(vty, "      LDP Id: %s:0, Transport address: %s%s",
+		    inet_ntoa(vadj->a.id), log_addr(vadj->a.af,
+		    &vadj->a.trans_addr), VTY_NEWLINE);
+		vty_out(vty, "          Hold time: %u sec%s",
+		    vadj->a.holdtime, VTY_NEWLINE);
+
+		TAILQ_REMOVE(list, vadj, entry);
+		free(vadj);
+	}
+}
+
+static int
+show_discovery_msg(struct vty *vty, struct imsg *imsg,
+    struct show_filter *filter)
+{
+	struct ctl_adj			*adj;
+	struct ctl_adj_if		*iface;
+	struct ctl_adj_tnbr		*tnbr;
+	struct vty_adj			*vadj;
+	static struct vty_adj_if	*viface;
+	static struct vty_adj_tnbr	*vtnbr;
+	struct in_addr			 rtr_id;
+	union ldpd_addr			*trans_addr;
+
+	switch (imsg->hdr.type) {
+	case IMSG_CTL_SHOW_DISC_IFACE:
+		iface = imsg->data;
+
+		if (filter->family != AF_UNSPEC &&
+		    ((filter->family == AF_INET && !iface->active_v4) ||
+		    (filter->family == AF_INET6 && !iface->active_v6)))
+			break;
+
+		viface = calloc(1, sizeof(*viface));
+		if (viface == NULL)
+			fatal(__func__);
+
+		strlcpy(viface->name, iface->name, sizeof(viface->name));
+		TAILQ_INIT(&viface->adj_list);
+		TAILQ_INSERT_HEAD(&vty_ifaces, viface, entry);
+		break;
+	case IMSG_CTL_SHOW_DISC_TNBR:
+		tnbr = imsg->data;
+
+		if (filter->family != AF_UNSPEC && filter->family != tnbr->af)
+			break;
+
+		vtnbr = calloc(1, sizeof(*vtnbr));
+		if (vtnbr == NULL)
+			fatal(__func__);
+
+		vtnbr->af = tnbr->af;
+		vtnbr->addr = tnbr->addr;
+		TAILQ_INIT(&vtnbr->adj_list);
+		TAILQ_INSERT_HEAD(&vty_tnbrs, vtnbr, entry);
+		break;
+	case IMSG_CTL_SHOW_DISCOVERY:
+		adj = imsg->data;
+
+		if (filter->family != AF_UNSPEC && filter->family != adj->af)
+			break;
+
+		vadj = calloc(1, sizeof(*vadj));
+		if (vadj == NULL)
+			fatal(__func__);
+
+		vadj->a = *adj;
+
+		switch(adj->type) {
+		case HELLO_LINK:
+			TAILQ_INSERT_TAIL(&viface->adj_list, vadj, entry);
+			break;
+		case HELLO_TARGETED:
+			TAILQ_INSERT_TAIL(&vtnbr->adj_list, vadj, entry);
+			break;
+		}
+		break;
+	case IMSG_CTL_END:
+		rtr_id.s_addr = ldp_rtr_id_get(ldpd_conf);
+		vty_out(vty, "Local LDP Identifier: %s:0%s", inet_ntoa(rtr_id),
+		    VTY_NEWLINE);
+		vty_out(vty, "Discovery Sources:%s", VTY_NEWLINE);
+
+		vty_out(vty, "  Interfaces:%s", VTY_NEWLINE);
+		while ((viface = TAILQ_FIRST(&vty_ifaces)) != NULL) {
+			vty_out(vty, "    %s: %s%s", viface->name,
+			    TAILQ_EMPTY(&viface->adj_list) ? "xmit" :
+			    "xmit/recv", VTY_NEWLINE);
+			show_discovery_adj(vty, &viface->adj_list);
+
+			TAILQ_REMOVE(&vty_ifaces, viface, entry);
+			free(viface);
+		}
+
+		vty_out(vty, "  Targeted Hellos:%s", VTY_NEWLINE);
+		while ((vtnbr = TAILQ_FIRST(&vty_tnbrs)) != NULL) {
+			trans_addr = &(ldp_af_conf_get(ldpd_conf,
+			    vtnbr->af))->trans_addr;
+
+			if (ldp_addrisset(vtnbr->af, trans_addr)) {
+				vty_out(vty, "    %s -> %s: %s%s",
+				    log_addr(vtnbr->af, trans_addr),
+				    log_addr(vtnbr->af, &vtnbr->addr),
+				    TAILQ_EMPTY(&vtnbr->adj_list) ? "xmit" :
+				    "xmit/recv", VTY_NEWLINE);
+				show_discovery_adj(vty, &vtnbr->adj_list);
+			}
+
+			TAILQ_REMOVE(&vty_tnbrs, vtnbr, entry);
+			free(vtnbr);
+		}
+
+		vty_out(vty, "%s", VTY_NEWLINE);
+		return (1);
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+static void
+show_nbr_adj(struct vty *vty, struct vty_adj_list *list)
+{
+	struct vty_adj		*vadj;
+
+	while ((vadj = TAILQ_FIRST(list)) != NULL) {
+		switch (vadj->a.type) {
+		case HELLO_LINK:
+			vty_out(vty, "      Interface: %s%s", vadj->a.ifname,
+			    VTY_NEWLINE);
+			break;
+		case HELLO_TARGETED:
+			vty_out(vty, "      Targeted Hello: %s%s",
+			    log_addr(vadj->a.af, &vadj->a.src_addr),
+			    VTY_NEWLINE);
+			break;
+		}
+
+		TAILQ_REMOVE(list, vadj, entry);
+		free(vadj);
+	}
+}
+
+static int
+show_nbr_msg(struct vty *vty, struct imsg *imsg, struct show_filter *filter)
+{
+	struct ctl_adj		*adj;
+	struct ctl_nbr		*nbr;
+	struct vty_adj		*vadj;
+
+	switch (imsg->hdr.type) {
+	case IMSG_CTL_SHOW_NBR_DISC:
+		adj = imsg->data;
+
+		vadj = calloc(1, sizeof(*vadj));
+		if (vadj == NULL)
+			fatal(__func__);
+
+		vadj->a = *adj;
+		switch (adj->af) {
+		case AF_INET:
+			TAILQ_INSERT_HEAD(&vty_nbr_v4adjs, vadj, entry);
+			break;
+		case AF_INET6:
+			TAILQ_INSERT_HEAD(&vty_nbr_v6adjs, vadj, entry);
+			break;
+		default:
+			fatalx("show_nbr_msg: unknown af");
+		}
+		break;
+	case IMSG_CTL_SHOW_NBR:
+		nbr = imsg->data;
+
+		vty_out(vty, "Peer LDP Identifier: %s:0%s", inet_ntoa(nbr->id),
+		    VTY_NEWLINE);
+		vty_out(vty, "  TCP connection: %s:%u - %s:%u%s",
+		    log_addr(nbr->af, &nbr->laddr), ntohs(nbr->lport),
+		    log_addr(nbr->af, &nbr->raddr), ntohs(nbr->rport),
+		    VTY_NEWLINE);
+		vty_out(vty, "  Session Holdtime: %u sec%s", nbr->holdtime,
+		    VTY_NEWLINE);
+		vty_out(vty, "  State: %s; Downstream-Unsolicited%s",
+		    nbr_state_name(nbr->nbr_state), VTY_NEWLINE);
+		vty_out(vty, "  Up time: %s%s", print_time(nbr->uptime),
+		    VTY_NEWLINE);
+
+		vty_out(vty, "  LDP Discovery Sources:%s", VTY_NEWLINE);
+		if (!TAILQ_EMPTY(&vty_nbr_v4adjs)) {
+			vty_out(vty, "    IPv4:%s", VTY_NEWLINE);
+			show_nbr_adj(vty, &vty_nbr_v4adjs);
+		}
+		if (!TAILQ_EMPTY(&vty_nbr_v6adjs)) {
+			vty_out(vty, "    IPv6:%s", VTY_NEWLINE);
+			show_nbr_adj(vty, &vty_nbr_v6adjs);
+		}
+
+		vty_out(vty, "%s", VTY_NEWLINE);
+		break;
+	case IMSG_CTL_END:
+		return (1);
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+static int
+show_lib_msg(struct vty *vty, struct imsg *imsg, struct show_filter *filter)
+{
+	struct ctl_rt	*rt;
+	char		*dstnet, *local = NULL, *remote = NULL;
+
+	switch (imsg->hdr.type) {
+	case IMSG_CTL_SHOW_LIB:
+		rt = imsg->data;
+
+		if (filter->family != AF_UNSPEC && filter->family != rt->af)
+			break;
+
+		if (asprintf(&dstnet, "%s/%d", log_addr(rt->af, &rt->prefix),
+		    rt->prefixlen) == -1)
+			fatal("show_lib_msg");
+
+		if (rt->first) {
+			vty_out(vty, "%s%s", dstnet, VTY_NEWLINE);
+			vty_out(vty, "%-8sLocal binding: label: %s%s", "",
+			    print_label(&local, rt->local_label), VTY_NEWLINE);
+
+			if (rt->remote_label != NO_LABEL) {
+				vty_out(vty, "%-8sRemote bindings:%s", "",
+				    VTY_NEWLINE);
+				vty_out(vty, "%-12sPeer                Label%s",
+				    "", VTY_NEWLINE);
+				vty_out(vty, "%-12s-----------------   "
+				    "---------%s", "", VTY_NEWLINE);
+			} else
+				vty_out(vty, "%-8sNo remote bindings%s", "",
+				    VTY_NEWLINE);
+		}
+		if (rt->remote_label != NO_LABEL)
+			vty_out(vty, "%12s%-20s%s%s", "",
+			    inet_ntoa(rt->nexthop), print_label(&remote,
+			    rt->remote_label), VTY_NEWLINE);
+
+		free(remote);
+		free(local);
+		free(dstnet);
+		break;
+	case IMSG_CTL_END:
+		vty_out(vty, "%s", VTY_NEWLINE);
+		return (1);
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+static int
+show_l2vpn_binding_msg(struct vty *vty, struct imsg *imsg)
+{
+	struct ctl_pw	*pw;
+
+	switch (imsg->hdr.type) {
+	case IMSG_CTL_SHOW_L2VPN_BINDING:
+		pw = imsg->data;
+
+		vty_out(vty, "  Destination Address: %s, VC ID: %u%s",
+		    inet_ntoa(pw->lsr_id), pw->pwid, VTY_NEWLINE);
+
+		/* local binding */
+		if (pw->local_label != NO_LABEL) {
+			vty_out(vty, "    Local Label:  %u%s", pw->local_label,
+			    VTY_NEWLINE);
+			vty_out(vty, "%-8sCbit: %u,    VC Type: %s,    "
+			    "GroupID: %u%s", "", pw->local_cword,
+			    print_pw_type(pw->type), pw->local_gid,
+			    VTY_NEWLINE);
+			vty_out(vty, "%-8sMTU: %u%s", "", pw->local_ifmtu,
+			    VTY_NEWLINE);
+		} else
+			vty_out(vty, "    Local Label: unassigned%s",
+			    VTY_NEWLINE);
+
+		/* remote binding */
+		if (pw->remote_label != NO_LABEL) {
+			vty_out(vty, "    Remote Label: %u%s",
+			    pw->remote_label,  VTY_NEWLINE);
+			vty_out(vty, "%-8sCbit: %u,    VC Type: %s,    "
+			    "GroupID: %u%s", "", pw->remote_cword,
+			    print_pw_type(pw->type), pw->remote_gid,
+			    VTY_NEWLINE);
+			vty_out(vty, "%-8sMTU: %u%s", "", pw->remote_ifmtu,
+			    VTY_NEWLINE);
+		} else
+			vty_out(vty, "    Remote Label: unassigned%s",
+			    VTY_NEWLINE);
+		break;
+	case IMSG_CTL_END:
+		vty_out(vty, "%s", VTY_NEWLINE);
+		return (1);
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+static int
+show_l2vpn_pw_msg(struct vty *vty, struct imsg *imsg)
+{
+	struct ctl_pw	*pw;
+
+	switch (imsg->hdr.type) {
+	case IMSG_CTL_SHOW_L2VPN_PW:
+		pw = imsg->data;
+
+		vty_out(vty, "%-9s %-15s %-10u %-16s %-10s%s", pw->ifname,
+		    inet_ntoa(pw->lsr_id), pw->pwid, pw->l2vpn_name,
+		    (pw->status ? "UP" : "DOWN"), VTY_NEWLINE);
+		break;
+	case IMSG_CTL_END:
+		vty_out(vty, "%s", VTY_NEWLINE);
+		return (1);
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+static int
+ldp_vty_connect(struct imsgbuf *ibuf)
+{
+	struct sockaddr_un	 s_un;
+	int			 ctl_sock;
+
+	/* connect to ldpd control socket */
+	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
+		log_warn("%s: socket", __func__);
+		return (-1);
+	}
+
+	memset(&s_un, 0, sizeof(s_un));
+	s_un.sun_family = AF_UNIX;
+	strlcpy(s_un.sun_path, LDPD_SOCKET, sizeof(s_un.sun_path));
+	if (connect(ctl_sock, (struct sockaddr *)&s_un, sizeof(s_un)) == -1) {
+		log_warn("%s: connect: %s", __func__, LDPD_SOCKET);
+		close(ctl_sock);
+		return (-1);
+	}
+
+	imsg_init(ibuf, ctl_sock);
+
+	return (0);
+}
+
+static int
+ldp_vty_dispatch(struct vty *vty, struct imsgbuf *ibuf, enum show_command cmd,
+    struct show_filter *filter)
+{
+	struct imsg		 imsg;
+	int			 n, done = 0;
+
+	while (ibuf->w.queued)
+		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN) {
+			log_warn("write error");
+			close(ibuf->fd);
+			return (CMD_WARNING);
+		}
+
+	while (!done) {
+		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN) {
+			log_warnx("imsg_read error");
+			close(ibuf->fd);
+			return (CMD_WARNING);
+		}
+		if (n == 0) {
+			log_warnx("pipe closed");
+			close(ibuf->fd);
+			return (CMD_WARNING);
+		}
+
+		while (!done) {
+			if ((n = imsg_get(ibuf, &imsg)) == -1) {
+				log_warnx("imsg_get error");
+				close(ibuf->fd);
+				return (CMD_WARNING);
+			}
+			if (n == 0)
+				break;
+			switch (cmd) {
+			case SHOW_IFACE:
+				done = show_interface_msg(vty, &imsg, filter);
+				break;
+			case SHOW_DISC:
+				done = show_discovery_msg(vty, &imsg, filter);
+				break;
+			case SHOW_NBR:
+				done = show_nbr_msg(vty, &imsg, filter);
+				break;
+			case SHOW_LIB:
+				done = show_lib_msg(vty, &imsg, filter);
+				break;
+			case SHOW_L2VPN_PW:
+				done = show_l2vpn_pw_msg(vty, &imsg);
+				break;
+			case SHOW_L2VPN_BINDING:
+				done = show_l2vpn_binding_msg(vty, &imsg);
+				break;
+			default:
+				break;
+			}
+			imsg_free(&imsg);
+		}
+	}
+
+	close(ibuf->fd);
+
+	return (CMD_SUCCESS);
+}
+
+static int
+ldp_vty_get_af(const char *str, int *af)
+{
+	if (str == NULL) {
+		*af = AF_UNSPEC;
+		return (0);
+	} else if (strcmp(str, "ipv4") == 0) {
+		*af = AF_INET;
+		return (0);
+	} else if (strcmp(str, "ipv6") == 0) {
+		*af = AF_INET6;
+		return (0);
+	}
+
+	return (-1);
+}
+
+int
+ldp_vty_show_binding(struct vty *vty, struct vty_arg *args[])
+{
+	struct imsgbuf		 ibuf;
+	struct show_filter	 filter;
+	const char		*af_str;
+	int			 af;
+
+	if (ldp_vty_connect(&ibuf) < 0)
+		return (CMD_WARNING);
+
+	imsg_compose(&ibuf, IMSG_CTL_SHOW_LIB, 0, 0, -1, NULL, 0);
+
+	af_str = vty_get_arg_value(args, "address-family");
+	if (ldp_vty_get_af(af_str, &af) < 0)
+		return (CMD_ERR_NO_MATCH);
+
+	memset(&filter, 0, sizeof(filter));
+	filter.family = af;
+
+	return (ldp_vty_dispatch(vty, &ibuf, SHOW_LIB, &filter));
+}
+
+int
+ldp_vty_show_discovery(struct vty *vty, struct vty_arg *args[])
+{
+	struct imsgbuf		 ibuf;
+	struct show_filter	 filter;
+	const char		*af_str;
+	int			 af;
+
+	if (ldp_vty_connect(&ibuf) < 0)
+		return (CMD_WARNING);
+
+	imsg_compose(&ibuf, IMSG_CTL_SHOW_DISCOVERY, 0, 0, -1, NULL, 0);
+
+	af_str = vty_get_arg_value(args, "address-family");
+	if (ldp_vty_get_af(af_str, &af) < 0)
+		return (CMD_ERR_NO_MATCH);
+
+	memset(&filter, 0, sizeof(filter));
+	filter.family = af;
+
+	return (ldp_vty_dispatch(vty, &ibuf, SHOW_DISC, &filter));
+}
+
+int
+ldp_vty_show_interface(struct vty *vty, struct vty_arg *args[])
+{
+	struct imsgbuf		 ibuf;
+	struct show_filter	 filter;
+	unsigned int		 ifidx = 0;
+	const char		*af_str;
+	int			 af;
+
+	if (ldp_vty_connect(&ibuf) < 0)
+		return (CMD_WARNING);
+
+	imsg_compose(&ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0, -1, &ifidx,
+	    sizeof(ifidx));
+
+	af_str = vty_get_arg_value(args, "address-family");
+	if (ldp_vty_get_af(af_str, &af) < 0)
+		return (CMD_ERR_NO_MATCH);
+
+	memset(&filter, 0, sizeof(filter));
+	filter.family = af;
+
+	/* header */
+	vty_out(vty, "%-4s %-11s %-6s %-8s %-12s %3s%s", "AF",
+	    "Interface", "State", "Uptime", "Hello Timers", "ac", VTY_NEWLINE);
+
+	return (ldp_vty_dispatch(vty, &ibuf, SHOW_IFACE, &filter));
+}
+
+int
+ldp_vty_show_neighbor(struct vty *vty, struct vty_arg *args[])
+{
+	struct imsgbuf		 ibuf;
+	struct show_filter	 filter;
+
+	if (ldp_vty_connect(&ibuf) < 0)
+		return (CMD_WARNING);
+
+	imsg_compose(&ibuf, IMSG_CTL_SHOW_NBR, 0, 0, -1, NULL, 0);
+
+	/* not used */
+	memset(&filter, 0, sizeof(filter));
+
+	return (ldp_vty_dispatch(vty, &ibuf, SHOW_NBR, &filter));
+}
+
+int
+ldp_vty_show_atom_binding(struct vty *vty, struct vty_arg *args[])
+{
+	struct imsgbuf		 ibuf;
+	struct show_filter	 filter;
+
+	if (ldp_vty_connect(&ibuf) < 0)
+		return (CMD_WARNING);
+
+	imsg_compose(&ibuf, IMSG_CTL_SHOW_L2VPN_BINDING, 0, 0, -1, NULL, 0);
+
+	/* not used */
+	memset(&filter, 0, sizeof(filter));
+
+	return (ldp_vty_dispatch(vty, &ibuf, SHOW_L2VPN_BINDING, &filter));
+}
+
+int
+ldp_vty_show_atom_vc(struct vty *vty, struct vty_arg *args[])
+{
+	struct imsgbuf		 ibuf;
+	struct show_filter	 filter;
+
+	if (ldp_vty_connect(&ibuf) < 0)
+		return (CMD_WARNING);
+
+	imsg_compose(&ibuf, IMSG_CTL_SHOW_L2VPN_PW, 0, 0, -1, NULL, 0);
+
+	/* not used */
+	memset(&filter, 0, sizeof(filter));
+
+	/* header */
+	vty_out(vty, "%-9s %-15s %-10s %-16s %-10s%s",
+	    "Interface", "Peer ID", "VC ID", "Name", "Status", VTY_NEWLINE);
+	vty_out(vty, "%-9s %-15s %-10s %-16s %-10s%s",
+	    "---------", "---------------", "----------",
+	    "----------------", "----------", VTY_NEWLINE);
+
+	return (ldp_vty_dispatch(vty, &ibuf, SHOW_L2VPN_PW, &filter));
+}
+
+int
+ldp_vty_clear_nbr(struct vty *vty, struct vty_arg *args[])
+{
+	struct imsgbuf		 ibuf;
+	const char		*addr_str;
+	struct ctl_nbr		 nbr;
+
+	addr_str = vty_get_arg_value(args, "addr");
+
+	memset(&nbr, 0, sizeof(nbr));
+	if (addr_str &&
+	    (ldp_get_address(addr_str, &nbr.af, &nbr.raddr) == -1 ||
+	    bad_addr(nbr.af, &nbr.raddr))) {
+		vty_out(vty, "%% Malformed address%s", VTY_NEWLINE);
+		return (CMD_WARNING);
+	}
+
+	if (ldp_vty_connect(&ibuf) < 0)
+		return (CMD_WARNING);
+
+	imsg_compose(&ibuf, IMSG_CTL_CLEAR_NBR, 0, 0, -1, &nbr, sizeof(nbr));
+
+	while (ibuf.w.queued)
+		if (msgbuf_write(&ibuf.w) <= 0 && errno != EAGAIN) {
+			log_warn("write error");
+			close(ibuf.fd);
+			return (CMD_WARNING);
+		}
+
+	close(ibuf.fd);
+
+	return (CMD_SUCCESS);
+}
diff --git a/ldpd/ldp_zebra.c b/ldpd/ldp_zebra.c
new file mode 100644
index 0000000..acc8150
--- /dev/null
+++ b/ldpd/ldp_zebra.c
@@ -0,0 +1,569 @@
+/*
+ * Copyright (C) 2016 by Open Source Routing.
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#include <zebra.h>
+
+#include "prefix.h"
+#include "stream.h"
+#include "memory.h"
+#include "zclient.h"
+#include "command.h"
+#include "network.h"
+#include "linklist.h"
+#include "mpls.h"
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "lde.h"
+#include "log.h"
+
+static void	 ifp2kif(struct interface *, struct kif *);
+static void	 ifc2kaddr(struct interface *, struct connected *,
+		    struct kaddr *);
+static int	 ldp_router_id_update(int, struct zclient *, zebra_size_t,
+		    vrf_id_t);
+static int	 ldp_interface_add(int, struct zclient *, zebra_size_t,
+		    vrf_id_t);
+static int	 ldp_interface_delete(int, struct zclient *, zebra_size_t,
+    vrf_id_t);
+static int	 ldp_interface_status_change(int command, struct zclient *,
+		    zebra_size_t, vrf_id_t);
+static int	 ldp_interface_address_add(int, struct zclient *, zebra_size_t,
+		    vrf_id_t);
+static int	 ldp_interface_address_delete(int, struct zclient *,
+		    zebra_size_t, vrf_id_t);
+static int	 ldp_zebra_read_route(int, struct zclient *, zebra_size_t,
+		    vrf_id_t);
+static void	 ldp_zebra_connected(struct zclient *);
+
+struct zclient		*zclient = NULL;
+
+static void
+ifp2kif(struct interface *ifp, struct kif *kif)
+{
+	memset(kif, 0, sizeof(*kif));
+	strlcpy(kif->ifname, ifp->name, sizeof(kif->ifname));
+	kif->ifindex = ifp->ifindex;
+	kif->flags = ifp->flags;
+}
+
+static void
+ifc2kaddr(struct interface *ifp, struct connected *ifc, struct kaddr *ka)
+{
+	memset(ka, 0, sizeof(*ka));
+	ka->ifindex = ifp->ifindex;
+	ka->af = ifc->address->family;
+	ka->prefixlen = ifc->address->prefixlen;
+
+	switch (ka->af) {
+	case AF_INET:
+		ka->addr.v4 = ifc->address->u.prefix4;
+		if (ifc->destination)
+			ka->dstbrd.v4 = ifc->destination->u.prefix4;
+		break;
+	case AF_INET6:
+		ka->addr.v6 = ifc->address->u.prefix6;
+		if (ifc->destination)
+			ka->dstbrd.v6 = ifc->destination->u.prefix6;
+		break;
+	default:
+		break;
+	}
+}
+
+static int
+zebra_send_mpls_lsp(u_char cmd, struct zclient *zclient, int af,
+    union ldpd_addr *nexthop, mpls_label_t in_label, mpls_label_t out_label)
+{
+	struct stream		*s;
+
+	/* Reset stream. */
+	s = zclient->obuf;
+	stream_reset(s);
+
+	zclient_create_header(s, cmd, VRF_DEFAULT);
+	stream_putc(s, ZEBRA_LSP_LDP);
+	stream_putl(s, af);
+	switch (af) {
+	case AF_INET:
+		stream_put_in_addr(s, &nexthop->v4);
+		break;
+	case AF_INET6:
+		stream_write (s, (u_char *)&nexthop->v6, 16);
+		break;
+	default:
+		fatalx("zebra_send_mpls_lsp: unknown af");
+	}
+	stream_putl(s, in_label);
+	stream_putl(s, out_label);
+
+	/* Put length at the first point of the stream. */
+	stream_putw_at(s, 0, stream_get_endp(s));
+
+	return (zclient_send_message(zclient));
+}
+
+static int
+zebra_send_mpls_ftn(int delete, struct zclient *zclient, int af,
+    union ldpd_addr *prefix, uint8_t prefixlen, union ldpd_addr *nexthop,
+    mpls_label_t label)
+{
+	unsigned char		 cmd;
+	struct prefix_ipv4	 p4;
+	struct prefix_ipv6	 p6;
+	struct zapi_ipv4	 api4;
+	struct zapi_ipv6	 api6;
+	struct in_addr		*nexthop4;
+	struct in6_addr		*nexthop6;
+
+	switch (af) {
+	case AF_INET:
+		p4.family = AF_INET;
+		p4.prefixlen = prefixlen;
+		p4.prefix = prefix->v4;
+		nexthop4 = &nexthop->v4;
+
+		api4.vrf_id = VRF_DEFAULT;
+		api4.type = ZEBRA_ROUTE_LDP;
+		api4.flags = 0;
+		api4.message = 0;
+		api4.safi = SAFI_UNICAST;
+		SET_FLAG(api4.message, ZAPI_MESSAGE_NEXTHOP);
+		api4.nexthop_num = 1;
+		api4.nexthop = &nexthop4;
+		api4.ifindex_num = 0;
+		SET_FLAG(api4.message, ZAPI_MESSAGE_LABEL);
+		api4.label = label;
+
+		if (delete)
+			cmd = ZEBRA_IPV4_ROUTE_DELETE;
+		else
+			cmd = ZEBRA_IPV4_ROUTE_ADD;
+		return (zapi_ipv4_route(cmd, zclient, &p4, &api4));
+	case AF_INET6:
+		p6.family = AF_INET6;
+		p6.prefixlen = prefixlen;
+		p6.prefix = prefix->v6;
+		nexthop6 = &nexthop->v6;
+
+		api6.vrf_id = VRF_DEFAULT;
+		api6.type = ZEBRA_ROUTE_LDP;
+		api6.flags = 0;
+		api6.message = 0;
+		api6.safi = SAFI_UNICAST;
+		SET_FLAG(api6.message, ZAPI_MESSAGE_NEXTHOP);
+		api6.nexthop_num = 1;
+		api6.nexthop = &nexthop6;
+		api6.ifindex_num = 0;
+		SET_FLAG(api6.message, ZAPI_MESSAGE_LABEL);
+		api6.label = label;
+
+		if (delete)
+			cmd = ZEBRA_IPV6_ROUTE_DELETE;
+		else
+			cmd = ZEBRA_IPV6_ROUTE_ADD;
+		return (zapi_ipv6_route(cmd, zclient, &p6, &api6));
+	default:
+		fatalx("zebra_send_mpls_ftn: unknown af");
+	}
+}
+
+int
+kr_change(struct kroute *kr)
+{
+	if (kr->local_label < MPLS_LABEL_RESERVED_MAX ||
+	    kr->remote_label == NO_LABEL)
+		return (0);
+
+	/* FEC -> NHLFE */
+	if (kr->remote_label != MPLS_LABEL_IMPLNULL)
+		zebra_send_mpls_ftn(0, zclient, kr->af, &kr->prefix,
+		    kr->prefixlen, &kr->nexthop, kr->remote_label);
+
+	/* ILM -> NHLFE */
+	zebra_send_mpls_lsp(ZEBRA_MPLS_LSP_ADD, zclient, kr->af, &kr->nexthop,
+	    kr->local_label, kr->remote_label);
+
+	return (0);
+}
+
+int
+kr_delete(struct kroute *kr)
+{
+	if (kr->local_label < MPLS_LABEL_RESERVED_MAX ||
+	    kr->remote_label == NO_LABEL)
+		return (0);
+
+	/* FEC -> NHLFE */
+	if (kr->remote_label != MPLS_LABEL_IMPLNULL)
+		zebra_send_mpls_ftn(1, zclient, kr->af, &kr->prefix,
+		    kr->prefixlen, &kr->nexthop, kr->remote_label);
+
+	/* ILM -> NHLFE */
+	zebra_send_mpls_lsp(ZEBRA_MPLS_LSP_DELETE, zclient, kr->af,
+	    &kr->nexthop, kr->local_label, kr->remote_label);
+
+	return (0);
+}
+
+int
+kmpw_set(struct kpw *kpw)
+{
+	/* TODO */
+	return (0);
+}
+
+int
+kmpw_unset(struct kpw *kpw)
+{
+	/* TODO */
+	return (0);
+}
+
+void
+kif_redistribute(const char *ifname)
+{
+	struct listnode		*node, *cnode;
+	struct interface	*ifp;
+	struct connected	*ifc;
+	struct kif		 kif;
+	struct kaddr		 ka;
+
+	for (ALL_LIST_ELEMENTS_RO(vrf_iflist(VRF_DEFAULT), node, ifp)) {
+		if (ifname && strcmp(ifname, ifp->name) != 0)
+			continue;
+
+		ifp2kif(ifp, &kif);
+		main_imsg_compose_ldpe(IMSG_IFSTATUS, 0, &kif, sizeof(kif));
+
+		for (ALL_LIST_ELEMENTS_RO(ifp->connected, cnode, ifc)) {
+			ifc2kaddr(ifp, ifc, &ka);
+			main_imsg_compose_ldpe(IMSG_NEWADDR, 0, &ka,
+			    sizeof(ka));
+		}
+	}
+}
+
+static int
+ldp_router_id_update(int command, struct zclient *zclient, zebra_size_t length,
+    vrf_id_t vrf_id)
+{
+	struct prefix	 router_id;
+
+	zebra_router_id_update_read(zclient->ibuf, &router_id);
+
+	if (bad_addr_v4(router_id.u.prefix4))
+		return (0);
+
+	log_debug("zebra: router-id update %s", inet_ntoa(router_id.u.prefix4));
+
+	global.rtr_id.s_addr = router_id.u.prefix4.s_addr;
+	main_imsg_compose_ldpe(IMSG_RTRID_UPDATE, 0, &global.rtr_id,
+	    sizeof(global.rtr_id));
+
+	return (0);
+}
+
+static int
+ldp_interface_add(int command, struct zclient *zclient, zebra_size_t length,
+    vrf_id_t vrf_id)
+{
+	struct interface	*ifp;
+	struct kif		 kif;
+
+	ifp = zebra_interface_add_read(zclient->ibuf, vrf_id);
+	log_debug("zebra: interface add %s index %d mtu %d", ifp->name,
+	    ifp->ifindex, ifp->mtu);
+
+	ifp2kif(ifp, &kif);
+	main_imsg_compose_ldpe(IMSG_IFSTATUS, 0, &kif, sizeof(kif));
+
+	return (0);
+}
+
+static int
+ldp_interface_delete(int command, struct zclient *zclient, zebra_size_t length,
+    vrf_id_t vrf_id)
+{
+	struct interface	*ifp;
+
+	/* zebra_interface_state_read() updates interface structure in iflist */
+	ifp = zebra_interface_state_read(zclient->ibuf, vrf_id);
+	if (ifp == NULL)
+		return (0);
+
+	log_debug("zebra: interface delete %s index %d mtu %d", ifp->name,
+	    ifp->ifindex, ifp->mtu);
+
+	/* To support pseudo interface do not free interface structure.  */
+	/* if_delete(ifp); */
+	ifp->ifindex = IFINDEX_INTERNAL;
+
+	return (0);
+}
+
+static int
+ldp_interface_status_change(int command, struct zclient *zclient,
+    zebra_size_t length, vrf_id_t vrf_id)
+{
+	struct interface	*ifp;
+	struct listnode		*node;
+	struct connected	*ifc;
+	struct kif		 kif;
+	struct kaddr		 ka;
+	int			 link_new;
+
+	/*
+	 * zebra_interface_state_read() updates interface structure in
+	 * iflist.
+	 */
+	ifp = zebra_interface_state_read(zclient->ibuf, vrf_id);
+	if (ifp == NULL)
+		return (0);
+
+	log_debug("interface %s state update", ifp->name);
+
+	ifp2kif(ifp, &kif);
+	main_imsg_compose_ldpe(IMSG_IFSTATUS, 0, &kif, sizeof(kif));
+
+	link_new = (ifp->flags & IFF_UP) && (ifp->flags & IFF_RUNNING);
+	if (link_new) {
+		for (ALL_LIST_ELEMENTS_RO(ifp->connected, node, ifc)) {
+			ifc2kaddr(ifp, ifc, &ka);
+			main_imsg_compose_ldpe(IMSG_NEWADDR, 0, &ka,
+			    sizeof(ka));
+		}
+	} else {
+		for (ALL_LIST_ELEMENTS_RO(ifp->connected, node, ifc)) {
+			ifc2kaddr(ifp, ifc, &ka);
+			main_imsg_compose_ldpe(IMSG_DELADDR, 0, &ka,
+			    sizeof(ka));
+		}
+	}
+
+	return (0);
+}
+
+static int
+ldp_interface_address_add(int command, struct zclient *zclient,
+    zebra_size_t length, vrf_id_t vrf_id)
+{
+	struct connected	*ifc;
+	struct interface	*ifp;
+	struct kaddr		 ka;
+
+	ifc = zebra_interface_address_read(command, zclient->ibuf, vrf_id);
+	if (ifc == NULL)
+		return (0);
+
+	ifp = ifc->ifp;
+	ifc2kaddr(ifp, ifc, &ka);
+
+	/* Filter invalid addresses.  */
+	if (bad_addr(ka.af, &ka.addr))
+		return (0);
+
+	log_debug("zebra: address add %s/%u", log_addr(ka.af, &ka.addr),
+	    ka.prefixlen);
+
+	/* notify ldpe about new address */
+	main_imsg_compose_ldpe(IMSG_NEWADDR, 0, &ka, sizeof(ka));
+
+	return (0);
+}
+
+static int
+ldp_interface_address_delete(int command, struct zclient *zclient,
+    zebra_size_t length, vrf_id_t vrf_id)
+{
+	struct connected	*ifc;
+	struct interface	*ifp;
+	struct kaddr		 ka;
+
+	ifc = zebra_interface_address_read(command, zclient->ibuf, vrf_id);
+	if (ifc == NULL)
+		return (0);
+
+	ifp = ifc->ifp;
+	ifc2kaddr(ifp, ifc, &ka);
+	connected_free(ifc);
+
+	/* Filter invalid addresses.  */
+	if (bad_addr(ka.af, &ka.addr))
+		return (0);
+
+	log_debug("zebra: address delete %s/%u", log_addr(ka.af, &ka.addr),
+	    ka.prefixlen);
+
+	/* notify ldpe about removed address */
+	main_imsg_compose_ldpe(IMSG_DELADDR, 0, &ka, sizeof(ka));
+
+	return (0);
+}
+
+static int
+ldp_zebra_read_route(int command, struct zclient *zclient, zebra_size_t length,
+    vrf_id_t vrf_id)
+{
+	struct stream		*s;
+	u_char			 type;
+	u_char			 flags, message_flags;
+	struct kroute		 kr;
+
+	memset(&kr, 0, sizeof(kr));
+	s = zclient->ibuf;
+
+	type = stream_getc(s);
+	flags = stream_getc(s);
+	message_flags = stream_getc(s);
+
+	switch (command) {
+	case ZEBRA_IPV4_ROUTE_ADD:
+	case ZEBRA_IPV4_ROUTE_DELETE:
+		kr.af = AF_INET;
+		break;
+	case ZEBRA_IPV6_ROUTE_ADD:
+	case ZEBRA_IPV6_ROUTE_DELETE:
+		kr.af = AF_INET6;
+		break;
+	default:
+		fatalx("ldp_zebra_read_route: unknown command");
+	}
+	kr.prefixlen = stream_getc(s);
+	stream_get(&kr.prefix, s, PSIZE(kr.prefixlen));
+
+	if (bad_addr(kr.af, &kr.prefix) ||
+	    (kr.af == AF_INET6 && IN6_IS_SCOPE_EMBED(&kr.prefix.v6)))
+		return (0);
+
+	/*
+	 * Consider networks with nexthop loopback as not redistributable
+	 * unless it is a reject or blackhole route.
+	 */
+	if (CHECK_FLAG(message_flags, ZAPI_MESSAGE_NEXTHOP)) {
+		stream_getc(s);	/* nexthop_num, unused. */
+		switch (kr.af) {
+		case AF_INET:
+			kr.nexthop.v4.s_addr = stream_get_ipv4(s);
+
+			if (kr.nexthop.v4.s_addr == htonl(INADDR_LOOPBACK) &&
+			    (CHECK_FLAG(flags, ZEBRA_FLAG_BLACKHOLE)
+			    || CHECK_FLAG(flags, ZEBRA_FLAG_REJECT)))
+				return (0);
+			break;
+		case AF_INET6:
+			stream_get(&kr.nexthop.v6, s, sizeof(kr.nexthop.v6));
+
+			if (IN6_IS_ADDR_LOOPBACK(&kr.nexthop.v6) &&
+			    (CHECK_FLAG(flags, ZEBRA_FLAG_BLACKHOLE)
+			    || CHECK_FLAG(flags, ZEBRA_FLAG_REJECT)))
+				return (0);
+			break;
+		default:
+			break;
+		}
+	}
+	if (CHECK_FLAG(message_flags, ZAPI_MESSAGE_IFINDEX)) {
+		stream_getc(s);	/* ifindex_num, unused. */
+		kr.ifindex = stream_getl(s);
+	}
+
+	if (CHECK_FLAG(message_flags, ZAPI_MESSAGE_DISTANCE))
+		kr.priority = stream_getc(s);
+	if (CHECK_FLAG(message_flags, ZAPI_MESSAGE_METRIC))
+		stream_getl(s);	/* metric, not used */
+
+	if (type == ZEBRA_ROUTE_CONNECT)
+		kr.flags |= F_CONNECTED;
+
+	switch (command) {
+	case ZEBRA_IPV4_ROUTE_ADD:
+	case ZEBRA_IPV6_ROUTE_ADD:
+		log_debug("zebra: route add %s/%d nexthop %s (%s)",
+		    log_addr(kr.af, &kr.prefix), kr.prefixlen,
+		    log_addr(kr.af, &kr.nexthop),
+		    zebra_route_string(type));
+		main_imsg_compose_lde(IMSG_NETWORK_ADD, 0, &kr, sizeof(kr));
+		break;
+	case ZEBRA_IPV4_ROUTE_DELETE:
+	case ZEBRA_IPV6_ROUTE_DELETE:
+		log_debug("zebra: route delete %s/%d nexthop %s (%s)",
+		    log_addr(kr.af, &kr.prefix), kr.prefixlen,
+		    log_addr(kr.af, &kr.nexthop),
+		    zebra_route_string(type));
+		main_imsg_compose_lde(IMSG_NETWORK_DEL, 0, &kr, sizeof(kr));
+		break;
+	default:
+		fatalx("ldp_zebra_read_route: unknown command");
+	}
+
+	return (0);
+}
+
+static void
+ldp_zebra_connected(struct zclient *zclient)
+{
+	int	i;
+
+	zclient_send_requests(zclient, VRF_DEFAULT);
+
+	for (i = 0; i < ZEBRA_ROUTE_MAX; i++) {
+		switch (i) {
+		case ZEBRA_ROUTE_KERNEL:
+		case ZEBRA_ROUTE_CONNECT:
+		case ZEBRA_ROUTE_STATIC:
+		case ZEBRA_ROUTE_RIP:
+		case ZEBRA_ROUTE_RIPNG:
+		case ZEBRA_ROUTE_OSPF:
+		case ZEBRA_ROUTE_OSPF6:
+		case ZEBRA_ROUTE_ISIS:
+			zclient_redistribute(ZEBRA_REDISTRIBUTE_ADD, zclient,
+			    i, VRF_DEFAULT);
+			break;
+		case ZEBRA_ROUTE_BGP:
+		default:
+			/* LDP should follow the IGP and ignore BGP routes */
+			break;
+		}
+	}
+}
+
+void
+ldp_zebra_init(struct thread_master *master)
+{
+	/* Set default values. */
+	zclient = zclient_new(master);
+	zclient_init(zclient, ZEBRA_ROUTE_LDP);
+
+	/* set callbacks */
+	zclient->zebra_connected = ldp_zebra_connected;
+	zclient->router_id_update = ldp_router_id_update;
+	zclient->interface_add = ldp_interface_add;
+	zclient->interface_delete = ldp_interface_delete;
+	zclient->interface_up = ldp_interface_status_change;
+	zclient->interface_down = ldp_interface_status_change;
+	zclient->interface_address_add = ldp_interface_address_add;
+	zclient->interface_address_delete = ldp_interface_address_delete;
+	zclient->ipv4_route_add = ldp_zebra_read_route;
+	zclient->ipv4_route_delete = ldp_zebra_read_route;
+	zclient->ipv6_route_add = ldp_zebra_read_route;
+	zclient->ipv6_route_delete = ldp_zebra_read_route;
+}
diff --git a/ldpd/ldpd.c b/ldpd/ldpd.c
new file mode 100644
index 0000000..975b72c
--- /dev/null
+++ b/ldpd/ldpd.c
@@ -0,0 +1,1696 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2005 Claudio Jeker <claudio@openbsd.org>
+ * Copyright (c) 2004, 2008 Esben Norby <norby@openbsd.org>
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+#include <sys/wait.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "lde.h"
+#include "log.h"
+#include "ldp_vty.h"
+
+#include <lib/version.h>
+#include <lib/log.h>
+#include "getopt.h"
+#include "vty.h"
+#include "command.h"
+#include "memory.h"
+#include "privs.h"
+#include "sigevent.h"
+#include "zclient.h"
+#include "vrf.h"
+
+static void		 ldpd_shutdown(void);
+static pid_t		 start_child(enum ldpd_process, char *, int);
+static int		 check_child(pid_t, const char *);
+static int		 main_dispatch_ldpe(struct thread *);
+static int		 main_dispatch_lde(struct thread *);
+static int		 main_imsg_compose_both(enum imsg_type, void *,
+			    uint16_t);
+static int		 main_imsg_send_ipc_sockets(struct imsgbuf *,
+			    struct imsgbuf *);
+static void		 main_imsg_send_net_sockets(int);
+static void		 main_imsg_send_net_socket(int, enum socket_type);
+static int		 main_imsg_send_config(struct ldpd_conf *);
+static void		 merge_global(struct ldpd_conf *, struct ldpd_conf *);
+static void		 merge_af(int, struct ldpd_af_conf *,
+			    struct ldpd_af_conf *);
+static void		 merge_ifaces(struct ldpd_conf *, struct ldpd_conf *);
+static void		 merge_iface_af(struct iface_af *, struct iface_af *);
+static void		 merge_tnbrs(struct ldpd_conf *, struct ldpd_conf *);
+static void		 merge_nbrps(struct ldpd_conf *, struct ldpd_conf *);
+static void		 merge_l2vpns(struct ldpd_conf *, struct ldpd_conf *);
+static void		 merge_l2vpn(struct ldpd_conf *, struct l2vpn *,
+			    struct l2vpn *);
+
+struct ldpd_global	 global;
+struct ldpd_conf	*ldpd_conf;
+
+static struct imsgev	*iev_ldpe;
+static struct imsgev	*iev_lde;
+static pid_t		 ldpe_pid;
+static pid_t		 lde_pid;
+
+#define LDP_DEFAULT_CONFIG	"ldpd.conf"
+#define LDP_VTY_PORT		2612
+
+/* Master of threads. */
+struct thread_master *master;
+
+/* Process ID saved for use by init system */
+static const char *pid_file = PATH_LDPD_PID;
+
+/* Configuration filename and directory. */
+static char config_default[] = SYSCONFDIR LDP_DEFAULT_CONFIG;
+
+/* ldpd privileges */
+static zebra_capabilities_t _caps_p [] =
+{
+	ZCAP_BIND,
+	ZCAP_NET_ADMIN
+};
+
+struct zebra_privs_t ldpd_privs =
+{
+#if defined(QUAGGA_USER) && defined(QUAGGA_GROUP)
+	.user = QUAGGA_USER,
+	.group = QUAGGA_GROUP,
+#endif
+#if defined(VTY_GROUP)
+	.vty_group = VTY_GROUP,
+#endif
+	.caps_p = _caps_p,
+	.cap_num_p = array_size(_caps_p),
+	.cap_num_i = 0
+};
+
+/* LDPd options. */
+static struct option longopts[] =
+{
+	{ "daemon",      no_argument,       NULL, 'd'},
+	{ "config_file", required_argument, NULL, 'f'},
+	{ "pid_file",    required_argument, NULL, 'i'},
+	{ "socket",      required_argument, NULL, 'z'},
+	{ "dryrun",      no_argument,       NULL, 'C'},
+	{ "help",        no_argument,       NULL, 'h'},
+	{ "vty_addr",    required_argument, NULL, 'A'},
+	{ "vty_port",    required_argument, NULL, 'P'},
+	{ "user",        required_argument, NULL, 'u'},
+	{ "group",       required_argument, NULL, 'g'},
+	{ "version",     no_argument,       NULL, 'v'},
+	{ 0 }
+};
+
+/* Help information display. */
+static void __attribute__ ((noreturn))
+usage(char *progname, int status)
+{
+	if (status != 0)
+		fprintf(stderr, "Try `%s --help' for more information.\n",
+		    progname);
+	else {
+		printf("Usage : %s [OPTION...]\n\
+Daemon which manages LDP.\n\n\
+-d, --daemon       Runs in daemon mode\n\
+-f, --config_file  Set configuration file name\n\
+-i, --pid_file     Set process identifier file name\n\
+-z, --socket       Set path of zebra socket\n\
+-A, --vty_addr     Set vty's bind address\n\
+-P, --vty_port     Set vty's port number\n\
+-u, --user         User to run as\n\
+-g, --group        Group to run as\n\
+-v, --version      Print program version\n\
+-C, --dryrun       Check configuration for validity and exit\n\
+-h, --help         Display this help and exit\n\
+\n\
+Report bugs to %s\n", progname, ZEBRA_BUG_ADDRESS);
+	}
+
+	exit(status);
+}
+
+/* SIGHUP handler. */
+static void
+sighup(void)
+{
+	log_info("SIGHUP received");
+}
+
+/* SIGINT / SIGTERM handler. */
+static void
+sigint(void)
+{
+	log_notice("Terminating on signal");
+
+	if (check_child(ldpe_pid, "ldp engine"))
+		ldpe_pid = 0;
+	if (check_child(lde_pid, "label decision engine"))
+		lde_pid = 0;
+
+	ldpd_shutdown();
+}
+
+/* SIGCHLD handler. */
+static void
+sigchld(void)
+{
+	int	die = 0;
+
+	log_info("SIGCHLD received");
+
+	if (check_child(ldpe_pid, "ldp engine")) {
+		ldpe_pid = 0;
+		die = 1;
+	}
+	if (check_child(lde_pid, "label decision engine")) {
+		lde_pid = 0;
+		die = 1;
+	}
+	if (die)
+		ldpd_shutdown();
+}
+
+/* SIGUSR1 handler. */
+static void
+sigusr1(void)
+{
+	zlog_rotate(NULL);
+}
+
+static struct quagga_signal_t ldp_signals[] =
+{
+	{
+		.signal = SIGHUP,
+		.handler = &sighup,
+	},
+	{
+		.signal = SIGINT,
+		.handler = &sigint,
+	},
+	{
+		.signal = SIGTERM,
+		.handler = &sigint,
+	},
+	{
+		.signal = SIGCHLD,
+		.handler = &sigchld,
+	},
+	{
+		.signal = SIGUSR1,
+		.handler = &sigusr1,
+	}
+};
+
+int
+main(int argc, char *argv[])
+{
+	char			*saved_argv0;
+	int			 lflag = 0, eflag = 0;
+	int			 pipe_parent2ldpe[2];
+	int			 pipe_parent2lde[2];
+	char			*p;
+	char			*vty_addr = NULL;
+	int			 vty_port = LDP_VTY_PORT;
+	int			 daemon_mode = 0;
+	char			*config_file = NULL;
+	char			*progname;
+	struct thread		 thread;
+	int			 dryrun = 0;
+
+	ldpd_process = PROC_MAIN;
+
+	/* Set umask before anything for security */
+	umask(0027);
+
+	/* get program name */
+	progname = ((p = strrchr(argv[0], '/')) ? ++p : argv[0]);
+
+	saved_argv0 = argv[0];
+	if (saved_argv0 == NULL)
+		saved_argv0 = (char *)"ldpd";
+
+	while (1) {
+		int opt;
+
+		opt = getopt_long(argc, argv, "df:i:z:hA:P:u:g:vCLE",
+		    longopts, 0);
+
+		if (opt == EOF)
+			break;
+
+		switch (opt) {
+		case 0:
+			break;
+		case 'd':
+			daemon_mode = 1;
+			break;
+		case 'f':
+			config_file = optarg;
+			break;
+		case 'A':
+			vty_addr = optarg;
+			break;
+		case 'i':
+			pid_file = optarg;
+			break;
+		case 'z':
+			zclient_serv_path_set(optarg);
+			break;
+		case 'P':
+			/*
+			 * Deal with atoi() returning 0 on failure, and ldpd
+			 * not listening on ldpd port.
+			 */
+			if (strcmp(optarg, "0") == 0) {
+				vty_port = 0;
+				break;
+			}
+			vty_port = atoi(optarg);
+			if (vty_port <= 0 || vty_port > 0xffff)
+				vty_port = LDP_VTY_PORT;
+			break;
+		case 'u':
+			ldpd_privs.user = optarg;
+			break;
+		case 'g':
+			ldpd_privs.group = optarg;
+			break;
+		case 'v':
+			print_version(progname);
+			exit(0);
+			break;
+		case 'C':
+			dryrun = 1;
+			break;
+		case 'h':
+			usage(progname, 0);
+			break;
+		case 'L':
+			lflag = 1;
+			break;
+		case 'E':
+			eflag = 1;
+			break;
+		default:
+			usage(progname, 1);
+			break;
+		}
+	}
+
+	argc -= optind;
+	argv += optind;
+	if (argc > 0 || (lflag && eflag))
+		usage(progname, 1);
+
+	zlog_default = openzlog(progname, ZLOG_LDP,
+	    LOG_CONS | LOG_NDELAY | LOG_PID, LOG_DAEMON);
+
+	if (lflag)
+		lde();
+	else if (eflag)
+		ldpe();
+
+  	master = thread_master_create();
+
+	cmd_init(1);
+	vty_init(master);
+	vrf_init();
+	ldp_vty_init();
+	ldp_vty_if_init();
+
+	/* Get configuration file. */
+	ldpd_conf = config_new_empty();
+	ldp_reset_main_conf(ldpd_conf);
+	vty_read_config(config_file, config_default);
+
+	/* Start execution only if not in dry-run mode */
+	if (dryrun)
+		exit(0);
+
+	/* check for root privileges  */
+	if (geteuid() != 0) {
+		errno = EPERM;
+		perror(progname);
+		exit(1);
+	}
+
+	if (daemon_mode && daemon(0, 0) < 0) {
+		log_warn("LDPd daemon failed");
+		exit(1);
+	}
+
+	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2ldpe) == -1)
+		fatal("socketpair");
+	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2lde) == -1)
+		fatal("socketpair");
+	sock_set_blockmode(pipe_parent2ldpe[0], BM_NONBLOCK);
+	sock_set_blockmode(pipe_parent2ldpe[1], BM_NONBLOCK);
+	sock_set_blockmode(pipe_parent2lde[0], BM_NONBLOCK);
+	sock_set_blockmode(pipe_parent2lde[1], BM_NONBLOCK);
+
+	/* start children */
+	lde_pid = start_child(PROC_LDE_ENGINE, saved_argv0,
+	    pipe_parent2lde[1]);
+	ldpe_pid = start_child(PROC_LDP_ENGINE, saved_argv0,
+	    pipe_parent2ldpe[1]);
+
+	/* setup signal handler */
+	signal_init(master, array_size(ldp_signals), ldp_signals);
+
+	/* drop privileges */
+	zprivs_init(&ldpd_privs);
+
+	/* library inits */
+	ldp_zebra_init(master);
+
+	/* setup pipes to children */
+	if ((iev_ldpe = malloc(sizeof(struct imsgev))) == NULL ||
+	    (iev_lde = malloc(sizeof(struct imsgev))) == NULL)
+		fatal(NULL);
+	imsg_init(&iev_ldpe->ibuf, pipe_parent2ldpe[0]);
+	iev_ldpe->handler_read = main_dispatch_ldpe;
+	iev_ldpe->ev_read = thread_add_read(master, iev_ldpe->handler_read,
+	    iev_ldpe, iev_ldpe->ibuf.fd);
+	iev_ldpe->handler_write = ldp_write_handler;
+	iev_ldpe->ev_write = NULL;
+
+	imsg_init(&iev_lde->ibuf, pipe_parent2lde[0]);
+	iev_lde->handler_read = main_dispatch_lde;
+	iev_lde->ev_read = thread_add_read(master, iev_lde->handler_read,
+	    iev_lde, iev_lde->ibuf.fd);
+	iev_lde->handler_write = ldp_write_handler;
+	iev_lde->ev_write = NULL;
+
+	if (main_imsg_send_ipc_sockets(&iev_ldpe->ibuf, &iev_lde->ibuf))
+		fatal("could not establish imsg links");
+	main_imsg_send_config(ldpd_conf);
+
+	main_imsg_send_net_sockets(AF_INET);
+	main_imsg_send_net_sockets(AF_INET6);
+
+	/* Process id file create. */
+	pid_output(pid_file);
+
+	/* Create VTY socket */
+	vty_serv_sock(vty_addr, vty_port, LDP_VTYSH_PATH);
+
+	/* Print banner. */
+	log_notice("LDPd %s starting: vty@%d", QUAGGA_VERSION, vty_port);
+
+	/* Fetch next active thread. */
+	while (thread_fetch(master, &thread))
+		thread_call(&thread);
+
+	/* NOTREACHED */
+	return (0);
+}
+
+static void
+ldpd_shutdown(void)
+{
+	pid_t		 pid;
+
+	if (ldpe_pid)
+		kill(ldpe_pid, SIGTERM);
+
+	if (lde_pid)
+		kill(lde_pid, SIGTERM);
+
+	do {
+		if ((pid = wait(NULL)) == -1 &&
+		    errno != EINTR && errno != ECHILD)
+			fatal("wait");
+	} while (pid != -1 || (pid == -1 && errno == EINTR));
+
+	config_clear(ldpd_conf);
+
+	msgbuf_clear(&iev_ldpe->ibuf.w);
+	free(iev_ldpe);
+	msgbuf_clear(&iev_lde->ibuf.w);
+	free(iev_lde);
+
+	log_info("terminating");
+	exit(0);
+}
+
+static pid_t
+start_child(enum ldpd_process p, char *argv0, int fd)
+{
+	char	*argv[3];
+	int	 argc = 0;
+	pid_t	 pid;
+
+	switch (pid = fork()) {
+	case -1:
+		fatal("cannot fork");
+	case 0:
+		break;
+	default:
+		close(fd);
+		return (pid);
+	}
+
+	if (dup2(fd, 3) == -1)
+		fatal("cannot setup imsg fd");
+
+	argv[argc++] = argv0;
+	switch (p) {
+	case PROC_MAIN:
+		fatalx("Can not start main process");
+	case PROC_LDE_ENGINE:
+		argv[argc++] = (char *)"-L";
+		break;
+	case PROC_LDP_ENGINE:
+		argv[argc++] = (char *)"-E";
+		break;
+	}
+	argv[argc++] = NULL;
+
+	execvp(argv0, argv);
+	fatal("execvp");
+}
+
+static int
+check_child(pid_t pid, const char *pname)
+{
+	int	status;
+
+	if (waitpid(pid, &status, WNOHANG) > 0) {
+		if (WIFEXITED(status)) {
+			log_warnx("lost child: %s exited", pname);
+			return (1);
+		}
+		if (WIFSIGNALED(status)) {
+			log_warnx("lost child: %s terminated; signal %d",
+			    pname, WTERMSIG(status));
+			return (1);
+		}
+	}
+
+	return (0);
+}
+
+/* imsg handling */
+/* ARGSUSED */
+static int
+main_dispatch_ldpe(struct thread *thread)
+{
+	struct imsgev		*iev = THREAD_ARG(thread);
+	struct imsgbuf		*ibuf = &iev->ibuf;
+	struct imsg		 imsg;
+	int			 af;
+	ssize_t			 n;
+	int			 shut = 0;
+
+	iev->ev_read = NULL;
+
+	if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
+		fatal("imsg_read error");
+	if (n == 0)	/* connection closed */
+		shut = 1;
+
+	for (;;) {
+		if ((n = imsg_get(ibuf, &imsg)) == -1)
+			fatal("imsg_get");
+
+		if (n == 0)
+			break;
+
+		switch (imsg.hdr.type) {
+		case IMSG_REQUEST_SOCKETS:
+			af = imsg.hdr.pid;
+			main_imsg_send_net_sockets(af);
+			break;
+		default:
+			log_debug("%s: error handling imsg %d", __func__,
+			    imsg.hdr.type);
+			break;
+		}
+		imsg_free(&imsg);
+	}
+	if (!shut)
+		imsg_event_add(iev);
+	else {
+		/* this pipe is dead, so remove the event handlers and exit */
+		THREAD_READ_OFF(iev->ev_read);
+		THREAD_WRITE_OFF(iev->ev_write);
+		ldpd_shutdown();
+	}
+
+	return (0);
+}
+
+/* ARGSUSED */
+static int
+main_dispatch_lde(struct thread *thread)
+{
+	struct imsgev	*iev = THREAD_ARG(thread);
+	struct imsgbuf	*ibuf = &iev->ibuf;
+	struct imsg	 imsg;
+	ssize_t		 n;
+	int		 shut = 0;
+
+	iev->ev_read = NULL;
+
+	if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
+		fatal("imsg_read error");
+	if (n == 0)	/* connection closed */
+		shut = 1;
+
+	for (;;) {
+		if ((n = imsg_get(ibuf, &imsg)) == -1)
+			fatal("imsg_get");
+
+		if (n == 0)
+			break;
+
+		switch (imsg.hdr.type) {
+		case IMSG_KLABEL_CHANGE:
+			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
+			    sizeof(struct kroute))
+				fatalx("invalid size of IMSG_KLABEL_CHANGE");
+			if (kr_change(imsg.data))
+				log_warn("%s: error changing route", __func__);
+			break;
+		case IMSG_KLABEL_DELETE:
+			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
+			    sizeof(struct kroute))
+				fatalx("invalid size of IMSG_KLABEL_DELETE");
+			if (kr_delete(imsg.data))
+				log_warn("%s: error deleting route", __func__);
+			break;
+		case IMSG_KPWLABEL_CHANGE:
+			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
+			    sizeof(struct kpw))
+				fatalx("invalid size of IMSG_KPWLABEL_CHANGE");
+			if (kmpw_set(imsg.data))
+				log_warn("%s: error changing pseudowire",
+				    __func__);
+			break;
+		case IMSG_KPWLABEL_DELETE:
+			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
+			    sizeof(struct kpw))
+				fatalx("invalid size of IMSG_KPWLABEL_DELETE");
+			if (kmpw_unset(imsg.data))
+				log_warn("%s: error unsetting pseudowire",
+				    __func__);
+			break;
+		default:
+			log_debug("%s: error handling imsg %d", __func__,
+			    imsg.hdr.type);
+			break;
+		}
+		imsg_free(&imsg);
+	}
+	if (!shut)
+		imsg_event_add(iev);
+	else {
+		/* this pipe is dead, so remove the event handlers and exit */
+		THREAD_READ_OFF(iev->ev_read);
+		THREAD_WRITE_OFF(iev->ev_write);
+		ldpd_shutdown();
+	}
+
+	return (0);
+}
+
+/* ARGSUSED */
+int
+ldp_write_handler(struct thread *thread)
+{
+	struct imsgev	*iev = THREAD_ARG(thread);
+	struct imsgbuf	*ibuf = &iev->ibuf;
+	ssize_t		 n;
+
+	iev->ev_write = NULL;
+
+	if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
+		fatal("msgbuf_write");
+	if (n == 0) {
+		/* this pipe is dead, so remove the event handlers */
+		THREAD_READ_OFF(iev->ev_read);
+		THREAD_WRITE_OFF(iev->ev_write);
+		return (0);
+	}
+
+	imsg_event_add(iev);
+
+	return (0);
+}
+
+void
+main_imsg_compose_ldpe(int type, pid_t pid, void *data, uint16_t datalen)
+{
+	if (iev_ldpe == NULL)
+		return;
+	imsg_compose_event(iev_ldpe, type, 0, pid, -1, data, datalen);
+}
+
+void
+main_imsg_compose_lde(int type, pid_t pid, void *data, uint16_t datalen)
+{
+	imsg_compose_event(iev_lde, type, 0, pid, -1, data, datalen);
+}
+
+static int
+main_imsg_compose_both(enum imsg_type type, void *buf, uint16_t len)
+{
+	if (iev_ldpe == NULL || iev_lde == NULL)
+		return (0);
+	if (imsg_compose_event(iev_ldpe, type, 0, 0, -1, buf, len) == -1)
+		return (-1);
+	if (imsg_compose_event(iev_lde, type, 0, 0, -1, buf, len) == -1)
+		return (-1);
+	return (0);
+}
+
+void
+imsg_event_add(struct imsgev *iev)
+{
+	THREAD_READ_ON(master, iev->ev_read, iev->handler_read, iev,
+	    iev->ibuf.fd);
+
+	if (iev->ibuf.w.queued)
+		THREAD_WRITE_ON(master, iev->ev_write, iev->handler_write, iev,
+		    iev->ibuf.fd);
+}
+
+int
+imsg_compose_event(struct imsgev *iev, uint16_t type, uint32_t peerid,
+    pid_t pid, int fd, void *data, uint16_t datalen)
+{
+	int	ret;
+
+	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
+	    pid, fd, data, datalen)) != -1)
+		imsg_event_add(iev);
+	return (ret);
+}
+
+void
+evbuf_enqueue(struct evbuf *eb, struct ibuf *buf)
+{
+	ibuf_close(&eb->wbuf, buf);
+	evbuf_event_add(eb);
+}
+
+void
+evbuf_event_add(struct evbuf *eb)
+{
+	if (eb->wbuf.queued)
+		THREAD_WRITE_ON(master, eb->ev, eb->handler, eb->arg,
+		    eb->wbuf.fd);
+}
+
+void
+evbuf_init(struct evbuf *eb, int fd, int (*handler)(struct thread *),
+    void *arg)
+{
+	msgbuf_init(&eb->wbuf);
+	eb->wbuf.fd = fd;
+	eb->handler = handler;
+	eb->arg = arg;
+}
+
+void
+evbuf_clear(struct evbuf *eb)
+{
+	THREAD_WRITE_OFF(eb->ev);
+	msgbuf_clear(&eb->wbuf);
+	eb->wbuf.fd = -1;
+}
+
+static int
+main_imsg_send_ipc_sockets(struct imsgbuf *ldpe_buf, struct imsgbuf *lde_buf)
+{
+	int pipe_ldpe2lde[2];
+
+	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_ldpe2lde) == -1)
+		return (-1);
+	sock_set_blockmode(pipe_ldpe2lde[0], BM_NONBLOCK);
+	sock_set_blockmode(pipe_ldpe2lde[1], BM_NONBLOCK);
+
+	if (imsg_compose(ldpe_buf, IMSG_SOCKET_IPC, 0, 0, pipe_ldpe2lde[0],
+	    NULL, 0) == -1)
+		return (-1);
+	if (imsg_compose(lde_buf, IMSG_SOCKET_IPC, 0, 0, pipe_ldpe2lde[1],
+	    NULL, 0) == -1)
+		return (-1);
+
+	return (0);
+}
+
+static void
+main_imsg_send_net_sockets(int af)
+{
+	if (!ldp_addrisset(af, &(ldp_af_conf_get(ldpd_conf, af))->trans_addr))
+		return;
+
+	main_imsg_send_net_socket(af, LDP_SOCKET_DISC);
+	main_imsg_send_net_socket(af, LDP_SOCKET_EDISC);
+	main_imsg_send_net_socket(af, LDP_SOCKET_SESSION);
+	imsg_compose_event(iev_ldpe, IMSG_SETUP_SOCKETS, af, 0, -1, NULL, 0);
+}
+
+static void
+main_imsg_send_net_socket(int af, enum socket_type type)
+{
+	int			 fd;
+
+	fd = ldp_create_socket(af, type);
+	if (fd == -1) {
+		log_warnx("%s: failed to create %s socket for address-family "
+		    "%s", __func__, socket_name(type), af_name(af));
+		return;
+	}
+
+	imsg_compose_event(iev_ldpe, IMSG_SOCKET_NET, af, 0, fd, &type,
+	    sizeof(type));
+}
+
+struct ldpd_af_conf *
+ldp_af_conf_get(struct ldpd_conf *xconf, int af)
+{
+	switch (af) {
+	case AF_INET:
+		return (&xconf->ipv4);
+	case AF_INET6:
+		return (&xconf->ipv6);
+	default:
+		fatalx("ldp_af_conf_get: unknown af");
+	}
+}
+
+struct ldpd_af_global *
+ldp_af_global_get(struct ldpd_global *xglobal, int af)
+{
+	switch (af) {
+	case AF_INET:
+		return (&xglobal->ipv4);
+	case AF_INET6:
+		return (&xglobal->ipv6);
+	default:
+		fatalx("ldp_af_global_get: unknown af");
+	}
+}
+
+int
+ldp_is_dual_stack(struct ldpd_conf *xconf)
+{
+	return ((xconf->ipv4.flags & F_LDPD_AF_ENABLED) &&
+	    (xconf->ipv6.flags & F_LDPD_AF_ENABLED));
+}
+
+in_addr_t
+ldp_rtr_id_get(struct ldpd_conf *xconf)
+{
+	if (xconf->rtr_id.s_addr != INADDR_ANY)
+		return (xconf->rtr_id.s_addr);
+	else
+		return (global.rtr_id.s_addr);
+}
+
+static int
+main_imsg_send_config(struct ldpd_conf *xconf)
+{
+	struct iface		*iface;
+	struct tnbr		*tnbr;
+	struct nbr_params	*nbrp;
+	struct l2vpn		*l2vpn;
+	struct l2vpn_if		*lif;
+	struct l2vpn_pw		*pw;
+
+	if (main_imsg_compose_both(IMSG_RECONF_CONF, xconf,
+	    sizeof(*xconf)) == -1)
+		return (-1);
+
+	LIST_FOREACH(iface, &xconf->iface_list, entry) {
+		if (main_imsg_compose_both(IMSG_RECONF_IFACE, iface,
+		    sizeof(*iface)) == -1)
+			return (-1);
+	}
+
+	LIST_FOREACH(tnbr, &xconf->tnbr_list, entry) {
+		if (main_imsg_compose_both(IMSG_RECONF_TNBR, tnbr,
+		    sizeof(*tnbr)) == -1)
+			return (-1);
+	}
+
+	LIST_FOREACH(nbrp, &xconf->nbrp_list, entry) {
+		if (main_imsg_compose_both(IMSG_RECONF_NBRP, nbrp,
+		    sizeof(*nbrp)) == -1)
+			return (-1);
+	}
+
+	LIST_FOREACH(l2vpn, &xconf->l2vpn_list, entry) {
+		if (main_imsg_compose_both(IMSG_RECONF_L2VPN, l2vpn,
+		    sizeof(*l2vpn)) == -1)
+			return (-1);
+
+		LIST_FOREACH(lif, &l2vpn->if_list, entry) {
+			if (main_imsg_compose_both(IMSG_RECONF_L2VPN_IF, lif,
+			    sizeof(*lif)) == -1)
+				return (-1);
+		}
+		LIST_FOREACH(pw, &l2vpn->pw_list, entry) {
+			if (main_imsg_compose_both(IMSG_RECONF_L2VPN_PW, pw,
+			    sizeof(*pw)) == -1)
+				return (-1);
+		}
+		LIST_FOREACH(pw, &l2vpn->pw_inactive_list, entry) {
+			if (main_imsg_compose_both(IMSG_RECONF_L2VPN_IPW, pw,
+			    sizeof(*pw)) == -1)
+				return (-1);
+		}
+	}
+
+	if (main_imsg_compose_both(IMSG_RECONF_END, NULL, 0) == -1)
+		return (-1);
+
+	return (0);
+}
+
+int
+ldp_reload(struct ldpd_conf *xconf)
+{
+	if (main_imsg_send_config(xconf) == -1)
+		return (-1);
+
+	merge_config(ldpd_conf, xconf);
+
+	return (0);
+}
+
+void
+ldp_reset_main_conf(struct ldpd_conf *conf)
+{
+	struct iface		*iface;
+	struct nbr_params	*nbrp;
+
+	while ((iface = LIST_FIRST(&conf->iface_list)) != NULL) {
+		LIST_REMOVE(iface, entry);
+		free(iface);
+	}
+
+	while ((nbrp = LIST_FIRST(&conf->nbrp_list)) != NULL) {
+		LIST_REMOVE(nbrp, entry);
+		free(nbrp);
+	}
+
+	conf->rtr_id.s_addr = INADDR_ANY;
+	ldp_reset_af_conf(conf, AF_INET);
+	ldp_reset_af_conf(conf, AF_INET6);
+	conf->lhello_holdtime = LINK_DFLT_HOLDTIME;
+	conf->lhello_interval = DEFAULT_HELLO_INTERVAL;
+	conf->thello_holdtime = TARGETED_DFLT_HOLDTIME;
+	conf->thello_interval = DEFAULT_HELLO_INTERVAL;
+	conf->trans_pref = DUAL_STACK_LDPOV6;
+	conf->flags = 0;
+}
+
+void
+ldp_reset_af_conf(struct ldpd_conf *conf, int af)
+{
+	struct ldpd_af_conf	*af_conf;
+	struct iface		*iface;
+	struct iface_af		*ia;
+	struct tnbr		*tnbr, *ttmp;
+
+	LIST_FOREACH(iface, &conf->iface_list, entry) {
+		ia = iface_af_get(iface, af);
+		ia->enabled = 0;
+	}
+
+	LIST_FOREACH_SAFE(tnbr, &conf->tnbr_list, entry, ttmp) {
+		if (tnbr->af != af)
+			continue;
+
+		LIST_REMOVE(tnbr, entry);
+		free(tnbr);
+	}
+
+	af_conf = ldp_af_conf_get(conf, af);
+	af_conf->keepalive = 180;
+	af_conf->lhello_holdtime = 0;
+	af_conf->lhello_interval = 0;
+	af_conf->thello_holdtime = 0;
+	af_conf->thello_interval = 0;
+	memset(&af_conf->trans_addr, 0, sizeof(af_conf->trans_addr));
+	af_conf->flags = 0;
+}
+
+struct ldpd_conf *
+ldp_dup_config(struct ldpd_conf *conf)
+{
+	struct ldpd_conf	*xconf;
+	struct iface		*iface, *xi;
+	struct tnbr		*tnbr, *xt;
+	struct nbr_params	*nbrp, *xn;
+	struct l2vpn		*l2vpn, *xl;
+	struct l2vpn_if		*lif, *xf;
+	struct l2vpn_pw		*pw, *xp;
+
+	xconf = malloc(sizeof(*xconf));
+	*xconf = *conf;
+	LIST_INIT(&xconf->iface_list);
+	LIST_INIT(&xconf->tnbr_list);
+	LIST_INIT(&xconf->nbrp_list);
+	LIST_INIT(&xconf->l2vpn_list);
+
+	LIST_FOREACH(iface, &conf->iface_list, entry) {
+		xi = calloc(1, sizeof(*xi));
+		if (xi == NULL)
+			fatal(__func__);
+		*xi = *iface;
+		xi->ipv4.iface = xi;
+		xi->ipv6.iface = xi;
+		LIST_INSERT_HEAD(&xconf->iface_list, xi, entry);
+	}
+	LIST_FOREACH(tnbr, &conf->tnbr_list, entry) {
+		if (!(tnbr->flags & F_TNBR_CONFIGURED))
+			continue;
+
+		xt = calloc(1, sizeof(*xt));
+		if (xt == NULL)
+			fatal(__func__);
+		*xt = *tnbr;
+		LIST_INSERT_HEAD(&xconf->tnbr_list, xt, entry);
+	}
+	LIST_FOREACH(nbrp, &conf->nbrp_list, entry) {
+		xn = calloc(1, sizeof(*xn));
+		if (xn == NULL)
+			fatal(__func__);
+		*xn = *nbrp;
+		LIST_INSERT_HEAD(&xconf->nbrp_list, xn, entry);
+	}
+	LIST_FOREACH(l2vpn, &conf->l2vpn_list, entry) {
+		xl = calloc(1, sizeof(*xl));
+		if (xl == NULL)
+			fatal(__func__);
+		*xl = *l2vpn;
+		LIST_INIT(&xl->if_list);
+		LIST_INIT(&xl->pw_list);
+		LIST_INIT(&xl->pw_inactive_list);
+		LIST_INSERT_HEAD(&xconf->l2vpn_list, xl, entry);
+
+		LIST_FOREACH(lif, &l2vpn->if_list, entry) {
+			xf = calloc(1, sizeof(*xf));
+			if (xf == NULL)
+				fatal(__func__);
+			*xf = *lif;
+			xf->l2vpn = xl;
+			LIST_INSERT_HEAD(&xl->if_list, xf, entry);
+		}
+		LIST_FOREACH(pw, &l2vpn->pw_list, entry) {
+			xp = calloc(1, sizeof(*xp));
+			if (xp == NULL)
+				fatal(__func__);
+			*xp = *pw;
+			xp->l2vpn = xl;
+			LIST_INSERT_HEAD(&xl->pw_list, xp, entry);
+		}
+		LIST_FOREACH(pw, &l2vpn->pw_inactive_list, entry) {
+			xp = calloc(1, sizeof(*xp));
+			if (xp == NULL)
+				fatal(__func__);
+			*xp = *pw;
+			xp->l2vpn = xl;
+			LIST_INSERT_HEAD(&xl->pw_inactive_list, xp, entry);
+		}
+	}
+
+	return (xconf);
+}
+
+void
+ldp_clear_config(struct ldpd_conf *xconf)
+{
+	struct iface		*iface;
+	struct tnbr		*tnbr;
+	struct nbr_params	*nbrp;
+	struct l2vpn		*l2vpn;
+
+	while ((iface = LIST_FIRST(&xconf->iface_list)) != NULL) {
+		LIST_REMOVE(iface, entry);
+		free(iface);
+	}
+
+	while ((tnbr = LIST_FIRST(&xconf->tnbr_list)) != NULL) {
+		LIST_REMOVE(tnbr, entry);
+		free(tnbr);
+	}
+
+	while ((nbrp = LIST_FIRST(&xconf->nbrp_list)) != NULL) {
+		LIST_REMOVE(nbrp, entry);
+		free(nbrp);
+	}
+
+	while ((l2vpn = LIST_FIRST(&xconf->l2vpn_list)) != NULL)
+		ldp_clear_l2vpn_config(l2vpn);
+
+	free(xconf);
+}
+
+void
+ldp_clear_l2vpn_config(struct l2vpn *l2vpn)
+{
+	struct l2vpn_if		*lif;
+	struct l2vpn_pw		*pw;
+
+	while ((lif = LIST_FIRST(&l2vpn->if_list)) != NULL) {
+		LIST_REMOVE(lif, entry);
+		free(lif);
+	}
+	while ((pw = LIST_FIRST(&l2vpn->pw_list)) != NULL) {
+		LIST_REMOVE(pw, entry);
+		free(pw);
+	}
+	while ((pw = LIST_FIRST(&l2vpn->pw_inactive_list)) != NULL) {
+		LIST_REMOVE(pw, entry);
+		free(pw);
+	}
+	LIST_REMOVE(l2vpn, entry);
+	free(l2vpn);
+}
+
+void
+merge_config(struct ldpd_conf *conf, struct ldpd_conf *xconf)
+{
+	merge_global(conf, xconf);
+	merge_af(AF_INET, &conf->ipv4, &xconf->ipv4);
+	merge_af(AF_INET6, &conf->ipv6, &xconf->ipv6);
+	merge_ifaces(conf, xconf);
+	merge_tnbrs(conf, xconf);
+	merge_nbrps(conf, xconf);
+	merge_l2vpns(conf, xconf);
+	free(xconf);
+}
+
+static void
+merge_global(struct ldpd_conf *conf, struct ldpd_conf *xconf)
+{
+	/* change of router-id requires resetting all neighborships */
+	if (conf->rtr_id.s_addr != xconf->rtr_id.s_addr) {
+		if (ldpd_process == PROC_LDP_ENGINE) {
+			ldpe_reset_nbrs(AF_INET);
+			ldpe_reset_nbrs(AF_INET6);
+			if (conf->rtr_id.s_addr == INADDR_ANY ||
+			    xconf->rtr_id.s_addr == INADDR_ANY) {
+				if_update_all(AF_UNSPEC);
+				tnbr_update_all(AF_UNSPEC);
+			}
+		}
+		conf->rtr_id = xconf->rtr_id;
+	}
+
+	conf->lhello_holdtime = xconf->lhello_holdtime;
+	conf->lhello_interval = xconf->lhello_interval;
+	conf->thello_holdtime = xconf->thello_holdtime;
+	conf->thello_interval = xconf->thello_interval;
+
+	if (conf->trans_pref != xconf->trans_pref) {
+		if (ldpd_process == PROC_LDP_ENGINE)
+			ldpe_reset_ds_nbrs();
+		conf->trans_pref = xconf->trans_pref;
+	}
+
+	if ((conf->flags & F_LDPD_DS_CISCO_INTEROP) !=
+	    (xconf->flags & F_LDPD_DS_CISCO_INTEROP)) {
+		if (ldpd_process == PROC_LDP_ENGINE)
+			ldpe_reset_ds_nbrs();
+	}
+
+	conf->flags = xconf->flags;
+}
+
+static void
+merge_af(int af, struct ldpd_af_conf *af_conf, struct ldpd_af_conf *xa)
+{
+	struct nbr		*nbr;
+#ifdef __OpenBSD__
+	struct nbr_params	*nbrp;
+#endif
+	int			 egress_label_changed = 0;
+
+	if (af_conf->keepalive != xa->keepalive) {
+		af_conf->keepalive = xa->keepalive;
+		if (ldpd_process == PROC_LDP_ENGINE)
+			ldpe_stop_init_backoff(af);
+	}
+
+	af_conf->lhello_holdtime = xa->lhello_holdtime;
+	af_conf->lhello_interval = xa->lhello_interval;
+	af_conf->thello_holdtime = xa->thello_holdtime;
+	af_conf->thello_interval = xa->thello_interval;
+
+	/* update flags */
+	if (ldpd_process == PROC_LDP_ENGINE &&
+	    (af_conf->flags & F_LDPD_AF_THELLO_ACCEPT) &&
+	    !(xa->flags & F_LDPD_AF_THELLO_ACCEPT))
+		ldpe_remove_dynamic_tnbrs(af);
+
+	if ((af_conf->flags & F_LDPD_AF_EXPNULL) !=
+	    (xa->flags & F_LDPD_AF_EXPNULL))
+		egress_label_changed = 1;
+
+	af_conf->flags = xa->flags;
+
+	if (egress_label_changed) {
+		switch (ldpd_process) {
+		case PROC_LDE_ENGINE:
+			lde_change_egress_label(af, af_conf->flags &
+			    F_LDPD_AF_EXPNULL);
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (ldp_addrcmp(af, &af_conf->trans_addr, &xa->trans_addr)) {
+		af_conf->trans_addr = xa->trans_addr;
+		if (ldpd_process == PROC_MAIN && iev_ldpe)
+			imsg_compose_event(iev_ldpe, IMSG_CLOSE_SOCKETS, af,
+			    0, -1, NULL, 0);
+		if (ldpd_process == PROC_LDP_ENGINE) {
+			RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
+				if (nbr->af != af)
+					continue;
+
+				session_shutdown(nbr, S_SHUTDOWN, 0, 0);
+
+#ifdef __OpenBSD__
+				pfkey_remove(nbr);
+#endif
+				nbr->laddr = af_conf->trans_addr;
+#ifdef __OpenBSD__
+				nbrp = nbr_params_find(leconf, nbr->id);
+				if (nbrp && pfkey_establish(nbr, nbrp) == -1)
+					fatalx("pfkey setup failed");
+#endif
+			}
+		}
+	}
+}
+
+static void
+merge_ifaces(struct ldpd_conf *conf, struct ldpd_conf *xconf)
+{
+	struct iface		*iface, *itmp, *xi;
+
+	LIST_FOREACH_SAFE(iface, &conf->iface_list, entry, itmp) {
+		/* find deleted interfaces */
+		if ((xi = if_lookup_name(xconf, iface->name)) == NULL) {
+			LIST_REMOVE(iface, entry);
+			if (ldpd_process == PROC_LDP_ENGINE)
+				if_del(iface);
+			else
+				free(iface);
+		}
+	}
+	LIST_FOREACH_SAFE(xi, &xconf->iface_list, entry, itmp) {
+		/* find new interfaces */
+		if ((iface = if_lookup_name(conf, xi->name)) == NULL) {
+			LIST_REMOVE(xi, entry);
+			LIST_INSERT_HEAD(&conf->iface_list, xi, entry);
+
+			/* resend addresses to activate new interfaces */
+			if (ldpd_process == PROC_MAIN)
+				kif_redistribute(xi->name);
+			continue;
+		}
+
+		/* update existing interfaces */
+		merge_iface_af(&iface->ipv4, &xi->ipv4);
+		merge_iface_af(&iface->ipv6, &xi->ipv6);
+		LIST_REMOVE(xi, entry);
+		free(xi);
+	}
+}
+
+static void
+merge_iface_af(struct iface_af *ia, struct iface_af *xi)
+{
+	if (ia->enabled != xi->enabled) {
+		ia->enabled = xi->enabled;
+		if (ldpd_process == PROC_LDP_ENGINE)
+			if_update(ia->iface, ia->af);
+	}
+	ia->hello_holdtime = xi->hello_holdtime;
+	ia->hello_interval = xi->hello_interval;
+}
+
+static void
+merge_tnbrs(struct ldpd_conf *conf, struct ldpd_conf *xconf)
+{
+	struct tnbr		*tnbr, *ttmp, *xt;
+
+	LIST_FOREACH_SAFE(tnbr, &conf->tnbr_list, entry, ttmp) {
+		if (!(tnbr->flags & F_TNBR_CONFIGURED))
+			continue;
+
+		/* find deleted tnbrs */
+		if ((xt = tnbr_find(xconf, tnbr->af, &tnbr->addr)) == NULL) {
+			if (ldpd_process == PROC_LDP_ENGINE) {
+				tnbr->flags &= ~F_TNBR_CONFIGURED;
+				tnbr_check(tnbr);
+			} else {
+				LIST_REMOVE(tnbr, entry);
+				free(tnbr);
+			}
+		}
+	}
+	LIST_FOREACH_SAFE(xt, &xconf->tnbr_list, entry, ttmp) {
+		/* find new tnbrs */
+		if ((tnbr = tnbr_find(conf, xt->af, &xt->addr)) == NULL) {
+			LIST_REMOVE(xt, entry);
+			LIST_INSERT_HEAD(&conf->tnbr_list, xt, entry);
+
+			if (ldpd_process == PROC_LDP_ENGINE)
+				tnbr_update(xt);
+			continue;
+		}
+
+		/* update existing tnbrs */
+		if (!(tnbr->flags & F_TNBR_CONFIGURED))
+			tnbr->flags |= F_TNBR_CONFIGURED;
+		LIST_REMOVE(xt, entry);
+		free(xt);
+	}
+}
+
+static void
+merge_nbrps(struct ldpd_conf *conf, struct ldpd_conf *xconf)
+{
+	struct nbr_params	*nbrp, *ntmp, *xn;
+	struct nbr		*nbr;
+	int			 nbrp_changed;
+
+	LIST_FOREACH_SAFE(nbrp, &conf->nbrp_list, entry, ntmp) {
+		/* find deleted nbrps */
+		if ((xn = nbr_params_find(xconf, nbrp->lsr_id)) == NULL) {
+			if (ldpd_process == PROC_LDP_ENGINE) {
+				nbr = nbr_find_ldpid(nbrp->lsr_id.s_addr);
+				if (nbr) {
+					session_shutdown(nbr, S_SHUTDOWN, 0, 0);
+#ifdef __OpenBSD__
+					pfkey_remove(nbr);
+#else
+					sock_set_md5sig(
+					    (ldp_af_global_get(&global,
+					    nbr->af))->ldp_session_socket,
+					    nbr->af, &nbr->raddr, NULL);
+#endif
+				}
+			}
+			LIST_REMOVE(nbrp, entry);
+			free(nbrp);
+		}
+	}
+	LIST_FOREACH_SAFE(xn, &xconf->nbrp_list, entry, ntmp) {
+		/* find new nbrps */
+		if ((nbrp = nbr_params_find(conf, xn->lsr_id)) == NULL) {
+			LIST_REMOVE(xn, entry);
+			LIST_INSERT_HEAD(&conf->nbrp_list, xn, entry);
+
+			if (ldpd_process == PROC_LDP_ENGINE) {
+				nbr = nbr_find_ldpid(xn->lsr_id.s_addr);
+				if (nbr) {
+					session_shutdown(nbr, S_SHUTDOWN, 0, 0);
+#ifdef __OpenBSD__
+					if (pfkey_establish(nbr, xn) == -1)
+						fatalx("pfkey setup failed");
+#else
+					sock_set_md5sig(
+					    (ldp_af_global_get(&global,
+					    nbr->af))->ldp_session_socket,
+					    nbr->af, &nbr->raddr,
+					    xn->auth.md5key);
+#endif
+				}
+			}
+			continue;
+		}
+
+		/* update existing nbrps */
+		if (nbrp->keepalive != xn->keepalive ||
+		    nbrp->auth.method != xn->auth.method ||
+		    strcmp(nbrp->auth.md5key, xn->auth.md5key) != 0)
+			nbrp_changed = 1;
+		else
+			nbrp_changed = 0;
+
+		nbrp->keepalive = xn->keepalive;
+		nbrp->auth.method = xn->auth.method;
+		strlcpy(nbrp->auth.md5key, xn->auth.md5key,
+		    sizeof(nbrp->auth.md5key));
+		nbrp->auth.md5key_len = xn->auth.md5key_len;
+		nbrp->flags = xn->flags;
+
+		if (ldpd_process == PROC_LDP_ENGINE) {
+			nbr = nbr_find_ldpid(nbrp->lsr_id.s_addr);
+			if (nbr && nbrp_changed) {
+				session_shutdown(nbr, S_SHUTDOWN, 0, 0);
+#ifdef __OpenBSD__
+				pfkey_remove(nbr);
+				if (pfkey_establish(nbr, nbrp) == -1)
+					fatalx("pfkey setup failed");
+#else
+				sock_set_md5sig((ldp_af_global_get(&global,
+				    nbr->af))->ldp_session_socket, nbr->af,
+				    &nbr->raddr, nbrp->auth.md5key);
+#endif
+			}
+		}
+		LIST_REMOVE(xn, entry);
+		free(xn);
+	}
+}
+
+static void
+merge_l2vpns(struct ldpd_conf *conf, struct ldpd_conf *xconf)
+{
+	struct l2vpn		*l2vpn, *ltmp, *xl;
+
+	LIST_FOREACH_SAFE(l2vpn, &conf->l2vpn_list, entry, ltmp) {
+		/* find deleted l2vpns */
+		if ((xl = l2vpn_find(xconf, l2vpn->name)) == NULL) {
+			LIST_REMOVE(l2vpn, entry);
+
+			switch (ldpd_process) {
+			case PROC_LDE_ENGINE:
+				l2vpn_del(l2vpn);
+				break;
+			case PROC_LDP_ENGINE:
+				ldpe_l2vpn_exit(l2vpn);
+				free(l2vpn);
+				break;
+			case PROC_MAIN:
+				free(l2vpn);
+				break;
+			}
+		}
+	}
+	LIST_FOREACH_SAFE(xl, &xconf->l2vpn_list, entry, ltmp) {
+		/* find new l2vpns */
+		if ((l2vpn = l2vpn_find(conf, xl->name)) == NULL) {
+			LIST_REMOVE(xl, entry);
+			LIST_INSERT_HEAD(&conf->l2vpn_list, xl, entry);
+
+			switch (ldpd_process) {
+			case PROC_LDE_ENGINE:
+				l2vpn_init(xl);
+				break;
+			case PROC_LDP_ENGINE:
+				ldpe_l2vpn_init(xl);
+				break;
+			case PROC_MAIN:
+				break;
+			}
+			continue;
+		}
+
+		/* update existing l2vpns */
+		merge_l2vpn(conf, l2vpn, xl);
+		LIST_REMOVE(xl, entry);
+		free(xl);
+	}
+}
+
+static void
+merge_l2vpn(struct ldpd_conf *xconf, struct l2vpn *l2vpn, struct l2vpn *xl)
+{
+	struct l2vpn_if		*lif, *ftmp, *xf;
+	struct l2vpn_pw		*pw, *ptmp, *xp;
+	struct nbr		*nbr;
+	int			 reset_nbr, reinstall_pwfec, reinstall_tnbr;
+	LIST_HEAD(, l2vpn_pw)	 pw_aux_list;
+	int			 previous_pw_type, previous_mtu;
+
+	previous_pw_type = l2vpn->pw_type;
+	previous_mtu = l2vpn->mtu;
+
+	/* merge intefaces */
+	LIST_FOREACH_SAFE(lif, &l2vpn->if_list, entry, ftmp) {
+		/* find deleted interfaces */
+		if ((xf = l2vpn_if_find_name(xl, lif->ifname)) == NULL) {
+			LIST_REMOVE(lif, entry);
+			free(lif);
+		}
+	}
+	LIST_FOREACH_SAFE(xf, &xl->if_list, entry, ftmp) {
+		/* find new interfaces */
+		if ((lif = l2vpn_if_find_name(l2vpn, xf->ifname)) == NULL) {
+			LIST_REMOVE(xf, entry);
+			LIST_INSERT_HEAD(&l2vpn->if_list, xf, entry);
+			xf->l2vpn = l2vpn;
+			continue;
+		}
+
+		LIST_REMOVE(xf, entry);
+		free(xf);
+	}
+
+	/* merge active pseudowires */
+	LIST_INIT(&pw_aux_list);
+	LIST_FOREACH_SAFE(pw, &l2vpn->pw_list, entry, ptmp) {
+		/* find deleted active pseudowires */
+		if ((xp = l2vpn_pw_find_name(xl, pw->ifname)) == NULL) {
+			switch (ldpd_process) {
+			case PROC_LDE_ENGINE:
+				l2vpn_pw_exit(pw);
+				break;
+			case PROC_LDP_ENGINE:
+				ldpe_l2vpn_pw_exit(pw);
+				break;
+			case PROC_MAIN:
+				break;
+			}
+
+			LIST_REMOVE(pw, entry);
+			free(pw);
+		}
+	}
+	LIST_FOREACH_SAFE(xp, &xl->pw_list, entry, ptmp) {
+		/* find new active pseudowires */
+		if ((pw = l2vpn_pw_find_name(l2vpn, xp->ifname)) == NULL) {
+			LIST_REMOVE(xp, entry);
+			LIST_INSERT_HEAD(&l2vpn->pw_list, xp, entry);
+			xp->l2vpn = l2vpn;
+
+			switch (ldpd_process) {
+			case PROC_LDE_ENGINE:
+				l2vpn_pw_init(xp);
+				break;
+			case PROC_LDP_ENGINE:
+				ldpe_l2vpn_pw_init(xp);
+				break;
+			case PROC_MAIN:
+				break;
+			}
+			continue;
+		}
+
+		/* update existing active pseudowire */
+    		if (pw->af != xp->af ||
+		    ldp_addrcmp(pw->af, &pw->addr, &xp->addr))
+			reinstall_tnbr = 1;
+		else
+			reinstall_tnbr = 0;
+
+		/* changes that require a session restart */
+		if ((pw->flags & (F_PW_STATUSTLV_CONF|F_PW_CWORD_CONF)) !=
+		    (xp->flags & (F_PW_STATUSTLV_CONF|F_PW_CWORD_CONF)))
+			reset_nbr = 1;
+		else
+			reset_nbr = 0;
+
+		if (l2vpn->pw_type != xl->pw_type || l2vpn->mtu != xl->mtu ||
+		    pw->pwid != xp->pwid || reinstall_tnbr || reset_nbr ||
+		    pw->lsr_id.s_addr != xp->lsr_id.s_addr)
+			reinstall_pwfec = 1;
+		else
+			reinstall_pwfec = 0;
+
+		/* check if the pseudowire should be disabled */
+		if (xp->lsr_id.s_addr == INADDR_ANY || xp->pwid == 0) {
+			reinstall_tnbr = 0;
+			reset_nbr = 0;
+			reinstall_pwfec = 0;
+
+			switch (ldpd_process) {
+			case PROC_LDE_ENGINE:
+				l2vpn_pw_exit(pw);
+				break;
+			case PROC_LDP_ENGINE:
+				ldpe_l2vpn_pw_exit(pw);
+				break;
+			case PROC_MAIN:
+				break;
+			}
+
+			/* remove from active list */
+			LIST_REMOVE(pw, entry);
+			LIST_INSERT_HEAD(&pw_aux_list, pw, entry);
+		}
+
+		if (ldpd_process == PROC_LDP_ENGINE) {
+			if (reinstall_tnbr)
+				ldpe_l2vpn_pw_exit(pw);
+			if (reset_nbr) {
+				nbr = nbr_find_ldpid(pw->lsr_id.s_addr);
+				if (nbr && nbr->state == NBR_STA_OPER)
+					session_shutdown(nbr, S_SHUTDOWN, 0, 0);
+			}
+		}
+		if (ldpd_process == PROC_LDE_ENGINE &&
+		    !reset_nbr && reinstall_pwfec)
+			l2vpn_pw_exit(pw);
+		pw->lsr_id = xp->lsr_id;
+		pw->af = xp->af;
+		pw->addr = xp->addr;
+		pw->pwid = xp->pwid;
+		strlcpy(pw->ifname, xp->ifname, sizeof(pw->ifname));
+		pw->ifindex = xp->ifindex;
+		if (xp->flags & F_PW_CWORD_CONF)
+			pw->flags |= F_PW_CWORD_CONF;
+		else
+			pw->flags &= ~F_PW_CWORD_CONF;
+		if (xp->flags & F_PW_STATUSTLV_CONF)
+			pw->flags |= F_PW_STATUSTLV_CONF;
+		else
+			pw->flags &= ~F_PW_STATUSTLV_CONF;
+		if (xp->flags & F_PW_STATIC_NBR_ADDR)
+			pw->flags |= F_PW_STATIC_NBR_ADDR;
+		else
+			pw->flags &= ~F_PW_STATIC_NBR_ADDR;
+		if (ldpd_process == PROC_LDP_ENGINE && reinstall_tnbr)
+			ldpe_l2vpn_pw_init(pw);
+		if (ldpd_process == PROC_LDE_ENGINE &&
+		    !reset_nbr && reinstall_pwfec) {
+			l2vpn->pw_type = xl->pw_type;
+			l2vpn->mtu = xl->mtu;
+			l2vpn_pw_init(pw);
+			l2vpn->pw_type = previous_pw_type;
+			l2vpn->mtu = previous_mtu;
+		}
+
+		LIST_REMOVE(xp, entry);
+		free(xp);
+	}
+
+	/* merge inactive pseudowires */
+	LIST_FOREACH_SAFE(pw, &l2vpn->pw_inactive_list, entry, ptmp) {
+		/* find deleted inactive pseudowires */
+		if ((xp = l2vpn_pw_find_name(xl, pw->ifname)) == NULL) {
+			LIST_REMOVE(pw, entry);
+			free(pw);
+		}
+	}
+	LIST_FOREACH_SAFE(xp, &xl->pw_inactive_list, entry, ptmp) {
+		/* find new inactive pseudowires */
+		if ((pw = l2vpn_pw_find_name(l2vpn, xp->ifname)) == NULL) {
+			LIST_REMOVE(xp, entry);
+			LIST_INSERT_HEAD(&l2vpn->pw_inactive_list, xp, entry);
+			xp->l2vpn = l2vpn;
+			continue;
+		}
+
+		/* update existing inactive pseudowire */
+		pw->lsr_id.s_addr = xp->lsr_id.s_addr;
+		pw->af = xp->af;
+		pw->addr = xp->addr;
+		pw->pwid = xp->pwid;
+		strlcpy(pw->ifname, xp->ifname, sizeof(pw->ifname));
+		pw->ifindex = xp->ifindex;
+		pw->flags = xp->flags;
+
+		/* check if the pseudowire should be activated */
+		if (pw->lsr_id.s_addr != INADDR_ANY && pw->pwid != 0) {
+			/* remove from inactive list */
+			LIST_REMOVE(pw, entry);
+			LIST_INSERT_HEAD(&l2vpn->pw_list, pw, entry);
+
+			switch (ldpd_process) {
+			case PROC_LDE_ENGINE:
+				l2vpn_pw_init(pw);
+				break;
+			case PROC_LDP_ENGINE:
+				ldpe_l2vpn_pw_init(pw);
+				break;
+			case PROC_MAIN:
+				break;
+			}
+		}
+
+		LIST_REMOVE(xp, entry);
+		free(xp);
+	}
+
+	/* insert pseudowires that were disabled in the inactive list */
+	LIST_FOREACH_SAFE(pw, &pw_aux_list, entry, ptmp) {
+		LIST_REMOVE(pw, entry);
+		LIST_INSERT_HEAD(&l2vpn->pw_inactive_list, pw, entry);
+	}
+
+	l2vpn->pw_type = xl->pw_type;
+	l2vpn->mtu = xl->mtu;
+	strlcpy(l2vpn->br_ifname, xl->br_ifname, sizeof(l2vpn->br_ifname));
+	l2vpn->br_ifindex = xl->br_ifindex;
+}
+
+struct ldpd_conf *
+config_new_empty(void)
+{
+	struct ldpd_conf	*xconf;
+
+	xconf = calloc(1, sizeof(*xconf));
+	if (xconf == NULL)
+		fatal(NULL);
+
+	LIST_INIT(&xconf->iface_list);
+	LIST_INIT(&xconf->tnbr_list);
+	LIST_INIT(&xconf->nbrp_list);
+	LIST_INIT(&xconf->l2vpn_list);
+
+	return (xconf);
+}
+
+void
+config_clear(struct ldpd_conf *conf)
+{
+	struct ldpd_conf	*xconf;
+
+	/*
+	 * Merge current config with an empty config, this will deactivate
+	 * and deallocate all the interfaces, pseudowires and so on. Before
+	 * merging, copy the router-id and other variables to avoid some
+	 * unnecessary operations, like trying to reset the neighborships.
+	 */
+	xconf = config_new_empty();
+	xconf->ipv4 = conf->ipv4;
+	xconf->ipv6 = conf->ipv6;
+	xconf->rtr_id = conf->rtr_id;
+	xconf->trans_pref = conf->trans_pref;
+	xconf->flags = conf->flags;
+	merge_config(conf, xconf);
+	free(conf);
+}
diff --git a/ldpd/ldpd.conf.sample b/ldpd/ldpd.conf.sample
new file mode 100644
index 0000000..49da35c
--- /dev/null
+++ b/ldpd/ldpd.conf.sample
@@ -0,0 +1,46 @@
+! -*- ldp -*-
+!
+! LDPd sample configuration file
+!
+hostname ldpd
+password zebra
+log stdout
+!
+interface eth0
+!
+interface eth1
+!
+interface lo
+!
+mpls ldp
+ dual-stack cisco-interop
+ neighbor 10.0.1.5 password opensourcerouting
+ neighbor 172.16.0.1 password opensourcerouting
+ !
+ address-family ipv4
+  discovery transport-address 10.0.1.1
+  label local advertise explicit-null
+  !
+  interface eth0
+  !
+  interface eth1
+  !
+ !
+ address-family ipv6
+  discovery transport-address 2001:db8::1
+  !
+  interface eth1
+  !
+ !
+!
+l2vpn ENG type vpls
+ bridge br0
+ member interface eth2
+ !
+ member pseudowire mpw0
+  neighbor lsr-id 1.1.1.1
+  pw-id 100
+ !
+!
+line vty
+!
diff --git a/ldpd/ldpd.h b/ldpd/ldpd.h
new file mode 100644
index 0000000..720513f
--- /dev/null
+++ b/ldpd/ldpd.h
@@ -0,0 +1,632 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ * Copyright (c) 2004 Esben Norby <norby@openbsd.org>
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _LDPD_H_
+#define _LDPD_H_
+
+#include "openbsd-queue.h"
+#include "openbsd-tree.h"
+#include "imsg.h"
+#include "thread.h"
+
+#include "ldp.h"
+
+#define CONF_FILE		"/etc/ldpd.conf"
+#define LDPD_USER		"_ldpd"
+
+#define LDPD_OPT_VERBOSE	0x00000001
+#define LDPD_OPT_VERBOSE2	0x00000002
+#define LDPD_OPT_NOACTION	0x00000004
+
+#define TCP_MD5_KEY_LEN		80
+#define L2VPN_NAME_LEN		32
+
+#define	RT_BUF_SIZE		16384
+#define	MAX_RTSOCK_BUF		128 * 1024
+#define	LDP_BACKLOG		128
+
+#define	F_LDPD_INSERTED		0x0001
+#define	F_CONNECTED		0x0002
+#define	F_STATIC		0x0004
+#define	F_DYNAMIC		0x0008
+#define	F_REJECT		0x0010
+#define	F_BLACKHOLE		0x0020
+#define	F_REDISTRIBUTED		0x0040
+
+struct evbuf {
+	struct msgbuf		 wbuf;
+	struct thread		*ev;
+	int			 (*handler)(struct thread *);
+	void			*arg;
+};
+
+struct imsgev {
+	struct imsgbuf		 ibuf;
+	int			(*handler_write)(struct thread *);
+	struct thread		*ev_write;
+	int			(*handler_read)(struct thread *);
+	struct thread		*ev_read;
+};
+
+enum imsg_type {
+	IMSG_NONE,
+	IMSG_CTL_RELOAD,
+	IMSG_CTL_SHOW_INTERFACE,
+	IMSG_CTL_SHOW_DISC_IFACE,
+	IMSG_CTL_SHOW_DISC_TNBR,
+	IMSG_CTL_SHOW_DISCOVERY,
+	IMSG_CTL_SHOW_NBR_DISC,
+	IMSG_CTL_SHOW_NBR,
+	IMSG_CTL_SHOW_LIB,
+	IMSG_CTL_SHOW_L2VPN_PW,
+	IMSG_CTL_SHOW_L2VPN_BINDING,
+	IMSG_CTL_CLEAR_NBR,
+	IMSG_CTL_FIB_COUPLE,
+	IMSG_CTL_FIB_DECOUPLE,
+	IMSG_CTL_KROUTE,
+	IMSG_CTL_KROUTE_ADDR,
+	IMSG_CTL_IFINFO,
+	IMSG_CTL_END,
+	IMSG_CTL_LOG_VERBOSE,
+	IMSG_KLABEL_CHANGE,
+	IMSG_KLABEL_DELETE,
+	IMSG_KPWLABEL_CHANGE,
+	IMSG_KPWLABEL_DELETE,
+	IMSG_IFSTATUS,
+	IMSG_NEWADDR,
+	IMSG_DELADDR,
+	IMSG_RTRID_UPDATE,
+	IMSG_LABEL_MAPPING,
+	IMSG_LABEL_MAPPING_FULL,
+	IMSG_LABEL_REQUEST,
+	IMSG_LABEL_RELEASE,
+	IMSG_LABEL_WITHDRAW,
+	IMSG_LABEL_ABORT,
+	IMSG_REQUEST_ADD,
+	IMSG_REQUEST_ADD_END,
+	IMSG_MAPPING_ADD,
+	IMSG_MAPPING_ADD_END,
+	IMSG_RELEASE_ADD,
+	IMSG_RELEASE_ADD_END,
+	IMSG_WITHDRAW_ADD,
+	IMSG_WITHDRAW_ADD_END,
+	IMSG_ADDRESS_ADD,
+	IMSG_ADDRESS_DEL,
+	IMSG_NOTIFICATION,
+	IMSG_NOTIFICATION_SEND,
+	IMSG_NEIGHBOR_UP,
+	IMSG_NEIGHBOR_DOWN,
+	IMSG_NETWORK_ADD,
+	IMSG_NETWORK_DEL,
+	IMSG_SOCKET_IPC,
+	IMSG_SOCKET_NET,
+	IMSG_CLOSE_SOCKETS,
+	IMSG_REQUEST_SOCKETS,
+	IMSG_SETUP_SOCKETS,
+	IMSG_RECONF_CONF,
+	IMSG_RECONF_IFACE,
+	IMSG_RECONF_TNBR,
+	IMSG_RECONF_NBRP,
+	IMSG_RECONF_L2VPN,
+	IMSG_RECONF_L2VPN_IF,
+	IMSG_RECONF_L2VPN_PW,
+	IMSG_RECONF_L2VPN_IPW,
+	IMSG_RECONF_END
+};
+
+union ldpd_addr {
+	struct in_addr	v4;
+	struct in6_addr	v6;
+};
+
+#define IN6_IS_SCOPE_EMBED(a)   \
+	((IN6_IS_ADDR_LINKLOCAL(a)) ||  \
+	 (IN6_IS_ADDR_MC_LINKLOCAL(a)) || \
+	 (IN6_IS_ADDR_MC_INTFACELOCAL(a)))
+
+/* interface states */
+#define	IF_STA_DOWN		0x01
+#define	IF_STA_ACTIVE		0x02
+
+/* targeted neighbor states */
+#define	TNBR_STA_DOWN		0x01
+#define	TNBR_STA_ACTIVE		0x02
+
+/* interface types */
+enum iface_type {
+	IF_TYPE_POINTOPOINT,
+	IF_TYPE_BROADCAST
+};
+
+/* neighbor states */
+#define	NBR_STA_PRESENT		0x0001
+#define	NBR_STA_INITIAL		0x0002
+#define	NBR_STA_OPENREC		0x0004
+#define	NBR_STA_OPENSENT	0x0008
+#define	NBR_STA_OPER		0x0010
+#define	NBR_STA_SESSION		(NBR_STA_INITIAL | NBR_STA_OPENREC | \
+				NBR_STA_OPENSENT | NBR_STA_OPER)
+
+/* neighbor events */
+enum nbr_event {
+	NBR_EVT_NOTHING,
+	NBR_EVT_MATCH_ADJ,
+	NBR_EVT_CONNECT_UP,
+	NBR_EVT_CLOSE_SESSION,
+	NBR_EVT_INIT_RCVD,
+	NBR_EVT_KEEPALIVE_RCVD,
+	NBR_EVT_PDU_RCVD,
+	NBR_EVT_PDU_SENT,
+	NBR_EVT_INIT_SENT
+};
+
+/* neighbor actions */
+enum nbr_action {
+	NBR_ACT_NOTHING,
+	NBR_ACT_RST_KTIMEOUT,
+	NBR_ACT_SESSION_EST,
+	NBR_ACT_RST_KTIMER,
+	NBR_ACT_CONNECT_SETUP,
+	NBR_ACT_PASSIVE_INIT,
+	NBR_ACT_KEEPALIVE_SEND,
+	NBR_ACT_CLOSE_SESSION
+};
+
+TAILQ_HEAD(mapping_head, mapping_entry);
+
+struct map {
+	uint8_t		type;
+	uint32_t	messageid;
+	union {
+		struct {
+			uint16_t	af;
+			union ldpd_addr	prefix;
+			uint8_t		prefixlen;
+		} prefix;
+		struct {
+			uint16_t	type;
+			uint32_t	pwid;
+			uint32_t	group_id;
+			uint16_t	ifmtu;
+		} pwid;
+	} fec;
+	uint32_t	label;
+	uint32_t	requestid;
+	uint32_t	pw_status;
+	uint8_t		flags;
+};
+#define F_MAP_REQ_ID	0x01	/* optional request message id present */
+#define F_MAP_PW_CWORD	0x02	/* pseudowire control word */
+#define F_MAP_PW_ID	0x04	/* pseudowire connection id */
+#define F_MAP_PW_IFMTU	0x08	/* pseudowire interface parameter */
+#define F_MAP_PW_STATUS	0x10	/* pseudowire status */
+
+struct notify_msg {
+	uint32_t	status;
+	uint32_t	messageid;	/* network byte order */
+	uint16_t	type;		/* network byte order */
+	uint32_t	pw_status;
+	struct map	fec;
+	uint8_t		flags;
+};
+#define F_NOTIF_PW_STATUS	0x01	/* pseudowire status tlv present */
+#define F_NOTIF_FEC		0x02	/* fec tlv present */
+
+struct if_addr {
+	LIST_ENTRY(if_addr)	 entry;
+	int			 af;
+	union ldpd_addr		 addr;
+	uint8_t			 prefixlen;
+	union ldpd_addr		 dstbrd;
+};
+LIST_HEAD(if_addr_head, if_addr);
+
+struct iface_af {
+	struct iface		*iface;
+	int			 af;
+	int			 enabled;
+	int			 state;
+	LIST_HEAD(, adj)	 adj_list;
+	time_t			 uptime;
+	struct thread		*hello_timer;
+	uint16_t		 hello_holdtime;
+	uint16_t		 hello_interval;
+};
+
+struct iface {
+	LIST_ENTRY(iface)	 entry;
+	char			 name[IF_NAMESIZE];
+	unsigned int		 ifindex;
+	struct if_addr_head	 addr_list;
+	struct in6_addr		 linklocal;
+	enum iface_type		 type;
+	uint16_t		 flags;
+	struct iface_af		 ipv4;
+	struct iface_af		 ipv6;
+};
+
+/* source of targeted hellos */
+struct tnbr {
+	LIST_ENTRY(tnbr)	 entry;
+	struct thread		*hello_timer;
+	struct adj		*adj;
+	int			 af;
+	union ldpd_addr		 addr;
+	int			 state;
+	uint16_t		 pw_count;
+	uint8_t			 flags;
+};
+#define F_TNBR_CONFIGURED	 0x01
+#define F_TNBR_DYNAMIC		 0x02
+
+enum auth_method {
+	AUTH_NONE,
+	AUTH_MD5SIG
+};
+
+/* neighbor specific parameters */
+struct nbr_params {
+	LIST_ENTRY(nbr_params)	 entry;
+	struct in_addr		 lsr_id;
+	uint16_t		 keepalive;
+	struct {
+		enum auth_method	 method;
+		char			 md5key[TCP_MD5_KEY_LEN];
+		uint8_t			 md5key_len;
+	} auth;
+	uint8_t			 flags;
+};
+#define F_NBRP_KEEPALIVE	 0x01
+
+struct l2vpn_if {
+	LIST_ENTRY(l2vpn_if)	 entry;
+	struct l2vpn		*l2vpn;
+	char			 ifname[IF_NAMESIZE];
+	unsigned int		 ifindex;
+	uint16_t		 flags;
+};
+
+struct l2vpn_pw {
+	LIST_ENTRY(l2vpn_pw)	 entry;
+	struct l2vpn		*l2vpn;
+	struct in_addr		 lsr_id;
+	int			 af;
+	union ldpd_addr		 addr;
+	uint32_t		 pwid;
+	char			 ifname[IF_NAMESIZE];
+	unsigned int		 ifindex;
+	uint32_t		 remote_group;
+	uint16_t		 remote_mtu;
+	uint32_t		 remote_status;
+	uint8_t			 flags;
+};
+#define F_PW_STATUSTLV_CONF	0x01	/* status tlv configured */
+#define F_PW_STATUSTLV		0x02	/* status tlv negotiated */
+#define F_PW_CWORD_CONF		0x04	/* control word configured */
+#define F_PW_CWORD		0x08	/* control word negotiated */
+#define F_PW_STATUS_UP		0x10	/* pseudowire is operational */
+#define F_PW_STATIC_NBR_ADDR	0x20	/* static neighbor address configured */
+
+struct l2vpn {
+	LIST_ENTRY(l2vpn)	 entry;
+	char			 name[L2VPN_NAME_LEN];
+	int			 type;
+	int			 pw_type;
+	int			 mtu;
+	char			 br_ifname[IF_NAMESIZE];
+	unsigned int		 br_ifindex;
+	LIST_HEAD(, l2vpn_if)	 if_list;
+	LIST_HEAD(, l2vpn_pw)	 pw_list;
+	LIST_HEAD(, l2vpn_pw)	 pw_inactive_list;
+};
+#define L2VPN_TYPE_VPWS		1
+#define L2VPN_TYPE_VPLS		2
+
+/* ldp_conf */
+enum ldpd_process {
+	PROC_MAIN,
+	PROC_LDP_ENGINE,
+	PROC_LDE_ENGINE
+} ldpd_process;
+
+enum socket_type {
+	LDP_SOCKET_DISC,
+	LDP_SOCKET_EDISC,
+	LDP_SOCKET_SESSION
+};
+
+enum blockmodes {
+	BM_NORMAL,
+	BM_NONBLOCK
+};
+
+enum hello_type {
+	HELLO_LINK,
+	HELLO_TARGETED
+};
+
+struct ldpd_af_conf {
+	uint16_t		 keepalive;
+	uint16_t		 lhello_holdtime;
+	uint16_t		 lhello_interval;
+	uint16_t		 thello_holdtime;
+	uint16_t		 thello_interval;
+	union ldpd_addr		 trans_addr;
+	int			 flags;
+};
+#define	F_LDPD_AF_ENABLED	0x0001
+#define	F_LDPD_AF_THELLO_ACCEPT	0x0002
+#define	F_LDPD_AF_EXPNULL	0x0004
+
+struct ldpd_conf {
+	struct in_addr		 rtr_id;
+	struct ldpd_af_conf	 ipv4;
+	struct ldpd_af_conf	 ipv6;
+	LIST_HEAD(, iface)	 iface_list;
+	LIST_HEAD(, tnbr)	 tnbr_list;
+	LIST_HEAD(, nbr_params)	 nbrp_list;
+	LIST_HEAD(, l2vpn)	 l2vpn_list;
+	uint16_t		 lhello_holdtime;
+	uint16_t		 lhello_interval;
+	uint16_t		 thello_holdtime;
+	uint16_t		 thello_interval;
+	uint16_t		 trans_pref;
+	int			 flags;
+};
+#define	F_LDPD_NO_FIB_UPDATE	0x0001
+#define	F_LDPD_DS_CISCO_INTEROP	0x0002
+#define	F_LDPD_ENABLED		0x0004
+
+struct ldpd_af_global {
+	struct thread		*disc_ev;
+	struct thread		*edisc_ev;
+	int			 ldp_disc_socket;
+	int			 ldp_edisc_socket;
+	int			 ldp_session_socket;
+};
+
+struct ldpd_global {
+	int			 cmd_opts;
+	time_t			 uptime;
+	struct in_addr		 rtr_id;
+	struct ldpd_af_global	 ipv4;
+	struct ldpd_af_global	 ipv6;
+	int			 pfkeysock;
+	struct if_addr_head	 addr_list;
+	LIST_HEAD(, adj)	 adj_list;
+	struct in_addr		 mcast_addr_v4;
+	struct in6_addr		 mcast_addr_v6;
+	TAILQ_HEAD(, pending_conn) pending_conns;
+};
+
+/* kroute */
+struct kroute {
+	int			 af;
+	union ldpd_addr		 prefix;
+	uint8_t			 prefixlen;
+	union ldpd_addr		 nexthop;
+	uint32_t		 local_label;
+	uint32_t		 remote_label;
+	unsigned short		 ifindex;
+	uint8_t			 priority;
+	uint16_t		 flags;
+};
+
+struct kpw {
+	unsigned short		 ifindex;
+	int			 pw_type;
+	int			 af;
+	union ldpd_addr		 nexthop;
+	uint32_t		 local_label;
+	uint32_t		 remote_label;
+	uint8_t			 flags;
+};
+
+struct kaddr {
+	unsigned short		 ifindex;
+	int			 af;
+	union ldpd_addr		 addr;
+	uint8_t			 prefixlen;
+	union ldpd_addr	 	 dstbrd;
+};
+
+struct kif {
+	char			 ifname[IF_NAMESIZE];
+	unsigned short		 ifindex;
+	int			 flags;
+	int			 mtu;
+};
+
+/* control data structures */
+struct ctl_iface {
+	int			 af;
+	char			 name[IF_NAMESIZE];
+	unsigned int		 ifindex;
+	int			 state;
+	uint16_t		 flags;
+	enum iface_type		 type;
+	uint16_t		 hello_holdtime;
+	uint16_t		 hello_interval;
+	time_t			 uptime;
+	uint16_t		 adj_cnt;
+};
+
+struct ctl_adj_if {
+	char			 name[IF_NAMESIZE];
+	int			 active_v4;
+	int			 active_v6;
+};
+
+struct ctl_adj_tnbr {
+	int			 af;
+	union ldpd_addr		 addr;
+};
+
+struct ctl_adj {
+	int			 af;
+	struct in_addr		 id;
+	enum hello_type		 type;
+	char			 ifname[IF_NAMESIZE];
+	union ldpd_addr		 src_addr;
+	uint16_t		 holdtime;
+	union ldpd_addr		 trans_addr;
+};
+
+struct ctl_nbr {
+	int			 af;
+	struct in_addr		 id;
+	union ldpd_addr		 laddr;
+	in_port_t		 lport;
+	union ldpd_addr		 raddr;
+	in_port_t		 rport;
+	uint16_t		 holdtime;
+	time_t			 uptime;
+	int			 nbr_state;
+};
+
+struct ctl_rt {
+	int			 af;
+	union ldpd_addr		 prefix;
+	uint8_t			 prefixlen;
+	struct in_addr		 nexthop;	/* lsr-id */
+	uint32_t		 local_label;
+	uint32_t		 remote_label;
+	uint8_t			 flags;
+	uint8_t			 in_use;
+	int			 first;
+};
+
+struct ctl_pw {
+	uint16_t		 type;
+	char			 l2vpn_name[L2VPN_NAME_LEN];
+	char			 ifname[IF_NAMESIZE];
+	uint32_t		 pwid;
+	struct in_addr		 lsr_id;
+	uint32_t		 local_label;
+	uint32_t		 local_gid;
+	uint16_t		 local_ifmtu;
+	uint8_t			 local_cword;
+	uint32_t		 remote_label;
+	uint32_t		 remote_gid;
+	uint16_t		 remote_ifmtu;
+	uint8_t			 remote_cword;
+	uint32_t		 status;
+};
+
+extern struct ldpd_conf		*ldpd_conf;
+extern struct ldpd_global	 global;
+
+/* parse.y */
+struct ldpd_conf	*parse_config(char *);
+int			 cmdline_symset(char *);
+
+/* kroute.c */
+void		 kif_redistribute(const char *);
+int		 kr_change(struct kroute *);
+int		 kr_delete(struct kroute *);
+int		 kmpw_set(struct kpw *);
+int		 kmpw_unset(struct kpw *);
+
+/* util.c */
+uint8_t		 mask2prefixlen(in_addr_t);
+uint8_t		 mask2prefixlen6(struct sockaddr_in6 *);
+in_addr_t	 prefixlen2mask(uint8_t);
+struct in6_addr	*prefixlen2mask6(uint8_t);
+void		 ldp_applymask(int, union ldpd_addr *,
+		    const union ldpd_addr *, int);
+int		 ldp_addrcmp(int, const union ldpd_addr *,
+		    const union ldpd_addr *);
+int		 ldp_addrisset(int, const union ldpd_addr *);
+int		 ldp_prefixcmp(int, const union ldpd_addr *,
+		    const union ldpd_addr *, uint8_t);
+int		 bad_addr_v4(struct in_addr);
+int		 bad_addr_v6(struct in6_addr *);
+int		 bad_addr(int, union ldpd_addr *);
+void		 embedscope(struct sockaddr_in6 *);
+void		 recoverscope(struct sockaddr_in6 *);
+void		 addscope(struct sockaddr_in6 *, uint32_t);
+void		 clearscope(struct in6_addr *);
+struct sockaddr	*addr2sa(int af, union ldpd_addr *, uint16_t);
+void		 sa2addr(struct sockaddr *, int *, union ldpd_addr *, in_port_t *);
+socklen_t	 sockaddr_len(struct sockaddr *);
+
+/* ldpd.c */
+int			 ldp_write_handler(struct thread *);
+void			 main_imsg_compose_ldpe(int, pid_t, void *, uint16_t);
+void			 main_imsg_compose_lde(int, pid_t, void *, uint16_t);
+void			 imsg_event_add(struct imsgev *);
+int			 imsg_compose_event(struct imsgev *, uint16_t, uint32_t, pid_t,
+			    int, void *, uint16_t);
+void			 evbuf_enqueue(struct evbuf *, struct ibuf *);
+void			 evbuf_event_add(struct evbuf *);
+void			 evbuf_init(struct evbuf *, int, int (*)(struct thread *), void *);
+void			 evbuf_clear(struct evbuf *);
+struct ldpd_af_conf	*ldp_af_conf_get(struct ldpd_conf *, int);
+struct ldpd_af_global	*ldp_af_global_get(struct ldpd_global *, int);
+int			 ldp_is_dual_stack(struct ldpd_conf *);
+in_addr_t		 ldp_rtr_id_get(struct ldpd_conf *);
+int			 ldp_reload(struct ldpd_conf *);
+void			 ldp_reset_main_conf(struct ldpd_conf *);
+void			 ldp_reset_af_conf(struct ldpd_conf *, int);
+struct ldpd_conf	*ldp_dup_config(struct ldpd_conf *);
+void			 ldp_clear_config(struct ldpd_conf *);
+void			 ldp_clear_l2vpn_config(struct l2vpn *);
+void			 merge_config(struct ldpd_conf *, struct ldpd_conf *);
+struct ldpd_conf	*config_new_empty(void);
+void			 config_clear(struct ldpd_conf *);
+
+/* socket.c */
+int		 ldp_create_socket(int, enum socket_type);
+void		 sock_set_blockmode(int, enum blockmodes);
+void		 sock_set_recvbuf(int);
+int		 sock_set_reuse(int, int);
+int		 sock_set_bindany(int, int);
+#ifndef __OpenBSD__
+int		 sock_set_md5sig(int, int, union ldpd_addr *, const char *);
+#endif
+int		 sock_set_ipv4_mcast_ttl(int, uint8_t);
+int		 sock_set_ipv4_tos(int, int);
+int		 sock_set_ipv4_pktinfo(int, int);
+int		 sock_set_ipv4_recvdstaddr(int, int);
+int		 sock_set_ipv4_recvif(int, int);
+int		 sock_set_ipv4_mcast(struct iface *);
+int		 sock_set_ipv4_mcast_loop(int);
+int		 sock_set_ipv6_dscp(int, int);
+int		 sock_set_ipv6_pktinfo(int, int);
+int		 sock_set_ipv6_mcast(struct iface *);
+int		 sock_set_ipv6_mcast_loop(int);
+
+/* quagga */
+extern struct thread_master	*master;
+
+/* ldp_zebra.c */
+void		ldp_zebra_init(struct thread_master *);
+
+/* compatibility */
+#ifndef __OpenBSD__
+#define __IPV6_ADDR_MC_SCOPE(a)		((a)->s6_addr[1] & 0x0f)
+#define __IPV6_ADDR_SCOPE_INTFACELOCAL	0x01
+#define	IN6_IS_ADDR_MC_INTFACELOCAL(a)	\
+	(IN6_IS_ADDR_MULTICAST(a) &&	\
+	(__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_INTFACELOCAL))
+#endif
+
+#endif	/* _LDPD_H_ */
diff --git a/ldpd/ldpe.c b/ldpd/ldpe.c
new file mode 100644
index 0000000..869f534
--- /dev/null
+++ b/ldpd/ldpe.c
@@ -0,0 +1,855 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2005 Claudio Jeker <claudio@openbsd.org>
+ * Copyright (c) 2004, 2008 Esben Norby <norby@openbsd.org>
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "lde.h"
+#include "control.h"
+#include "log.h"
+
+#include <lib/log.h>
+#include "memory.h"
+#include "privs.h"
+#include "sigevent.h"
+
+static void	 ldpe_shutdown(void);
+static int	 ldpe_dispatch_main(struct thread *);
+static int	 ldpe_dispatch_lde(struct thread *);
+#ifdef __OpenBSD__
+static int	 ldpe_dispatch_pfkey(struct thread *);
+#endif
+static void	 ldpe_setup_sockets(int, int, int, int);
+static void	 ldpe_close_sockets(int);
+static void	 ldpe_iface_af_ctl(struct ctl_conn *, int, unsigned int);
+
+struct ldpd_conf	*leconf;
+#ifdef __OpenBSD__
+struct ldpd_sysdep	 sysdep;
+#endif
+
+static struct imsgev	*iev_main;
+static struct imsgev	*iev_lde;
+#ifdef __OpenBSD__
+static struct thread	*pfkey_ev;
+#endif
+
+/* Master of threads. */
+struct thread_master *master;
+
+/* ldpe privileges */
+static zebra_capabilities_t _caps_p [] =
+{
+	ZCAP_BIND,
+	ZCAP_NET_ADMIN
+};
+
+struct zebra_privs_t ldpe_privs =
+{
+#if defined(QUAGGA_USER) && defined(QUAGGA_GROUP)
+	.user = QUAGGA_USER,
+	.group = QUAGGA_GROUP,
+#endif
+#if defined(VTY_GROUP)
+	.vty_group = VTY_GROUP,
+#endif
+	.caps_p = _caps_p,
+	.cap_num_p = array_size(_caps_p),
+	.cap_num_i = 0
+};
+
+/* SIGINT / SIGTERM handler. */
+static void
+sigint(void)
+{
+	ldpe_shutdown();
+}
+
+static struct quagga_signal_t ldpe_signals[] =
+{
+	{
+		.signal = SIGINT,
+		.handler = &sigint,
+	},
+	{
+		.signal = SIGTERM,
+		.handler = &sigint,
+	},
+};
+
+/* label distribution protocol engine */
+pid_t
+ldpe(void)
+{
+	struct thread		 thread;
+
+	leconf = config_new_empty();
+
+	zlog_set_level(NULL, ZLOG_DEST_STDOUT, zlog_default->default_lvl);
+
+#ifdef HAVE_SETPROCTITLE
+	setproctitle("ldp engine");
+#endif
+	ldpd_process = PROC_LDP_ENGINE;
+
+	LIST_INIT(&global.addr_list);
+	LIST_INIT(&global.adj_list);
+	TAILQ_INIT(&global.pending_conns);
+	if (inet_pton(AF_INET, AllRouters_v4, &global.mcast_addr_v4) != 1)
+		fatal("inet_pton");
+	if (inet_pton(AF_INET6, AllRouters_v6, &global.mcast_addr_v6) != 1)
+		fatal("inet_pton");
+#ifdef __OpenBSD__
+	global.pfkeysock = pfkey_init();
+#endif
+
+	/* drop privileges */
+	zprivs_init(&ldpe_privs);
+
+	if (control_init() == -1)
+		fatalx("control socket setup failed");
+
+#ifdef HAVE_PLEDGE
+	if (pledge("stdio cpath inet mcast recvfd", NULL) == -1)
+		fatal("pledge");
+#endif
+
+  	master = thread_master_create();
+	accept_init();
+
+	/* setup signal handler */
+	signal_init(master, array_size(ldpe_signals), ldpe_signals);
+
+	/* setup pipe and event handler to the parent process */
+	if ((iev_main = malloc(sizeof(struct imsgev))) == NULL)
+		fatal(NULL);
+	imsg_init(&iev_main->ibuf, 3);
+	iev_main->handler_read = ldpe_dispatch_main;
+	iev_main->ev_read = thread_add_read(master, iev_main->handler_read,
+	    iev_main, iev_main->ibuf.fd);
+	iev_main->handler_write = ldp_write_handler;
+	iev_main->ev_write = NULL;
+
+#ifdef __OpenBSD__
+	if (sysdep.no_pfkey == 0)
+		pfkey_ev = thread_add_read(master, ldpe_dispatch_pfkey,
+		    NULL, global.pfkeysock);
+#endif
+
+	/* mark sockets as closed */
+	global.ipv4.ldp_disc_socket = -1;
+	global.ipv4.ldp_edisc_socket = -1;
+	global.ipv4.ldp_session_socket = -1;
+	global.ipv6.ldp_disc_socket = -1;
+	global.ipv6.ldp_edisc_socket = -1;
+	global.ipv6.ldp_session_socket = -1;
+
+	/* listen on ldpd control socket */
+	TAILQ_INIT(&ctl_conns);
+	control_listen();
+
+	if ((pkt_ptr = calloc(1, IBUF_READ_SIZE)) == NULL)
+		fatal(__func__);
+
+	/* Fetch next active thread. */
+	while (thread_fetch(master, &thread))
+		thread_call(&thread);
+
+	/* NOTREACHED */
+	return (0);
+}
+
+static void
+ldpe_shutdown(void)
+{
+	struct if_addr		*if_addr;
+	struct adj		*adj;
+
+	control_cleanup();
+	config_clear(leconf);
+
+#ifdef __OpenBSD__
+	if (sysdep.no_pfkey == 0) {
+		THREAD_READ_OFF(pfkey_ev);
+		close(global.pfkeysock);
+	}
+#endif
+	ldpe_close_sockets(AF_INET);
+	ldpe_close_sockets(AF_INET6);
+
+	/* remove addresses from global list */
+	while ((if_addr = LIST_FIRST(&global.addr_list)) != NULL) {
+		LIST_REMOVE(if_addr, entry);
+		free(if_addr);
+	}
+	while ((adj = LIST_FIRST(&global.adj_list)) != NULL)
+		adj_del(adj);
+
+	/* clean up */
+	msgbuf_write(&iev_lde->ibuf.w);
+	msgbuf_clear(&iev_lde->ibuf.w);
+	free(iev_lde);
+	msgbuf_write(&iev_main->ibuf.w);
+	msgbuf_clear(&iev_main->ibuf.w);
+	free(iev_main);
+	free(pkt_ptr);
+
+	log_info("ldp engine exiting");
+	_exit(0);
+}
+
+/* imesg */
+int
+ldpe_imsg_compose_parent(int type, pid_t pid, void *data, uint16_t datalen)
+{
+	return (imsg_compose_event(iev_main, type, 0, pid, -1, data, datalen));
+}
+
+int
+ldpe_imsg_compose_lde(int type, uint32_t peerid, pid_t pid, void *data,
+    uint16_t datalen)
+{
+	return (imsg_compose_event(iev_lde, type, peerid, pid, -1,
+	    data, datalen));
+}
+
+/* ARGSUSED */
+static int
+ldpe_dispatch_main(struct thread *thread)
+{
+	static struct ldpd_conf	*nconf;
+	struct iface		*niface;
+	struct tnbr		*ntnbr;
+	struct nbr_params	*nnbrp;
+	static struct l2vpn	*nl2vpn;
+	struct l2vpn_if		*nlif;
+	struct l2vpn_pw		*npw;
+	struct imsg		 imsg;
+	int			 fd = THREAD_FD(thread);
+	struct imsgev		*iev = THREAD_ARG(thread);
+	struct imsgbuf		*ibuf = &iev->ibuf;
+	struct iface		*iface = NULL;
+	struct kif		*kif;
+	int			 af;
+	enum socket_type	*socket_type;
+	static int		 disc_socket = -1;
+	static int		 edisc_socket = -1;
+	static int		 session_socket = -1;
+	int			 n, shut = 0;
+
+	iev->ev_read = NULL;
+
+	if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
+		fatal("imsg_read error");
+	if (n == 0)	/* connection closed */
+		shut = 1;
+
+	for (;;) {
+		if ((n = imsg_get(ibuf, &imsg)) == -1)
+			fatal("ldpe_dispatch_main: imsg_get error");
+		if (n == 0)
+			break;
+
+		switch (imsg.hdr.type) {
+		case IMSG_IFSTATUS:
+			if (imsg.hdr.len != IMSG_HEADER_SIZE +
+			    sizeof(struct kif))
+				fatalx("IFSTATUS imsg with wrong len");
+			kif = imsg.data;
+
+			iface = if_lookup_name(leconf, kif->ifname);
+			if (!iface)
+				break;
+
+			if_update_info(iface, kif);
+			if_update(iface, AF_UNSPEC);
+			break;
+		case IMSG_NEWADDR:
+			if (imsg.hdr.len != IMSG_HEADER_SIZE +
+			    sizeof(struct kaddr))
+				fatalx("NEWADDR imsg with wrong len");
+
+			if_addr_add(imsg.data);
+			break;
+		case IMSG_DELADDR:
+			if (imsg.hdr.len != IMSG_HEADER_SIZE +
+			    sizeof(struct kaddr))
+				fatalx("DELADDR imsg with wrong len");
+
+			if_addr_del(imsg.data);
+			break;
+		case IMSG_SOCKET_IPC:
+			if (iev_lde) {
+				log_warnx("%s: received unexpected imsg fd "
+				    "to lde", __func__);
+				break;
+			}
+			if ((fd = imsg.fd) == -1) {
+				log_warnx("%s: expected to receive imsg fd to "
+				    "lde but didn't receive any", __func__);
+				break;
+			}
+
+			if ((iev_lde = malloc(sizeof(struct imsgev))) == NULL)
+				fatal(NULL);
+			imsg_init(&iev_lde->ibuf, fd);
+			iev_lde->handler_read = ldpe_dispatch_lde;
+			iev_lde->ev_read = thread_add_read(master,
+			    iev_lde->handler_read, iev_lde, iev_lde->ibuf.fd);
+			iev_lde->handler_write = ldp_write_handler;
+			iev_lde->ev_write = NULL;
+			break;
+		case IMSG_CLOSE_SOCKETS:
+			af = imsg.hdr.peerid;
+
+			ldpe_close_sockets(af);
+			if_update_all(af);
+			tnbr_update_all(af);
+
+			disc_socket = -1;
+			edisc_socket = -1;
+			session_socket = -1;
+			ldpe_imsg_compose_parent(IMSG_REQUEST_SOCKETS, af,
+			    NULL, 0);
+			break;
+		case IMSG_SOCKET_NET:
+			if (imsg.hdr.len != IMSG_HEADER_SIZE +
+			    sizeof(enum socket_type))
+				fatalx("SOCKET_NET imsg with wrong len");
+			socket_type = imsg.data;
+
+			switch (*socket_type) {
+			case LDP_SOCKET_DISC:
+				disc_socket = imsg.fd;
+				break;
+			case LDP_SOCKET_EDISC:
+				edisc_socket = imsg.fd;
+				break;
+			case LDP_SOCKET_SESSION:
+				session_socket = imsg.fd;
+				break;
+			}
+			break;
+		case IMSG_SETUP_SOCKETS:
+			af = imsg.hdr.peerid;
+			if (disc_socket == -1 || edisc_socket == -1 ||
+			    session_socket == -1) {
+				if (disc_socket != -1)
+					close(disc_socket);
+				if (edisc_socket != -1)
+					close(edisc_socket);
+				if (session_socket != -1)
+					close(session_socket);
+				break;
+			}
+
+			ldpe_setup_sockets(af, disc_socket, edisc_socket,
+			    session_socket);
+			if_update_all(af);
+			tnbr_update_all(af);
+			break;
+		case IMSG_RTRID_UPDATE:
+			memcpy(&global.rtr_id, imsg.data,
+			    sizeof(global.rtr_id));
+			if (leconf->rtr_id.s_addr == INADDR_ANY) {
+				ldpe_reset_nbrs(AF_INET);
+				ldpe_reset_nbrs(AF_INET6);
+			}
+			if_update_all(AF_UNSPEC);
+			tnbr_update_all(AF_UNSPEC);
+			break;
+		case IMSG_RECONF_CONF:
+			if ((nconf = malloc(sizeof(struct ldpd_conf))) ==
+			    NULL)
+				fatal(NULL);
+			memcpy(nconf, imsg.data, sizeof(struct ldpd_conf));
+
+			LIST_INIT(&nconf->iface_list);
+			LIST_INIT(&nconf->tnbr_list);
+			LIST_INIT(&nconf->nbrp_list);
+			LIST_INIT(&nconf->l2vpn_list);
+			break;
+		case IMSG_RECONF_IFACE:
+			if ((niface = malloc(sizeof(struct iface))) == NULL)
+				fatal(NULL);
+			memcpy(niface, imsg.data, sizeof(struct iface));
+
+			LIST_INIT(&niface->addr_list);
+			LIST_INIT(&niface->ipv4.adj_list);
+			LIST_INIT(&niface->ipv6.adj_list);
+			niface->ipv4.iface = niface;
+			niface->ipv6.iface = niface;
+
+			LIST_INSERT_HEAD(&nconf->iface_list, niface, entry);
+			break;
+		case IMSG_RECONF_TNBR:
+			if ((ntnbr = malloc(sizeof(struct tnbr))) == NULL)
+				fatal(NULL);
+			memcpy(ntnbr, imsg.data, sizeof(struct tnbr));
+
+			LIST_INSERT_HEAD(&nconf->tnbr_list, ntnbr, entry);
+			break;
+		case IMSG_RECONF_NBRP:
+			if ((nnbrp = malloc(sizeof(struct nbr_params))) == NULL)
+				fatal(NULL);
+			memcpy(nnbrp, imsg.data, sizeof(struct nbr_params));
+
+			LIST_INSERT_HEAD(&nconf->nbrp_list, nnbrp, entry);
+			break;
+		case IMSG_RECONF_L2VPN:
+			if ((nl2vpn = malloc(sizeof(struct l2vpn))) == NULL)
+				fatal(NULL);
+			memcpy(nl2vpn, imsg.data, sizeof(struct l2vpn));
+
+			LIST_INIT(&nl2vpn->if_list);
+			LIST_INIT(&nl2vpn->pw_list);
+			LIST_INIT(&nl2vpn->pw_inactive_list);
+
+			LIST_INSERT_HEAD(&nconf->l2vpn_list, nl2vpn, entry);
+			break;
+		case IMSG_RECONF_L2VPN_IF:
+			if ((nlif = malloc(sizeof(struct l2vpn_if))) == NULL)
+				fatal(NULL);
+			memcpy(nlif, imsg.data, sizeof(struct l2vpn_if));
+
+			nlif->l2vpn = nl2vpn;
+			LIST_INSERT_HEAD(&nl2vpn->if_list, nlif, entry);
+			break;
+		case IMSG_RECONF_L2VPN_PW:
+			if ((npw = malloc(sizeof(struct l2vpn_pw))) == NULL)
+				fatal(NULL);
+			memcpy(npw, imsg.data, sizeof(struct l2vpn_pw));
+
+			npw->l2vpn = nl2vpn;
+			LIST_INSERT_HEAD(&nl2vpn->pw_list, npw, entry);
+			break;
+		case IMSG_RECONF_L2VPN_IPW:
+			if ((npw = malloc(sizeof(struct l2vpn_pw))) == NULL)
+				fatal(NULL);
+			memcpy(npw, imsg.data, sizeof(struct l2vpn_pw));
+
+			npw->l2vpn = nl2vpn;
+			LIST_INSERT_HEAD(&nl2vpn->pw_inactive_list, npw, entry);
+			break;
+		case IMSG_RECONF_END:
+			merge_config(leconf, nconf);
+			nconf = NULL;
+			break;
+		case IMSG_CTL_END:
+			control_imsg_relay(&imsg);
+			break;
+		default:
+			log_debug("ldpe_dispatch_main: error handling imsg %d",
+			    imsg.hdr.type);
+			break;
+		}
+		imsg_free(&imsg);
+	}
+	if (!shut)
+		imsg_event_add(iev);
+	else {
+		/* this pipe is dead, so remove the event handlers and exit */
+		THREAD_READ_OFF(iev->ev_read);
+		THREAD_WRITE_OFF(iev->ev_write);
+		ldpe_shutdown();
+	}
+
+	return (0);
+}
+
+/* ARGSUSED */
+static int
+ldpe_dispatch_lde(struct thread *thread)
+{
+	struct imsgev		*iev = THREAD_ARG(thread);
+	struct imsgbuf		*ibuf = &iev->ibuf;
+	struct imsg		 imsg;
+	struct map		 map;
+	struct notify_msg	 nm;
+	int			 n, shut = 0;
+	struct nbr		*nbr = NULL;
+
+	iev->ev_read = NULL;
+
+	if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
+		fatal("imsg_read error");
+	if (n == 0)	/* connection closed */
+		shut = 1;
+
+	for (;;) {
+		if ((n = imsg_get(ibuf, &imsg)) == -1)
+			fatal("ldpe_dispatch_lde: imsg_get error");
+		if (n == 0)
+			break;
+
+		switch (imsg.hdr.type) {
+		case IMSG_MAPPING_ADD:
+		case IMSG_RELEASE_ADD:
+		case IMSG_REQUEST_ADD:
+		case IMSG_WITHDRAW_ADD:
+			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(map))
+				fatalx("invalid size of map request");
+			memcpy(&map, imsg.data, sizeof(map));
+
+			nbr = nbr_find_peerid(imsg.hdr.peerid);
+			if (nbr == NULL) {
+				log_debug("ldpe_dispatch_lde: cannot find "
+				    "neighbor");
+				break;
+			}
+			if (nbr->state != NBR_STA_OPER)
+				break;
+
+			switch (imsg.hdr.type) {
+			case IMSG_MAPPING_ADD:
+				mapping_list_add(&nbr->mapping_list, &map);
+				break;
+			case IMSG_RELEASE_ADD:
+				mapping_list_add(&nbr->release_list, &map);
+				break;
+			case IMSG_REQUEST_ADD:
+				mapping_list_add(&nbr->request_list, &map);
+				break;
+			case IMSG_WITHDRAW_ADD:
+				mapping_list_add(&nbr->withdraw_list, &map);
+				break;
+			}
+			break;
+		case IMSG_MAPPING_ADD_END:
+		case IMSG_RELEASE_ADD_END:
+		case IMSG_REQUEST_ADD_END:
+		case IMSG_WITHDRAW_ADD_END:
+			nbr = nbr_find_peerid(imsg.hdr.peerid);
+			if (nbr == NULL) {
+				log_debug("ldpe_dispatch_lde: cannot find "
+				    "neighbor");
+				break;
+			}
+			if (nbr->state != NBR_STA_OPER)
+				break;
+
+			switch (imsg.hdr.type) {
+			case IMSG_MAPPING_ADD_END:
+				send_labelmessage(nbr, MSG_TYPE_LABELMAPPING,
+				    &nbr->mapping_list);
+				break;
+			case IMSG_RELEASE_ADD_END:
+				send_labelmessage(nbr, MSG_TYPE_LABELRELEASE,
+				    &nbr->release_list);
+				break;
+			case IMSG_REQUEST_ADD_END:
+				send_labelmessage(nbr, MSG_TYPE_LABELREQUEST,
+				    &nbr->request_list);
+				break;
+			case IMSG_WITHDRAW_ADD_END:
+				send_labelmessage(nbr, MSG_TYPE_LABELWITHDRAW,
+				    &nbr->withdraw_list);
+				break;
+			}
+			break;
+		case IMSG_NOTIFICATION_SEND:
+			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(nm))
+				fatalx("invalid size of OE request");
+			memcpy(&nm, imsg.data, sizeof(nm));
+
+			nbr = nbr_find_peerid(imsg.hdr.peerid);
+			if (nbr == NULL) {
+				log_debug("ldpe_dispatch_lde: cannot find "
+				    "neighbor");
+				break;
+			}
+			if (nbr->state != NBR_STA_OPER)
+				break;
+
+			send_notification_full(nbr->tcp, &nm);
+			break;
+		case IMSG_CTL_END:
+		case IMSG_CTL_SHOW_LIB:
+		case IMSG_CTL_SHOW_L2VPN_PW:
+		case IMSG_CTL_SHOW_L2VPN_BINDING:
+			control_imsg_relay(&imsg);
+			break;
+		default:
+			log_debug("ldpe_dispatch_lde: error handling imsg %d",
+			    imsg.hdr.type);
+			break;
+		}
+		imsg_free(&imsg);
+	}
+	if (!shut)
+		imsg_event_add(iev);
+	else {
+		/* this pipe is dead, so remove the event handlers and exit */
+		THREAD_READ_OFF(iev->ev_read);
+		THREAD_WRITE_OFF(iev->ev_write);
+		ldpe_shutdown();
+	}
+
+	return (0);
+}
+
+#ifdef __OpenBSD__
+/* ARGSUSED */
+static int
+ldpe_dispatch_pfkey(struct thread *thread)
+{
+	int	 fd = THREAD_FD(thread);
+
+	pfkey_ev = thread_add_read(master, ldpe_dispatch_pfkey,
+	    NULL, global.pfkeysock);
+
+	if (pfkey_read(fd, NULL) == -1)
+		fatal("pfkey_read failed, exiting...");
+
+	return (0);
+}
+#endif /* __OpenBSD__ */
+
+static void
+ldpe_setup_sockets(int af, int disc_socket, int edisc_socket,
+    int session_socket)
+{
+	struct ldpd_af_global	*af_global;
+
+	af_global = ldp_af_global_get(&global, af);
+
+	/* discovery socket */
+	af_global->ldp_disc_socket = disc_socket;
+	af_global->disc_ev = thread_add_read(master, disc_recv_packet,
+	    &af_global->disc_ev, af_global->ldp_disc_socket);
+
+	/* extended discovery socket */
+	af_global->ldp_edisc_socket = edisc_socket;
+	af_global->edisc_ev = thread_add_read(master, disc_recv_packet,
+	    &af_global->edisc_ev, af_global->ldp_edisc_socket);
+
+	/* session socket */
+	af_global->ldp_session_socket = session_socket;
+	accept_add(af_global->ldp_session_socket, session_accept, NULL);
+}
+
+static void
+ldpe_close_sockets(int af)
+{
+	struct ldpd_af_global	*af_global;
+
+	af_global = ldp_af_global_get(&global, af);
+
+	/* discovery socket */
+	THREAD_READ_OFF(af_global->disc_ev);
+	if (af_global->ldp_disc_socket != -1) {
+		close(af_global->ldp_disc_socket);
+		af_global->ldp_disc_socket = -1;
+	}
+
+	/* extended discovery socket */
+	THREAD_READ_OFF(af_global->edisc_ev);
+	if (af_global->ldp_edisc_socket != -1) {
+		close(af_global->ldp_edisc_socket);
+		af_global->ldp_edisc_socket = -1;
+	}
+
+	/* session socket */
+	if (af_global->ldp_session_socket != -1) {
+		accept_del(af_global->ldp_session_socket);
+		close(af_global->ldp_session_socket);
+		af_global->ldp_session_socket = -1;
+	}
+}
+
+void
+ldpe_reset_nbrs(int af)
+{
+	struct nbr		*nbr;
+
+	RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
+		if (nbr->af == af)
+			session_shutdown(nbr, S_SHUTDOWN, 0, 0);
+	}
+}
+
+void
+ldpe_reset_ds_nbrs(void)
+{
+	struct nbr		*nbr;
+
+	RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
+		if (nbr->ds_tlv)
+			session_shutdown(nbr, S_SHUTDOWN, 0, 0);
+	}
+}
+
+void
+ldpe_remove_dynamic_tnbrs(int af)
+{
+	struct tnbr		*tnbr, *safe;
+
+	LIST_FOREACH_SAFE(tnbr, &leconf->tnbr_list, entry, safe) {
+		if (tnbr->af != af)
+			continue;
+
+		tnbr->flags &= ~F_TNBR_DYNAMIC;
+		tnbr_check(tnbr);
+	}
+}
+
+void
+ldpe_stop_init_backoff(int af)
+{
+	struct nbr		*nbr;
+
+	RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
+		if (nbr->af == af && nbr_pending_idtimer(nbr)) {
+			nbr_stop_idtimer(nbr);
+			nbr_establish_connection(nbr);
+		}
+	}
+}
+
+static void
+ldpe_iface_af_ctl(struct ctl_conn *c, int af, unsigned int idx)
+{
+	struct iface		*iface;
+	struct iface_af		*ia;
+	struct ctl_iface	*ictl;
+
+	LIST_FOREACH(iface, &leconf->iface_list, entry) {
+		if (idx == 0 || idx == iface->ifindex) {
+			ia = iface_af_get(iface, af);
+			if (!ia->enabled)
+				continue;
+
+			ictl = if_to_ctl(ia);
+			imsg_compose_event(&c->iev,
+			     IMSG_CTL_SHOW_INTERFACE,
+			    0, 0, -1, ictl, sizeof(struct ctl_iface));
+		}
+	}
+}
+
+void
+ldpe_iface_ctl(struct ctl_conn *c, unsigned int idx)
+{
+	ldpe_iface_af_ctl(c, AF_INET, idx);
+	ldpe_iface_af_ctl(c, AF_INET6, idx);
+}
+
+void
+ldpe_adj_ctl(struct ctl_conn *c)
+{
+	struct iface		*iface;
+	struct tnbr		*tnbr;
+	struct adj		*adj;
+	struct ctl_adj		*actl;
+	struct ctl_adj_if	 ictl;
+	struct ctl_adj_tnbr	 tctl;
+
+	LIST_FOREACH(iface, &leconf->iface_list, entry) {
+		memset(&ictl, 0, sizeof(ictl));
+		ictl.active_v4 = (iface->ipv4.state == IF_STA_ACTIVE);
+		ictl.active_v6 = (iface->ipv6.state == IF_STA_ACTIVE);
+
+		if (!ictl.active_v4 && !ictl.active_v6)
+			continue;
+
+		strlcpy(ictl.name, iface->name, sizeof(ictl.name));
+		imsg_compose_event(&c->iev, IMSG_CTL_SHOW_DISC_IFACE, 0, 0,
+		    -1, &ictl, sizeof(ictl));
+
+		LIST_FOREACH(adj, &iface->ipv4.adj_list, ia_entry) {
+			actl = adj_to_ctl(adj);
+			imsg_compose_event(&c->iev, IMSG_CTL_SHOW_DISCOVERY,
+			    0, 0, -1, actl, sizeof(struct ctl_adj));
+		}
+		LIST_FOREACH(adj, &iface->ipv6.adj_list, ia_entry) {
+			actl = adj_to_ctl(adj);
+			imsg_compose_event(&c->iev, IMSG_CTL_SHOW_DISCOVERY,
+			    0, 0, -1, actl, sizeof(struct ctl_adj));
+		}
+	}
+
+	LIST_FOREACH(tnbr, &leconf->tnbr_list, entry) {
+		memset(&tctl, 0, sizeof(tctl));
+		tctl.af = tnbr->af;
+		tctl.addr = tnbr->addr;
+		imsg_compose_event(&c->iev, IMSG_CTL_SHOW_DISC_TNBR, 0, 0,
+		    -1, &tctl, sizeof(tctl));
+
+		if (tnbr->adj == NULL)
+			continue;
+
+		actl = adj_to_ctl(tnbr->adj);
+		imsg_compose_event(&c->iev, IMSG_CTL_SHOW_DISCOVERY, 0, 0,
+		    -1, actl, sizeof(struct ctl_adj));
+	}
+
+	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
+}
+
+void
+ldpe_nbr_ctl(struct ctl_conn *c)
+{
+	struct adj	*adj;
+	struct ctl_adj	*actl;
+	struct nbr	*nbr;
+	struct ctl_nbr	*nctl;
+
+	RB_FOREACH(nbr, nbr_addr_head, &nbrs_by_addr) {
+		if (nbr->state == NBR_STA_PRESENT)
+			continue;
+
+		LIST_FOREACH(adj, &nbr->adj_list, nbr_entry) {
+			actl = adj_to_ctl(adj);
+			imsg_compose_event(&c->iev, IMSG_CTL_SHOW_NBR_DISC,
+			    0, 0, -1, actl, sizeof(struct ctl_adj));
+		}
+
+		nctl = nbr_to_ctl(nbr);
+		imsg_compose_event(&c->iev, IMSG_CTL_SHOW_NBR, 0, 0, -1, nctl,
+		    sizeof(struct ctl_nbr));
+	}
+	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
+}
+
+void
+mapping_list_add(struct mapping_head *mh, struct map *map)
+{
+	struct mapping_entry	*me;
+
+	me = calloc(1, sizeof(*me));
+	if (me == NULL)
+		fatal(__func__);
+	me->map = *map;
+
+	TAILQ_INSERT_TAIL(mh, me, entry);
+}
+
+void
+mapping_list_clr(struct mapping_head *mh)
+{
+	struct mapping_entry	*me;
+
+	while ((me = TAILQ_FIRST(mh)) != NULL) {
+		TAILQ_REMOVE(mh, me, entry);
+		free(me);
+	}
+}
diff --git a/ldpd/ldpe.h b/ldpd/ldpe.h
new file mode 100644
index 0000000..d8e8cde
--- /dev/null
+++ b/ldpd/ldpe.h
@@ -0,0 +1,282 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _LDPE_H_
+#define _LDPE_H_
+
+#include "openbsd-queue.h"
+#include "openbsd-tree.h"
+#ifdef __OpenBSD__
+#include <net/pfkeyv2.h>
+#endif
+
+#include "ldpd.h"
+
+#define min(x,y) ((x) <= (y) ? (x) : (y))
+#define max(x,y) ((x) > (y) ? (x) : (y))
+
+struct hello_source {
+	enum hello_type		 type;
+	struct {
+		struct iface_af	*ia;
+		union ldpd_addr	 src_addr;
+	} link;
+	struct tnbr		*target;
+};
+
+struct adj {
+	LIST_ENTRY(adj)		 global_entry;
+	LIST_ENTRY(adj)		 nbr_entry;
+	LIST_ENTRY(adj)		 ia_entry;
+	struct in_addr		 lsr_id;
+	struct nbr		*nbr;
+	int			 ds_tlv;
+	struct hello_source	 source;
+	struct thread		*inactivity_timer;
+	uint16_t		 holdtime;
+	union ldpd_addr		 trans_addr;
+};
+
+struct tcp_conn {
+	struct nbr		*nbr;
+	int			 fd;
+	struct ibuf_read	*rbuf;
+	struct evbuf		 wbuf;
+	struct thread		*rev;
+	in_port_t		 lport;
+	in_port_t		 rport;
+};
+
+struct nbr {
+	RB_ENTRY(nbr)		 id_tree, addr_tree, pid_tree;
+	struct tcp_conn		*tcp;
+	LIST_HEAD(, adj)	 adj_list;	/* adjacencies */
+	struct thread		*ev_connect;
+	struct thread		*keepalive_timer;
+	struct thread		*keepalive_timeout;
+	struct thread		*initdelay_timer;
+
+	struct mapping_head	 mapping_list;
+	struct mapping_head	 withdraw_list;
+	struct mapping_head	 request_list;
+	struct mapping_head	 release_list;
+	struct mapping_head	 abortreq_list;
+
+	uint32_t		 peerid;	/* unique ID in DB */
+	int			 af;
+	int			 ds_tlv;
+	int			 v4_enabled;	/* announce/process v4 msgs */
+	int			 v6_enabled;	/* announce/process v6 msgs */
+	struct in_addr		 id;		/* lsr id */
+	union ldpd_addr		 laddr;		/* local address */
+	union ldpd_addr		 raddr;		/* remote address */
+	uint32_t		 raddr_scope;	/* remote address scope (v6) */
+	time_t			 uptime;
+	int			 fd;
+	int			 state;
+	int			 idtimer_cnt;
+	uint16_t		 keepalive;
+	uint16_t		 max_pdu_len;
+
+	struct {
+		uint8_t			established;
+		uint32_t		spi_in;
+		uint32_t		spi_out;
+		enum auth_method	method;
+		char			md5key[TCP_MD5_KEY_LEN];
+	} auth;
+};
+RB_HEAD(nbr_id_head, nbr);
+RB_PROTOTYPE(nbr_id_head, nbr, id_tree, nbr_id_compare)
+RB_HEAD(nbr_addr_head, nbr);
+RB_PROTOTYPE(nbr_addr_head, nbr, addr_tree, nbr_addr_compare)
+RB_HEAD(nbr_pid_head, nbr);
+RB_PROTOTYPE(nbr_pid_head, nbr, pid_tree, nbr_pid_compare)
+
+struct pending_conn {
+	TAILQ_ENTRY(pending_conn)	 entry;
+	int				 fd;
+	int				 af;
+	union ldpd_addr			 addr;
+	struct thread			*ev_timeout;
+};
+#define PENDING_CONN_TIMEOUT	5
+
+struct mapping_entry {
+	TAILQ_ENTRY(mapping_entry)	entry;
+	struct map			map;
+};
+
+struct ldpd_sysdep {
+	uint8_t		no_pfkey;
+	uint8_t		no_md5sig;
+};
+
+extern struct ldpd_conf		*leconf;
+extern struct ldpd_sysdep	 sysdep;
+extern struct nbr_id_head	 nbrs_by_id;
+extern struct nbr_addr_head	 nbrs_by_addr;
+extern struct nbr_pid_head	 nbrs_by_pid;
+
+/* accept.c */
+void	accept_init(void);
+int	accept_add(int, int (*)(struct thread *), void *);
+void	accept_del(int);
+void	accept_pause(void);
+void	accept_unpause(void);
+
+/* hello.c */
+int	 send_hello(enum hello_type, struct iface_af *, struct tnbr *);
+void	 recv_hello(struct in_addr, struct ldp_msg *, int, union ldpd_addr *,
+	    struct iface *, int, char *, uint16_t);
+
+/* init.c */
+void	 send_init(struct nbr *);
+int	 recv_init(struct nbr *, char *, uint16_t);
+
+/* keepalive.c */
+void	 send_keepalive(struct nbr *);
+int	 recv_keepalive(struct nbr *, char *, uint16_t);
+
+/* notification.c */
+void	 send_notification_full(struct tcp_conn *, struct notify_msg *);
+void	 send_notification(uint32_t, struct tcp_conn *, uint32_t,
+	    uint32_t);
+void	 send_notification_nbr(struct nbr *, uint32_t, uint32_t, uint32_t);
+int	 recv_notification(struct nbr *, char *, uint16_t);
+
+/* address.c */
+void	 send_address(struct nbr *, int, struct if_addr *, int);
+int	 recv_address(struct nbr *, char *, uint16_t);
+
+/* labelmapping.c */
+#define PREFIX_SIZE(x)	(((x) + 7) / 8)
+void	 send_labelmessage(struct nbr *, uint16_t, struct mapping_head *);
+int	 recv_labelmessage(struct nbr *, char *, uint16_t, uint16_t);
+void	 gen_pw_status_tlv(struct ibuf *, uint32_t);
+void	 gen_fec_tlv(struct ibuf *, struct map *);
+int	 tlv_decode_fec_elm(struct nbr *, struct ldp_msg *, char *,
+	    uint16_t, struct map *);
+
+/* ldpe.c */
+pid_t		 ldpe(void);
+int		 ldpe_imsg_compose_parent(int, pid_t, void *,
+		    uint16_t);
+int		 ldpe_imsg_compose_lde(int, uint32_t, pid_t, void *,
+		    uint16_t);
+void		 ldpe_reset_nbrs(int);
+void		 ldpe_reset_ds_nbrs(void);
+void		 ldpe_remove_dynamic_tnbrs(int);
+void		 ldpe_stop_init_backoff(int);
+struct ctl_conn;
+void		 ldpe_iface_ctl(struct ctl_conn *, unsigned int);
+void		 ldpe_adj_ctl(struct ctl_conn *);
+void		 ldpe_nbr_ctl(struct ctl_conn *);
+void		 mapping_list_add(struct mapping_head *, struct map *);
+void		 mapping_list_clr(struct mapping_head *);
+
+/* interface.c */
+struct iface	*if_new(struct kif *);
+void		 if_del(struct iface *);
+struct iface	*if_lookup(struct ldpd_conf *, unsigned short);
+struct iface	*if_lookup_name(struct ldpd_conf *, const char *);
+void		 if_update_info(struct iface *, struct kif *);
+struct iface_af *iface_af_get(struct iface *, int);
+void		 if_addr_add(struct kaddr *);
+void		 if_addr_del(struct kaddr *);
+void		 if_update(struct iface *, int);
+void		 if_update_all(int);
+uint16_t	 if_get_hello_holdtime(struct iface_af *);
+uint16_t	 if_get_hello_interval(struct iface_af *);
+struct ctl_iface *if_to_ctl(struct iface_af *);
+in_addr_t	 if_get_ipv4_addr(struct iface *);
+
+/* adjacency.c */
+struct adj	*adj_new(struct in_addr, struct hello_source *,
+		    union ldpd_addr *);
+void		 adj_del(struct adj *);
+struct adj	*adj_find(struct hello_source *);
+int		 adj_get_af(struct adj *adj);
+void		 adj_start_itimer(struct adj *);
+void		 adj_stop_itimer(struct adj *);
+struct tnbr	*tnbr_new(int, union ldpd_addr *);
+struct tnbr	*tnbr_find(struct ldpd_conf *, int, union ldpd_addr *);
+struct tnbr	*tnbr_check(struct tnbr *);
+void		 tnbr_update(struct tnbr *);
+void		 tnbr_update_all(int);
+uint16_t	 tnbr_get_hello_holdtime(struct tnbr *);
+uint16_t	 tnbr_get_hello_interval(struct tnbr *);
+struct ctl_adj	*adj_to_ctl(struct adj *);
+
+/* neighbor.c */
+int			 nbr_fsm(struct nbr *, enum nbr_event);
+struct nbr		*nbr_new(struct in_addr, int, int, union ldpd_addr *,
+			    uint32_t);
+void			 nbr_del(struct nbr *);
+struct nbr		*nbr_find_ldpid(uint32_t);
+struct nbr		*nbr_find_addr(int, union ldpd_addr *);
+struct nbr		*nbr_find_peerid(uint32_t);
+int			 nbr_adj_count(struct nbr *, int);
+int			 nbr_session_active_role(struct nbr *);
+void			 nbr_stop_ktimer(struct nbr *);
+void			 nbr_stop_ktimeout(struct nbr *);
+void			 nbr_start_idtimer(struct nbr *);
+void			 nbr_stop_idtimer(struct nbr *);
+int			 nbr_pending_idtimer(struct nbr *);
+int			 nbr_pending_connect(struct nbr *);
+int			 nbr_establish_connection(struct nbr *);
+struct nbr_params	*nbr_params_new(struct in_addr);
+struct nbr_params	*nbr_params_find(struct ldpd_conf *, struct in_addr);
+uint16_t		 nbr_get_keepalive(int, struct in_addr);
+struct ctl_nbr		*nbr_to_ctl(struct nbr *);
+void			 nbr_clear_ctl(struct ctl_nbr *);
+
+/* packet.c */
+int			 gen_ldp_hdr(struct ibuf *, uint16_t);
+int			 gen_msg_hdr(struct ibuf *, uint32_t, uint16_t);
+int			 send_packet(int, int, union ldpd_addr *,
+			    struct iface_af *, void *, size_t);
+int			 disc_recv_packet(struct thread *);
+int			 session_accept(struct thread *);
+void			 session_accept_nbr(struct nbr *, int);
+void			 session_shutdown(struct nbr *, uint32_t, uint32_t,
+			    uint32_t);
+void			 session_close(struct nbr *);
+struct tcp_conn		*tcp_new(int, struct nbr *);
+void			 pending_conn_del(struct pending_conn *);
+struct pending_conn	*pending_conn_find(int, union ldpd_addr *);
+
+char	*pkt_ptr;	/* packet buffer */
+
+/* pfkey.c */
+#ifdef __OpenBSD__
+int	pfkey_read(int, struct sadb_msg *);
+int	pfkey_establish(struct nbr *, struct nbr_params *);
+int	pfkey_remove(struct nbr *);
+int	pfkey_init(void);
+#endif
+
+/* l2vpn.c */
+void	ldpe_l2vpn_init(struct l2vpn *);
+void	ldpe_l2vpn_exit(struct l2vpn *);
+void	ldpe_l2vpn_pw_init(struct l2vpn_pw *);
+void	ldpe_l2vpn_pw_exit(struct l2vpn_pw *);
+
+#endif	/* _LDPE_H_ */
diff --git a/ldpd/log.c b/ldpd/log.c
new file mode 100644
index 0000000..dd09740
--- /dev/null
+++ b/ldpd/log.c
@@ -0,0 +1,477 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "lde.h"
+#include "log.h"
+
+#include <lib/log.h>
+
+static const char * const procnames[] = {
+	"parent",
+	"ldpe",
+	"lde"
+};
+
+void
+logit(int pri, const char *fmt, ...)
+{
+	va_list	ap;
+
+	va_start(ap, fmt);
+	vzlog(NULL, pri, fmt, ap);
+	va_end(ap);
+}
+
+void
+log_warn(const char *emsg, ...)
+{
+	char	*nfmt;
+	va_list	 ap;
+
+	/* best effort to even work in out of memory situations */
+	if (emsg == NULL)
+		logit(LOG_CRIT, "%s", strerror(errno));
+	else {
+		va_start(ap, emsg);
+
+		if (asprintf(&nfmt, "%s: %s", emsg, strerror(errno)) == -1) {
+			/* we tried it... */
+			vzlog(NULL, LOG_CRIT, emsg, ap);
+			logit(LOG_CRIT, "%s", strerror(errno));
+		} else {
+			vzlog(NULL, LOG_CRIT, nfmt, ap);
+			free(nfmt);
+		}
+		va_end(ap);
+	}
+}
+
+void
+log_warnx(const char *emsg, ...)
+{
+	va_list	 ap;
+
+	va_start(ap, emsg);
+	vzlog(NULL, LOG_CRIT, emsg, ap);
+	va_end(ap);
+}
+
+void
+log_info(const char *emsg, ...)
+{
+	va_list	 ap;
+
+	va_start(ap, emsg);
+	vzlog(NULL, LOG_INFO, emsg, ap);
+	va_end(ap);
+}
+
+void
+log_notice(const char *emsg, ...)
+{
+	va_list	 ap;
+
+	va_start(ap, emsg);
+	vzlog(NULL, LOG_NOTICE, emsg, ap);
+	va_end(ap);
+}
+
+void
+log_debug(const char *emsg, ...)
+{
+	va_list	 ap;
+
+	va_start(ap, emsg);
+	vzlog(NULL, LOG_DEBUG, emsg, ap);
+	va_end(ap);
+}
+
+void
+fatal(const char *emsg)
+{
+	if (emsg == NULL)
+		logit(LOG_CRIT, "fatal in %s: %s", procnames[ldpd_process],
+		    strerror(errno));
+	else
+		if (errno)
+			logit(LOG_CRIT, "fatal in %s: %s: %s",
+			    procnames[ldpd_process], emsg, strerror(errno));
+		else
+			logit(LOG_CRIT, "fatal in %s: %s",
+			    procnames[ldpd_process], emsg);
+
+	if (ldpd_process == PROC_MAIN)
+		exit(1);
+	else				/* parent copes via SIGCHLD */
+		_exit(1);
+}
+
+void
+fatalx(const char *emsg)
+{
+	errno = 0;
+	fatal(emsg);
+}
+
+#define NUM_LOGS	4
+const char *
+log_sockaddr(void *vp)
+{
+	static char	 buf[NUM_LOGS][NI_MAXHOST];
+	static int	 round = 0;
+	struct sockaddr	*sa = vp;
+
+	round = (round + 1) % NUM_LOGS;
+
+	if (getnameinfo(sa, sockaddr_len(sa), buf[round], NI_MAXHOST, NULL, 0,
+	    NI_NUMERICHOST))
+		return ("(unknown)");
+	else
+		return (buf[round]);
+}
+
+const char *
+log_in6addr(const struct in6_addr *addr)
+{
+	struct sockaddr_in6	sa_in6;
+
+	memset(&sa_in6, 0, sizeof(sa_in6));
+#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
+	sa_in6.sin6_len = sizeof(sa_in6);
+#endif
+	sa_in6.sin6_family = AF_INET6;
+	sa_in6.sin6_addr = *addr;
+
+	recoverscope(&sa_in6);
+
+	return (log_sockaddr(&sa_in6));
+}
+
+const char *
+log_in6addr_scope(const struct in6_addr *addr, unsigned int ifindex)
+{
+	struct sockaddr_in6	sa_in6;
+
+	memset(&sa_in6, 0, sizeof(sa_in6));
+#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
+	sa_in6.sin6_len = sizeof(sa_in6);
+#endif
+	sa_in6.sin6_family = AF_INET6;
+	sa_in6.sin6_addr = *addr;
+
+	addscope(&sa_in6, ifindex);
+
+	return (log_sockaddr(&sa_in6));
+}
+
+const char *
+log_addr(int af, const union ldpd_addr *addr)
+{
+	static char	 buf[NUM_LOGS][INET6_ADDRSTRLEN];
+	static int	 round = 0;
+
+	switch (af) {
+	case AF_INET:
+		round = (round + 1) % NUM_LOGS;
+		if (inet_ntop(AF_INET, &addr->v4, buf[round],
+		    sizeof(buf[round])) == NULL)
+			return ("???");
+		return (buf[round]);
+	case AF_INET6:
+		return (log_in6addr(&addr->v6));
+	default:
+		break;
+	}
+
+	return ("???");
+}
+
+/* names */
+const char *
+af_name(int af)
+{
+	switch (af) {
+	case AF_INET:
+		return ("ipv4");
+	case AF_INET6:
+		return ("ipv6");
+#ifdef AF_MPLS
+	case AF_MPLS:
+		return ("mpls");
+#endif
+	default:
+		return ("UNKNOWN");
+	}
+}
+
+const char *
+socket_name(int type)
+{
+	switch (type) {
+	case LDP_SOCKET_DISC:
+		return ("discovery");
+	case LDP_SOCKET_EDISC:
+		return ("extended discovery");
+	case LDP_SOCKET_SESSION:
+		return ("session");
+	default:
+		return ("UNKNOWN");
+	}
+}
+
+const char *
+nbr_state_name(int state)
+{
+	switch (state) {
+	case NBR_STA_PRESENT:
+		return ("PRESENT");
+	case NBR_STA_INITIAL:
+		return ("INITIALIZED");
+	case NBR_STA_OPENREC:
+		return ("OPENREC");
+	case NBR_STA_OPENSENT:
+		return ("OPENSENT");
+	case NBR_STA_OPER:
+		return ("OPERATIONAL");
+	default:
+		return ("UNKNOWN");
+	}
+}
+
+const char *
+if_state_name(int state)
+{
+	switch (state) {
+	case IF_STA_DOWN:
+		return ("DOWN");
+	case IF_STA_ACTIVE:
+		return ("ACTIVE");
+	default:
+		return ("UNKNOWN");
+	}
+}
+
+const char *
+if_type_name(enum iface_type type)
+{
+	switch (type) {
+	case IF_TYPE_POINTOPOINT:
+		return ("POINTOPOINT");
+	case IF_TYPE_BROADCAST:
+		return ("BROADCAST");
+	}
+	/* NOTREACHED */
+	return ("UNKNOWN");
+}
+
+const char *
+notification_name(uint32_t status)
+{
+	static char buf[16];
+
+	switch (status) {
+	case S_SUCCESS:
+		return ("Success");
+	case S_BAD_LDP_ID:
+		return ("Bad LDP Identifier");
+	case S_BAD_PROTO_VER:
+		return ("Bad Protocol Version");
+	case S_BAD_PDU_LEN:
+		return ("Bad PDU Length");
+	case S_UNKNOWN_MSG:
+		return ("Unknown Message Type");
+	case S_BAD_MSG_LEN:
+		return ("Bad Message Length");
+	case S_UNKNOWN_TLV:
+		return ("Unknown TLV");
+	case S_BAD_TLV_LEN:
+		return ("Bad TLV Length");
+	case S_BAD_TLV_VAL:
+		return ("Malformed TLV Value");
+	case S_HOLDTIME_EXP:
+		return ("Hold Timer Expired");
+	case S_SHUTDOWN:
+		return ("Shutdown");
+	case S_LOOP_DETECTED:
+		return ("Loop Detected");
+	case S_UNKNOWN_FEC:
+		return ("Unknown FEC");
+	case S_NO_ROUTE:
+		return ("No Route");
+	case S_NO_LABEL_RES:
+		return ("No Label Resources");
+	case S_AVAILABLE:
+		return ("Label Resources Available");
+	case S_NO_HELLO:
+		return ("Session Rejected, No Hello");
+	case S_PARM_ADV_MODE:
+		return ("Rejected Advertisement Mode Parameter");
+	case S_MAX_PDU_LEN:
+		return ("Rejected Max PDU Length Parameter");
+	case S_PARM_L_RANGE:
+		return ("Rejected Label Range Parameter");
+	case S_KEEPALIVE_TMR:
+		return ("KeepAlive Timer Expired");
+	case S_LAB_REQ_ABRT:
+		return ("Label Request Aborted");
+	case S_MISS_MSG:
+		return ("Missing Message Parameters");
+	case S_UNSUP_ADDR:
+		return ("Unsupported Address Family");
+	case S_KEEPALIVE_BAD:
+		return ("Bad KeepAlive Time");
+	case S_INTERN_ERR:
+		return ("Internal Error");
+	case S_ILLEGAL_CBIT:
+		return ("Illegal C-Bit");
+	case S_WRONG_CBIT:
+		return ("Wrong C-Bit");
+	case S_INCPT_BITRATE:
+		return ("Incompatible bit-rate");
+	case S_CEP_MISCONF:
+		return ("CEP-TDM mis-configuration");
+	case S_PW_STATUS:
+		return ("PW Status");
+	case S_UNASSIGN_TAI:
+		return ("Unassigned/Unrecognized TAI");
+	case S_MISCONF_ERR:
+		return ("Generic Misconfiguration Error");
+	case S_WITHDRAW_MTHD:
+		return ("Label Withdraw PW Status Method");
+	case S_TRANS_MISMTCH:
+		return ("Transport Connection Mismatch");
+	case S_DS_NONCMPLNCE:
+		return ("Dual-Stack Noncompliance");
+	default:
+		snprintf(buf, sizeof(buf), "[%08x]", status);
+		return (buf);
+	}
+}
+
+const char *
+pw_type_name(uint16_t pw_type)
+{
+	static char buf[64];
+
+	switch (pw_type) {
+	case PW_TYPE_ETHERNET_TAGGED:
+		return ("Eth Tagged");
+	case PW_TYPE_ETHERNET:
+		return ("Ethernet");
+	default:
+		snprintf(buf, sizeof(buf), "[%0x]", pw_type);
+		return (buf);
+	}
+}
+
+char *
+log_hello_src(const struct hello_source *src)
+{
+	static char buffer[64];
+
+	switch (src->type) {
+	case HELLO_LINK:
+		snprintf(buffer, sizeof(buffer), "iface %s",
+		    src->link.ia->iface->name);
+		break;
+	case HELLO_TARGETED:
+		snprintf(buffer, sizeof(buffer), "source %s",
+		    log_addr(src->target->af, &src->target->addr));
+		break;
+	}
+
+	return (buffer);
+}
+
+const char *
+log_map(const struct map *map)
+{
+	static char	buf[64];
+	int		af;
+
+	switch (map->type) {
+	case MAP_TYPE_WILDCARD:
+		if (snprintf(buf, sizeof(buf), "wildcard") < 0)
+			return ("???");
+		break;
+	case MAP_TYPE_PREFIX:
+		switch (map->fec.prefix.af) {
+		case AF_IPV4:
+			af = AF_INET;
+			break;
+		case AF_IPV6:
+			af = AF_INET6;
+			break;
+		default:
+			return ("???");
+		}
+
+		if (snprintf(buf, sizeof(buf), "%s/%u",
+		    log_addr(af, &map->fec.prefix.prefix),
+		    map->fec.prefix.prefixlen) == -1)
+			return ("???");
+		break;
+	case MAP_TYPE_PWID:
+		if (snprintf(buf, sizeof(buf), "pwid %u (%s)",
+		    map->fec.pwid.pwid,
+		    pw_type_name(map->fec.pwid.type)) == -1)
+			return ("???");
+		break;
+	default:
+		return ("???");
+	}
+
+	return (buf);
+}
+
+const char *
+log_fec(const struct fec *fec)
+{
+	static char	buf[64];
+	union ldpd_addr	addr;
+
+	switch (fec->type) {
+	case FEC_TYPE_IPV4:
+		addr.v4 = fec->u.ipv4.prefix;
+		if (snprintf(buf, sizeof(buf), "ipv4 %s/%u",
+		    log_addr(AF_INET, &addr), fec->u.ipv4.prefixlen) == -1)
+			return ("???");
+		break;
+	case FEC_TYPE_IPV6:
+		addr.v6 = fec->u.ipv6.prefix;
+		if (snprintf(buf, sizeof(buf), "ipv6 %s/%u",
+		    log_addr(AF_INET6, &addr), fec->u.ipv6.prefixlen) == -1)
+			return ("???");
+		break;
+	case FEC_TYPE_PWID:
+		if (snprintf(buf, sizeof(buf),
+		    "pwid %u (%s) - %s",
+		    fec->u.pwid.pwid, pw_type_name(fec->u.pwid.type),
+		    inet_ntoa(fec->u.pwid.lsr_id)) == -1)
+			return ("???");
+		break;
+	default:
+		return ("???");
+	}
+
+	return (buf);
+}
diff --git a/ldpd/log.h b/ldpd/log.h
new file mode 100644
index 0000000..5d2b0c8
--- /dev/null
+++ b/ldpd/log.h
@@ -0,0 +1,52 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _LOG_H_
+#define	_LOG_H_
+
+#include <stdarg.h>
+
+struct in6_addr;
+union ldpd_addr;
+struct hello_source;
+struct fec;
+
+void		 logit(int, const char *, ...);
+void		 log_warn(const char *, ...);
+void		 log_warnx(const char *, ...);
+void		 log_info(const char *, ...);
+void		 log_notice(const char *, ...);
+void		 log_debug(const char *, ...);
+void		 fatal(const char *) __attribute__ ((noreturn));
+void		 fatalx(const char *) __attribute__ ((noreturn));
+const char	*log_sockaddr(void *);
+const char	*log_in6addr(const struct in6_addr *);
+const char	*log_in6addr_scope(const struct in6_addr *, unsigned int);
+const char	*log_addr(int, const union ldpd_addr *);
+const char	*af_name(int);
+const char	*socket_name(int);
+const char	*nbr_state_name(int);
+const char	*if_state_name(int);
+const char	*if_type_name(enum iface_type);
+const char	*notification_name(uint32_t);
+const char	*pw_type_name(uint16_t);
+char		*log_hello_src(const struct hello_source *);
+const char	*log_map(const struct map *);
+const char	*log_fec(const struct fec *);
+
+#endif /* _LOG_H_ */
diff --git a/ldpd/neighbor.c b/ldpd/neighbor.c
new file mode 100644
index 0000000..7c9c195
--- /dev/null
+++ b/ldpd/neighbor.c
@@ -0,0 +1,702 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ * Copyright (c) 2005 Claudio Jeker <claudio@openbsd.org>
+ * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "lde.h"
+#include "log.h"
+
+static __inline int	 nbr_id_compare(struct nbr *, struct nbr *);
+static __inline int	 nbr_addr_compare(struct nbr *, struct nbr *);
+static __inline int	 nbr_pid_compare(struct nbr *, struct nbr *);
+static void		 nbr_update_peerid(struct nbr *);
+static int		 nbr_ktimer(struct thread *);
+static void		 nbr_start_ktimer(struct nbr *);
+static int		 nbr_ktimeout(struct thread *);
+static void		 nbr_start_ktimeout(struct nbr *);
+static int		 nbr_idtimer(struct thread *);
+static int		 nbr_act_session_operational(struct nbr *);
+static void		 nbr_send_labelmappings(struct nbr *);
+
+RB_GENERATE(nbr_id_head, nbr, id_tree, nbr_id_compare)
+RB_GENERATE(nbr_addr_head, nbr, addr_tree, nbr_addr_compare)
+RB_GENERATE(nbr_pid_head, nbr, pid_tree, nbr_pid_compare)
+
+struct {
+	int		state;
+	enum nbr_event	event;
+	enum nbr_action	action;
+	int		new_state;
+} nbr_fsm_tbl[] = {
+    /* current state	event that happened	action to take		resulting state */
+/* Passive Role */
+    {NBR_STA_PRESENT,	NBR_EVT_MATCH_ADJ,	NBR_ACT_NOTHING,	NBR_STA_INITIAL},
+    {NBR_STA_INITIAL,	NBR_EVT_INIT_RCVD,	NBR_ACT_PASSIVE_INIT,	NBR_STA_OPENREC},
+    {NBR_STA_OPENREC,	NBR_EVT_KEEPALIVE_RCVD,	NBR_ACT_SESSION_EST,	NBR_STA_OPER},
+/* Active Role */
+    {NBR_STA_PRESENT,	NBR_EVT_CONNECT_UP,	NBR_ACT_CONNECT_SETUP,	NBR_STA_INITIAL},
+    {NBR_STA_INITIAL,	NBR_EVT_INIT_SENT,	NBR_ACT_NOTHING,	NBR_STA_OPENSENT},
+    {NBR_STA_OPENSENT,	NBR_EVT_INIT_RCVD,	NBR_ACT_KEEPALIVE_SEND,	NBR_STA_OPENREC},
+/* Session Maintenance */
+    {NBR_STA_OPER,	NBR_EVT_PDU_RCVD,	NBR_ACT_RST_KTIMEOUT,	0},
+    {NBR_STA_OPER,	NBR_EVT_PDU_SENT,	NBR_ACT_RST_KTIMER,	0},
+/* Session Close */
+    {NBR_STA_PRESENT,	NBR_EVT_CLOSE_SESSION,	NBR_ACT_NOTHING,	0},
+    {NBR_STA_SESSION,	NBR_EVT_CLOSE_SESSION,	NBR_ACT_CLOSE_SESSION,	NBR_STA_PRESENT},
+    {-1,		NBR_EVT_NOTHING,	NBR_ACT_NOTHING,	0},
+};
+
+const char * const nbr_event_names[] = {
+	"NOTHING",
+	"ADJACENCY MATCHED",
+	"CONNECTION UP",
+	"SESSION CLOSE",
+	"INIT RECEIVED",
+	"KEEPALIVE RECEIVED",
+	"PDU RECEIVED",
+	"PDU SENT",
+	"INIT SENT"
+};
+
+const char * const nbr_action_names[] = {
+	"NOTHING",
+	"RESET KEEPALIVE TIMEOUT",
+	"START NEIGHBOR SESSION",
+	"RESET KEEPALIVE TIMER",
+	"SETUP NEIGHBOR CONNECTION",
+	"SEND INIT AND KEEPALIVE",
+	"SEND KEEPALIVE",
+	"CLOSE SESSION"
+};
+
+struct nbr_id_head nbrs_by_id = RB_INITIALIZER(&nbrs_by_id);
+struct nbr_addr_head nbrs_by_addr = RB_INITIALIZER(&nbrs_by_addr);
+struct nbr_pid_head nbrs_by_pid = RB_INITIALIZER(&nbrs_by_pid);
+
+static __inline int
+nbr_id_compare(struct nbr *a, struct nbr *b)
+{
+	return (ntohl(a->id.s_addr) - ntohl(b->id.s_addr));
+}
+
+static __inline int
+nbr_addr_compare(struct nbr *a, struct nbr *b)
+{
+	if (a->af < b->af)
+		return (-1);
+	if (a->af > b->af)
+		return (1);
+
+	return (ldp_addrcmp(a->af, &a->raddr, &b->raddr));
+}
+
+static __inline int
+nbr_pid_compare(struct nbr *a, struct nbr *b)
+{
+	return (a->peerid - b->peerid);
+}
+
+int
+nbr_fsm(struct nbr *nbr, enum nbr_event event)
+{
+	struct timeval	now;
+	int		old_state;
+	int		new_state = 0;
+	int		i;
+
+	old_state = nbr->state;
+	for (i = 0; nbr_fsm_tbl[i].state != -1; i++)
+		if ((nbr_fsm_tbl[i].state & old_state) &&
+		    (nbr_fsm_tbl[i].event == event)) {
+			new_state = nbr_fsm_tbl[i].new_state;
+			break;
+		}
+
+	if (nbr_fsm_tbl[i].state == -1) {
+		/* event outside of the defined fsm, ignore it. */
+		log_warnx("%s: lsr-id %s, event %s not expected in "
+		    "state %s", __func__, inet_ntoa(nbr->id),
+		    nbr_event_names[event], nbr_state_name(old_state));
+		return (0);
+	}
+
+	if (new_state != 0)
+		nbr->state = new_state;
+
+	if (old_state != nbr->state) {
+		log_debug("%s: event %s resulted in action %s and "
+		    "changing state for lsr-id %s from %s to %s",
+		    __func__, nbr_event_names[event],
+		    nbr_action_names[nbr_fsm_tbl[i].action],
+		    inet_ntoa(nbr->id), nbr_state_name(old_state),
+		    nbr_state_name(nbr->state));
+
+		if (nbr->state == NBR_STA_OPER) {
+			gettimeofday(&now, NULL);
+			nbr->uptime = now.tv_sec;
+		}
+	}
+
+	switch (nbr_fsm_tbl[i].action) {
+	case NBR_ACT_RST_KTIMEOUT:
+		nbr_start_ktimeout(nbr);
+		break;
+	case NBR_ACT_RST_KTIMER:
+		nbr_start_ktimer(nbr);
+		break;
+	case NBR_ACT_SESSION_EST:
+		nbr_act_session_operational(nbr);
+		nbr_start_ktimer(nbr);
+		nbr_start_ktimeout(nbr);
+		if (nbr->v4_enabled)
+			send_address(nbr, AF_INET, NULL, 0);
+		if (nbr->v6_enabled)
+			send_address(nbr, AF_INET6, NULL, 0);
+		nbr_send_labelmappings(nbr);
+		break;
+	case NBR_ACT_CONNECT_SETUP:
+		nbr->tcp = tcp_new(nbr->fd, nbr);
+
+		/* trigger next state */
+		send_init(nbr);
+		nbr_fsm(nbr, NBR_EVT_INIT_SENT);
+		break;
+	case NBR_ACT_PASSIVE_INIT:
+		send_init(nbr);
+		send_keepalive(nbr);
+		break;
+	case NBR_ACT_KEEPALIVE_SEND:
+		nbr_start_ktimeout(nbr);
+		send_keepalive(nbr);
+		break;
+	case NBR_ACT_CLOSE_SESSION:
+		ldpe_imsg_compose_lde(IMSG_NEIGHBOR_DOWN, nbr->peerid, 0,
+		    NULL, 0);
+		session_close(nbr);
+		break;
+	case NBR_ACT_NOTHING:
+		/* do nothing */
+		break;
+	}
+
+	return (0);
+}
+
+struct nbr *
+nbr_new(struct in_addr id, int af, int ds_tlv, union ldpd_addr *addr,
+    uint32_t scope_id)
+{
+	struct nbr		*nbr;
+	struct nbr_params	*nbrp;
+	struct adj		*adj;
+	struct pending_conn	*pconn;
+
+	log_debug("%s: lsr-id %s transport-address %s", __func__,
+	    inet_ntoa(id), log_addr(af, addr));
+
+	if ((nbr = calloc(1, sizeof(*nbr))) == NULL)
+		fatal(__func__);
+
+	LIST_INIT(&nbr->adj_list);
+	nbr->state = NBR_STA_PRESENT;
+	nbr->peerid = 0;
+	nbr->af = af;
+	nbr->ds_tlv = ds_tlv;
+	if (af == AF_INET || ds_tlv)
+		nbr->v4_enabled = 1;
+	if (af == AF_INET6 || ds_tlv)
+		nbr->v6_enabled = 1;
+	nbr->id = id;
+	nbr->laddr = (ldp_af_conf_get(leconf, af))->trans_addr;
+	nbr->raddr = *addr;
+	nbr->raddr_scope = scope_id;
+
+	LIST_FOREACH(adj, &global.adj_list, global_entry) {
+		if (adj->lsr_id.s_addr == nbr->id.s_addr) {
+			adj->nbr = nbr;
+			LIST_INSERT_HEAD(&nbr->adj_list, adj, nbr_entry);
+		}
+	}
+
+	if (RB_INSERT(nbr_id_head, &nbrs_by_id, nbr) != NULL)
+		fatalx("nbr_new: RB_INSERT(nbrs_by_id) failed");
+	if (RB_INSERT(nbr_addr_head, &nbrs_by_addr, nbr) != NULL)
+		fatalx("nbr_new: RB_INSERT(nbrs_by_addr) failed");
+
+	TAILQ_INIT(&nbr->mapping_list);
+	TAILQ_INIT(&nbr->withdraw_list);
+	TAILQ_INIT(&nbr->request_list);
+	TAILQ_INIT(&nbr->release_list);
+	TAILQ_INIT(&nbr->abortreq_list);
+
+	nbrp = nbr_params_find(leconf, nbr->id);
+	if (nbrp) {
+#ifdef __OpenBSD__
+		if (pfkey_establish(nbr, nbrp) == -1)
+			fatalx("pfkey setup failed");
+#else
+		sock_set_md5sig(
+		    (ldp_af_global_get(&global, nbr->af))->ldp_session_socket,
+		    nbr->af, &nbr->raddr, nbrp->auth.md5key);
+#endif
+	}
+
+	pconn = pending_conn_find(nbr->af, &nbr->raddr);
+	if (pconn) {
+		session_accept_nbr(nbr, pconn->fd);
+		pending_conn_del(pconn);
+	}
+
+	return (nbr);
+}
+
+void
+nbr_del(struct nbr *nbr)
+{
+	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));
+
+	nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
+#ifdef __OpenBSD__
+	pfkey_remove(nbr);
+#else
+	sock_set_md5sig(
+	    (ldp_af_global_get(&global, nbr->af))->ldp_session_socket,
+	    nbr->af, &nbr->raddr, NULL);
+#endif
+
+	if (nbr_pending_connect(nbr))
+		THREAD_WRITE_OFF(nbr->ev_connect);
+	nbr_stop_ktimer(nbr);
+	nbr_stop_ktimeout(nbr);
+	nbr_stop_idtimer(nbr);
+
+	mapping_list_clr(&nbr->mapping_list);
+	mapping_list_clr(&nbr->withdraw_list);
+	mapping_list_clr(&nbr->request_list);
+	mapping_list_clr(&nbr->release_list);
+	mapping_list_clr(&nbr->abortreq_list);
+
+	if (nbr->peerid)
+		RB_REMOVE(nbr_pid_head, &nbrs_by_pid, nbr);
+	RB_REMOVE(nbr_id_head, &nbrs_by_id, nbr);
+	RB_REMOVE(nbr_addr_head, &nbrs_by_addr, nbr);
+
+	free(nbr);
+}
+
+static void
+nbr_update_peerid(struct nbr *nbr)
+{
+	static uint32_t	 peercnt = 1;
+
+	if (nbr->peerid)
+		RB_REMOVE(nbr_pid_head, &nbrs_by_pid, nbr);
+
+	/* get next unused peerid */
+	while (nbr_find_peerid(++peercnt))
+		;
+	nbr->peerid = peercnt;
+
+	if (RB_INSERT(nbr_pid_head, &nbrs_by_pid, nbr) != NULL)
+		fatalx("nbr_update_peerid: RB_INSERT(nbrs_by_pid) failed");
+}
+
+struct nbr *
+nbr_find_ldpid(uint32_t lsr_id)
+{
+	struct nbr	n;
+	n.id.s_addr = lsr_id;
+	return (RB_FIND(nbr_id_head, &nbrs_by_id, &n));
+}
+
+struct nbr *
+nbr_find_addr(int af, union ldpd_addr *addr)
+{
+	struct nbr	n;
+	n.af = af;
+	n.raddr = *addr;
+	return (RB_FIND(nbr_addr_head, &nbrs_by_addr, &n));
+}
+
+struct nbr *
+nbr_find_peerid(uint32_t peerid)
+{
+	struct nbr	n;
+	n.peerid = peerid;
+	return (RB_FIND(nbr_pid_head, &nbrs_by_pid, &n));
+}
+
+int
+nbr_adj_count(struct nbr *nbr, int af)
+{
+	struct adj	*adj;
+	int		 total = 0;
+
+	LIST_FOREACH(adj, &nbr->adj_list, nbr_entry)
+		if (adj_get_af(adj) == af)
+			total++;
+
+	return (total);
+}
+
+int
+nbr_session_active_role(struct nbr *nbr)
+{
+	if (ldp_addrcmp(nbr->af, &nbr->laddr, &nbr->raddr) > 0)
+		return (1);
+
+	return (0);
+}
+
+/* timers */
+
+/* Keepalive timer: timer to send keepalive message to neighbors */
+
+static int
+nbr_ktimer(struct thread *thread)
+{
+	struct nbr	*nbr = THREAD_ARG(thread);
+
+	nbr->keepalive_timer = NULL;
+	send_keepalive(nbr);
+	nbr_start_ktimer(nbr);
+
+	return (0);
+}
+
+static void
+nbr_start_ktimer(struct nbr *nbr)
+{
+	int		 secs;
+
+	/* send three keepalives per period */
+	secs = nbr->keepalive / KEEPALIVE_PER_PERIOD;
+	THREAD_TIMER_OFF(nbr->keepalive_timer);
+	nbr->keepalive_timer = thread_add_timer(master, nbr_ktimer, nbr, secs);
+}
+
+void
+nbr_stop_ktimer(struct nbr *nbr)
+{
+	THREAD_TIMER_OFF(nbr->keepalive_timer);
+}
+
+/* Keepalive timeout: if the nbr hasn't sent keepalive */
+
+static int
+nbr_ktimeout(struct thread *thread)
+{
+	struct nbr *nbr = THREAD_ARG(thread);
+
+	nbr->keepalive_timeout = NULL;
+
+	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));
+
+	session_shutdown(nbr, S_KEEPALIVE_TMR, 0, 0);
+
+	return (0);
+}
+
+static void
+nbr_start_ktimeout(struct nbr *nbr)
+{
+	THREAD_TIMER_OFF(nbr->keepalive_timeout);
+	nbr->keepalive_timeout = thread_add_timer(master, nbr_ktimeout, nbr,
+	    nbr->keepalive);
+}
+
+void
+nbr_stop_ktimeout(struct nbr *nbr)
+{
+	THREAD_TIMER_OFF(nbr->keepalive_timeout);
+}
+
+/* Init delay timer: timer to retry to iniziatize session */
+
+static int
+nbr_idtimer(struct thread *thread)
+{
+	struct nbr *nbr = THREAD_ARG(thread);
+
+	nbr->initdelay_timer = NULL;
+
+	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));
+
+	nbr_establish_connection(nbr);
+
+	return (0);
+}
+
+void
+nbr_start_idtimer(struct nbr *nbr)
+{
+	int	secs;
+
+	secs = INIT_DELAY_TMR;
+	switch(nbr->idtimer_cnt) {
+	default:
+		/* do not further increase the counter */
+		secs = MAX_DELAY_TMR;
+		break;
+	case 2:
+		secs *= 2;
+		/* FALLTHROUGH */
+	case 1:
+		secs *= 2;
+		/* FALLTHROUGH */
+	case 0:
+		nbr->idtimer_cnt++;
+		break;
+	}
+
+	THREAD_TIMER_OFF(nbr->initdelay_timer);
+	nbr->initdelay_timer = thread_add_timer(master, nbr_idtimer, nbr, secs);
+}
+
+void
+nbr_stop_idtimer(struct nbr *nbr)
+{
+	THREAD_TIMER_OFF(nbr->initdelay_timer);
+}
+
+int
+nbr_pending_idtimer(struct nbr *nbr)
+{
+	return (nbr->initdelay_timer != NULL);
+}
+
+int
+nbr_pending_connect(struct nbr *nbr)
+{
+	return (nbr->ev_connect != NULL);
+}
+
+static int
+nbr_connect_cb(struct thread *thread)
+{
+	struct nbr	*nbr = THREAD_ARG(thread);
+	int		 error;
+	socklen_t	 len;
+
+	nbr->ev_connect = NULL;
+
+	len = sizeof(error);
+	if (getsockopt(nbr->fd, SOL_SOCKET, SO_ERROR, &error, &len) < 0) {
+		log_warn("%s: getsockopt SOL_SOCKET SO_ERROR", __func__);
+		return (0);
+	}
+
+	if (error) {
+		close(nbr->fd);
+		errno = error;
+		log_debug("%s: error while connecting to %s: %s", __func__,
+		    log_addr(nbr->af, &nbr->raddr), strerror(errno));
+		return (0);
+	}
+
+	nbr_fsm(nbr, NBR_EVT_CONNECT_UP);
+
+	return (0);
+}
+
+int
+nbr_establish_connection(struct nbr *nbr)
+{
+	struct sockaddr_storage	 local_sa;
+	struct sockaddr_storage	 remote_sa;
+	struct adj		*adj;
+	struct nbr_params	*nbrp;
+#ifdef __OpenBSD__
+	int			 opt = 1;
+#endif
+
+	nbr->fd = socket(nbr->af, SOCK_STREAM, 0);
+	if (nbr->fd == -1) {
+		log_warn("%s: error while creating socket", __func__);
+		return (-1);
+	}
+	sock_set_blockmode(nbr->fd, BM_NONBLOCK);
+
+	nbrp = nbr_params_find(leconf, nbr->id);
+	if (nbrp && nbrp->auth.method == AUTH_MD5SIG) {
+#ifdef __OpenBSD__
+		if (sysdep.no_pfkey || sysdep.no_md5sig) {
+			log_warnx("md5sig configured but not available");
+			close(nbr->fd);
+			return (-1);
+		}
+		if (setsockopt(nbr->fd, IPPROTO_TCP, TCP_MD5SIG,
+		    &opt, sizeof(opt)) == -1) {
+			log_warn("setsockopt md5sig");
+			close(nbr->fd);
+			return (-1);
+		}
+#else
+		sock_set_md5sig(nbr->fd, nbr->af, &nbr->raddr,
+		    nbrp->auth.md5key);
+#endif
+	}
+
+	memcpy(&local_sa, addr2sa(nbr->af, &nbr->laddr, 0), sizeof(local_sa));
+	memcpy(&remote_sa, addr2sa(nbr->af, &nbr->raddr, LDP_PORT),
+	    sizeof(local_sa));
+	if (nbr->af == AF_INET6 && nbr->raddr_scope)
+		addscope((struct sockaddr_in6 *)&remote_sa, nbr->raddr_scope);
+
+	if (bind(nbr->fd, (struct sockaddr *)&local_sa,
+	    sockaddr_len((struct sockaddr *)&local_sa)) == -1) {
+		log_warn("%s: error while binding socket to %s", __func__,
+		    log_sockaddr((struct sockaddr *)&local_sa));
+		close(nbr->fd);
+		return (-1);
+	}
+
+	/*
+	 * Send an extra hello to guarantee that the remote peer has formed
+	 * an adjacency as well.
+	 */
+	LIST_FOREACH(adj, &nbr->adj_list, nbr_entry)
+		send_hello(adj->source.type, adj->source.link.ia,
+		    adj->source.target);
+
+	if (connect(nbr->fd, (struct sockaddr *)&remote_sa,
+	    sockaddr_len((struct sockaddr *)&remote_sa)) == -1) {
+		if (errno == EINPROGRESS) {
+			THREAD_WRITE_ON(master, nbr->ev_connect, nbr_connect_cb,
+			    nbr, nbr->fd);
+			return (0);
+		}
+		log_warn("%s: error while connecting to %s", __func__,
+		    log_sockaddr((struct sockaddr *)&remote_sa));
+		close(nbr->fd);
+		return (-1);
+	}
+
+	/* connection completed immediately */
+	nbr_fsm(nbr, NBR_EVT_CONNECT_UP);
+
+	return (0);
+}
+
+static int
+nbr_act_session_operational(struct nbr *nbr)
+{
+	struct lde_nbr	 lde_nbr;
+
+	nbr->idtimer_cnt = 0;
+
+	/* this is necessary to avoid ipc synchronization issues */
+	nbr_update_peerid(nbr);
+
+	memset(&lde_nbr, 0, sizeof(lde_nbr));
+	lde_nbr.id = nbr->id;
+	lde_nbr.v4_enabled = nbr->v4_enabled;
+	lde_nbr.v6_enabled = nbr->v6_enabled;
+	return (ldpe_imsg_compose_lde(IMSG_NEIGHBOR_UP, nbr->peerid, 0,
+	    &lde_nbr, sizeof(lde_nbr)));
+}
+
+static void
+nbr_send_labelmappings(struct nbr *nbr)
+{
+	ldpe_imsg_compose_lde(IMSG_LABEL_MAPPING_FULL, nbr->peerid, 0,
+	    NULL, 0);
+}
+
+struct nbr_params *
+nbr_params_new(struct in_addr lsr_id)
+{
+	struct nbr_params	*nbrp;
+
+	if ((nbrp = calloc(1, sizeof(*nbrp))) == NULL)
+		fatal(__func__);
+
+	nbrp->lsr_id = lsr_id;
+	nbrp->auth.method = AUTH_NONE;
+
+	return (nbrp);
+}
+
+struct nbr_params *
+nbr_params_find(struct ldpd_conf *xconf, struct in_addr lsr_id)
+{
+	struct nbr_params *nbrp;
+
+	LIST_FOREACH(nbrp, &xconf->nbrp_list, entry)
+		if (nbrp->lsr_id.s_addr == lsr_id.s_addr)
+			return (nbrp);
+
+	return (NULL);
+}
+
+uint16_t
+nbr_get_keepalive(int af, struct in_addr lsr_id)
+{
+	struct nbr_params	*nbrp;
+
+	nbrp = nbr_params_find(leconf, lsr_id);
+	if (nbrp && (nbrp->flags & F_NBRP_KEEPALIVE))
+		return (nbrp->keepalive);
+
+	return ((ldp_af_conf_get(leconf, af))->keepalive);
+}
+
+struct ctl_nbr *
+nbr_to_ctl(struct nbr *nbr)
+{
+	static struct ctl_nbr	 nctl;
+	struct timeval		 now;
+
+	nctl.af = nbr->af;
+	nctl.id = nbr->id;
+	nctl.laddr = nbr->laddr;
+	nctl.lport = nbr->tcp->lport;
+	nctl.raddr = nbr->raddr;
+	nctl.rport = nbr->tcp->rport;
+	nctl.holdtime = nbr->keepalive;
+	nctl.nbr_state = nbr->state;
+
+	gettimeofday(&now, NULL);
+	if (nbr->state == NBR_STA_OPER) {
+		nctl.uptime = now.tv_sec - nbr->uptime;
+	} else
+		nctl.uptime = 0;
+
+	return (&nctl);
+}
+
+void
+nbr_clear_ctl(struct ctl_nbr *nctl)
+{
+	struct nbr		*nbr;
+
+	RB_FOREACH(nbr, nbr_addr_head, &nbrs_by_addr) {
+		if (ldp_addrisset(nctl->af, &nctl->raddr) &&
+		    ldp_addrcmp(nctl->af, &nctl->raddr, &nbr->raddr))
+			continue;
+
+		log_debug("%s: neighbor %s manually cleared", __func__,
+		    log_addr(nbr->af, &nbr->raddr));
+		session_shutdown(nbr, S_SHUTDOWN, 0, 0);
+	}
+}
diff --git a/ldpd/notification.c b/ldpd/notification.c
new file mode 100644
index 0000000..1131a5b
--- /dev/null
+++ b/ldpd/notification.c
@@ -0,0 +1,241 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldp.h"
+#include "log.h"
+#include "ldpe.h"
+
+static int	 gen_status_tlv(struct ibuf *, uint32_t, uint32_t, uint32_t);
+
+void
+send_notification_full(struct tcp_conn *tcp, struct notify_msg *nm)
+{
+	struct ibuf	*buf;
+	uint16_t	 size;
+
+	/* calculate size */
+	size = LDP_HDR_SIZE + LDP_MSG_SIZE + STATUS_SIZE;
+	if (nm->flags & F_NOTIF_PW_STATUS)
+		size += PW_STATUS_TLV_LEN;
+	if (nm->flags & F_NOTIF_FEC) {
+		size += TLV_HDR_LEN;
+		switch (nm->fec.type) {
+		case MAP_TYPE_PWID:
+			size += FEC_PWID_ELM_MIN_LEN;
+			if (nm->fec.flags & F_MAP_PW_ID)
+				size += sizeof(uint32_t);
+			break;
+		}
+	}
+
+	if ((buf = ibuf_open(size)) == NULL)
+		fatal(__func__);
+
+	gen_ldp_hdr(buf, size);
+	size -= LDP_HDR_SIZE;
+	gen_msg_hdr(buf, MSG_TYPE_NOTIFICATION, size);
+	gen_status_tlv(buf, nm->status, nm->messageid, nm->type);
+	/* optional tlvs */
+	if (nm->flags & F_NOTIF_PW_STATUS)
+		gen_pw_status_tlv(buf, nm->pw_status);
+	if (nm->flags & F_NOTIF_FEC)
+		gen_fec_tlv(buf, &nm->fec);
+
+	evbuf_enqueue(&tcp->wbuf, buf);
+}
+
+/* send a notification without optional tlvs */
+void
+send_notification(uint32_t status, struct tcp_conn *tcp, uint32_t msgid,
+    uint32_t type)
+{
+	struct notify_msg	 nm;
+
+	memset(&nm, 0, sizeof(nm));
+	nm.status = status;
+	nm.messageid = msgid;
+	nm.type = type;
+
+	send_notification_full(tcp, &nm);
+}
+
+void
+send_notification_nbr(struct nbr *nbr, uint32_t status, uint32_t msgid,
+    uint32_t type)
+{
+	log_debug("%s: lsr-id %s, status %s", __func__, inet_ntoa(nbr->id),
+	     notification_name(status));
+
+	send_notification(status, nbr->tcp, msgid, type);
+	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
+}
+
+int
+recv_notification(struct nbr *nbr, char *buf, uint16_t len)
+{
+	struct ldp_msg		not;
+	struct status_tlv	st;
+	struct notify_msg	nm;
+	int			tlen;
+
+	memcpy(&not, buf, sizeof(not));
+	buf += LDP_MSG_SIZE;
+	len -= LDP_MSG_SIZE;
+
+	if (len < STATUS_SIZE) {
+		session_shutdown(nbr, S_BAD_MSG_LEN, not.msgid, not.type);
+		return (-1);
+	}
+	memcpy(&st, buf, sizeof(st));
+
+	if (ntohs(st.length) > STATUS_SIZE - TLV_HDR_LEN ||
+	    ntohs(st.length) > len - TLV_HDR_LEN) {
+		session_shutdown(nbr, S_BAD_TLV_LEN, not.msgid, not.type);
+		return (-1);
+	}
+	buf += STATUS_SIZE;
+	len -= STATUS_SIZE;
+
+	memset(&nm, 0, sizeof(nm));
+	nm.status = ntohl(st.status_code);
+
+	/* Optional Parameters */
+	while (len > 0) {
+		struct tlv 	tlv;
+
+		if (len < sizeof(tlv)) {
+			session_shutdown(nbr, S_BAD_TLV_LEN, not.msgid,
+			    not.type);
+			return (-1);
+		}
+
+		memcpy(&tlv, buf, sizeof(tlv));
+		if (ntohs(tlv.length) > len - TLV_HDR_LEN) {
+			session_shutdown(nbr, S_BAD_TLV_LEN, not.msgid,
+			    not.type);
+			return (-1);
+		}
+		buf += TLV_HDR_LEN;
+		len -= TLV_HDR_LEN;
+
+		switch (ntohs(tlv.type) & ~UNKNOWN_FLAG) {
+		case TLV_TYPE_EXTSTATUS:
+		case TLV_TYPE_RETURNEDPDU:
+		case TLV_TYPE_RETURNEDMSG:
+			/* TODO is there any use for this? */
+			break;
+		case TLV_TYPE_PW_STATUS:
+			if (ntohs(tlv.length) != 4) {
+				session_shutdown(nbr, S_BAD_TLV_LEN,
+				    not.msgid, not.type);
+				return (-1);
+			}
+
+			nm.pw_status = ntohl(*(uint32_t *)buf);
+			nm.flags |= F_NOTIF_PW_STATUS;
+			break;
+		case TLV_TYPE_FEC:
+			if ((tlen = tlv_decode_fec_elm(nbr, &not, buf,
+			    ntohs(tlv.length), &nm.fec)) == -1)
+				return (-1);
+			/* allow only one fec element */
+			if (tlen != ntohs(tlv.length)) {
+				session_shutdown(nbr, S_BAD_TLV_VAL,
+				    not.msgid, not.type);
+				return (-1);
+			}
+			nm.flags |= F_NOTIF_FEC;
+			break;
+		default:
+			if (!(ntohs(tlv.type) & UNKNOWN_FLAG)) {
+				send_notification_nbr(nbr, S_UNKNOWN_TLV,
+				    not.msgid, not.type);
+			}
+			/* ignore unknown tlv */
+			break;
+		}
+		buf += ntohs(tlv.length);
+		len -= ntohs(tlv.length);
+	}
+
+	if (nm.status == S_PW_STATUS) {
+		if (!(nm.flags & (F_NOTIF_PW_STATUS|F_NOTIF_FEC))) {
+			send_notification_nbr(nbr, S_MISS_MSG,
+			    not.msgid, not.type);
+			return (-1);
+		}
+
+		switch (nm.fec.type) {
+		case MAP_TYPE_PWID:
+			break;
+		default:
+			send_notification_nbr(nbr, S_BAD_TLV_VAL,
+			    not.msgid, not.type);
+			return (-1);
+		}
+	}
+
+	if (st.status_code & htonl(STATUS_FATAL))
+		log_warnx("received notification from neighbor %s: %s",
+		    inet_ntoa(nbr->id),
+		    notification_name(ntohl(st.status_code)));
+	else
+		log_debug("received non-fatal notification from neighbor "
+		    "%s: %s", inet_ntoa(nbr->id),
+		    notification_name(ntohl(st.status_code)));
+
+	if (st.status_code & htonl(STATUS_FATAL)) {
+		if ((st.status_code == htonl(S_NO_HELLO) ||
+		    st.status_code == htonl(S_PARM_ADV_MODE) ||
+		    st.status_code == htonl(S_MAX_PDU_LEN) ||
+		    st.status_code == htonl(S_PARM_L_RANGE) ||
+		    st.status_code == htonl(S_KEEPALIVE_BAD))
+		    && nbr_session_active_role(nbr))
+			nbr_start_idtimer(nbr);
+
+		nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
+		return (-1);
+	}
+
+	if (nm.status == S_PW_STATUS)
+		ldpe_imsg_compose_lde(IMSG_NOTIFICATION, nbr->peerid, 0,
+		    &nm, sizeof(nm));
+
+	return (0);
+}
+
+static int
+gen_status_tlv(struct ibuf *buf, uint32_t status, uint32_t msgid, uint32_t type)
+{
+	struct status_tlv	st;
+
+	memset(&st, 0, sizeof(st));
+
+	st.type = htons(TLV_TYPE_STATUS);
+	st.length = htons(STATUS_TLV_LEN);
+	st.status_code = htonl(status);
+
+	/* for convenience, msgid and type are already in network byte order */
+	st.msg_id = msgid;
+	st.msg_type = type;
+
+	return (ibuf_add(buf, &st, STATUS_SIZE));
+}
diff --git a/ldpd/packet.c b/ldpd/packet.c
new file mode 100644
index 0000000..57088eb
--- /dev/null
+++ b/ldpd/packet.c
@@ -0,0 +1,814 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2013, 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+
+#include "sockopt.h"
+
+static struct iface		*disc_find_iface(unsigned int, int,
+				    union ldpd_addr *, int);
+static int			 session_read(struct thread *);
+static int			 session_write(struct thread *);
+static ssize_t			 session_get_pdu(struct ibuf_read *, char **);
+static void			 tcp_close(struct tcp_conn *);
+static struct pending_conn	*pending_conn_new(int, int, union ldpd_addr *);
+static int			 pending_conn_timeout(struct thread *);
+
+int
+gen_ldp_hdr(struct ibuf *buf, uint16_t size)
+{
+	struct ldp_hdr	ldp_hdr;
+
+	memset(&ldp_hdr, 0, sizeof(ldp_hdr));
+	ldp_hdr.version = htons(LDP_VERSION);
+	/* exclude the 'Version' and 'PDU Length' fields from the total */
+	ldp_hdr.length = htons(size - LDP_HDR_DEAD_LEN);
+	ldp_hdr.lsr_id = ldp_rtr_id_get(leconf);
+	ldp_hdr.lspace_id = 0;
+
+	return (ibuf_add(buf, &ldp_hdr, LDP_HDR_SIZE));
+}
+
+int
+gen_msg_hdr(struct ibuf *buf, uint32_t type, uint16_t size)
+{
+	static int	msgcnt = 0;
+	struct ldp_msg	msg;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.type = htons(type);
+	/* exclude the 'Type' and 'Length' fields from the total */
+	msg.length = htons(size - LDP_MSG_DEAD_LEN);
+	if (type != MSG_TYPE_HELLO)
+		msg.msgid = htonl(++msgcnt);
+
+	return (ibuf_add(buf, &msg, sizeof(msg)));
+}
+
+/* send packets */
+int
+send_packet(int fd, int af, union ldpd_addr *dst, struct iface_af *ia,
+    void *pkt, size_t len)
+{
+	struct sockaddr		*sa;
+
+	switch (af) {
+	case AF_INET:
+		if (ia && IN_MULTICAST(ntohl(dst->v4.s_addr))) {
+			/* set outgoing interface for multicast traffic */
+			if (sock_set_ipv4_mcast(ia->iface) == -1) {
+				log_debug("%s: error setting multicast "
+				    "interface, %s", __func__, ia->iface->name);
+				return (-1);
+			}
+		}
+		break;
+	case AF_INET6:
+		if (ia && IN6_IS_ADDR_MULTICAST(&dst->v6)) {
+			/* set outgoing interface for multicast traffic */
+			if (sock_set_ipv6_mcast(ia->iface) == -1) {
+				log_debug("%s: error setting multicast "
+				    "interface, %s", __func__, ia->iface->name);
+				return (-1);
+			}
+		}
+		break;
+	default:
+		fatalx("send_packet: unknown af");
+	}
+
+	sa = addr2sa(af, dst, LDP_PORT);
+	if (sendto(fd, pkt, len, 0, sa, sockaddr_len(sa)) == -1) {
+		log_warn("%s: error sending packet to %s", __func__,
+		    log_sockaddr(sa));
+		return (-1);
+	}
+
+	return (0);
+}
+
+/* Discovery functions */
+int
+disc_recv_packet(struct thread *thread)
+{
+	int			 fd = THREAD_FD(thread);
+	struct thread		**threadp = THREAD_ARG(thread);
+
+	union {
+		struct	cmsghdr hdr;
+#ifdef HAVE_STRUCT_SOCKADDR_DL
+		char	buf[CMSG_SPACE(sizeof(struct sockaddr_dl))];
+#else
+		char	buf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+#endif
+	} cmsgbuf;
+	struct msghdr		 msg;
+	struct sockaddr_storage	 from;
+	struct iovec		 iov;
+	char			*buf;
+#ifndef MSG_MCAST
+	struct cmsghdr		*cmsg;
+#endif
+	ssize_t			 r;
+	int			 multicast;
+	int			 af;
+	union ldpd_addr		 src;
+	unsigned int		 ifindex = 0;
+	struct iface		*iface;
+	uint16_t		 len;
+	struct ldp_hdr		 ldp_hdr;
+	uint16_t		 pdu_len;
+	struct ldp_msg		 ldp_msg;
+	uint16_t		 msg_len;
+	struct in_addr		 lsr_id;
+
+	/* reschedule read */
+	*threadp = thread_add_read(master, disc_recv_packet, threadp, fd);
+
+	/* setup buffer */
+	memset(&msg, 0, sizeof(msg));
+	iov.iov_base = buf = pkt_ptr;
+	iov.iov_len = IBUF_READ_SIZE;
+	msg.msg_name = &from;
+	msg.msg_namelen = sizeof(from);
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = &cmsgbuf.buf;
+	msg.msg_controllen = sizeof(cmsgbuf.buf);
+
+	if ((r = recvmsg(fd, &msg, 0)) == -1) {
+		if (errno != EAGAIN && errno != EINTR)
+			log_debug("%s: read error: %s", __func__,
+			    strerror(errno));
+		return (0);
+	}
+
+	sa2addr((struct sockaddr *)&from, &af, &src, NULL);
+#ifdef MSG_MCAST
+	multicast = (msg.msg_flags & MSG_MCAST) ? 1 : 0;
+#else
+	multicast = 0;
+	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
+	    cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+#if defined(HAVE_IP_PKTINFO)
+		if (af == AF_INET && cmsg->cmsg_level == IPPROTO_IP &&
+		    cmsg->cmsg_type == IP_PKTINFO) {
+			struct in_pktinfo	*pktinfo;
+
+			pktinfo = (struct in_pktinfo *)CMSG_DATA(cmsg);
+			if (IN_MULTICAST(ntohl(pktinfo->ipi_addr.s_addr)))
+				multicast = 1;
+			break;
+		}
+#elif defined(HAVE_IP_RECVDSTADDR)
+		if (af == AF_INET && cmsg->cmsg_level == IPPROTO_IP &&
+		    cmsg->cmsg_type == IP_RECVDSTADDR) {
+			struct in_addr		*addr;
+
+			addr = (struct in_addr *)CMSG_DATA(cmsg);
+			if (IN_MULTICAST(ntohl(addr->s_addr)))
+				multicast = 1;
+			break;
+		}
+#else
+#error "Unsupported socket API"
+#endif
+		if (af == AF_INET6 && cmsg->cmsg_level == IPPROTO_IPV6 &&
+		    cmsg->cmsg_type == IPV6_PKTINFO) {
+			struct in6_pktinfo	*pktinfo;
+
+			pktinfo = (struct in6_pktinfo *)CMSG_DATA(cmsg);
+			if (IN6_IS_ADDR_MULTICAST(&pktinfo->ipi6_addr))
+				multicast = 1;
+			break;
+		}
+	}
+#endif /* MSG_MCAST */
+	if (bad_addr(af, &src)) {
+		log_debug("%s: invalid source address: %s", __func__,
+		    log_addr(af, &src));
+		return (0);
+	}
+	ifindex = getsockopt_ifindex(af, &msg);
+
+	/* find a matching interface */
+	iface = disc_find_iface(ifindex, af, &src, multicast);
+	if (iface == NULL)
+		return (0);
+
+	/* check packet size */
+	len = (uint16_t)r;
+	if (len < (LDP_HDR_SIZE + LDP_MSG_SIZE) || len > LDP_MAX_LEN) {
+		log_debug("%s: bad packet size, source %s", __func__,
+		    log_addr(af, &src));
+		return (0);
+	}
+
+	/* LDP header sanity checks */
+	memcpy(&ldp_hdr, buf, sizeof(ldp_hdr));
+	if (ntohs(ldp_hdr.version) != LDP_VERSION) {
+		log_debug("%s: invalid LDP version %d, source %s", __func__,
+		    ntohs(ldp_hdr.version), log_addr(af, &src));
+		return (0);
+	}
+	if (ntohs(ldp_hdr.lspace_id) != 0) {
+		log_debug("%s: invalid label space %u, source %s", __func__,
+		    ntohs(ldp_hdr.lspace_id), log_addr(af, &src));
+		return (0);
+	}
+	/* check "PDU Length" field */
+	pdu_len = ntohs(ldp_hdr.length);
+	if ((pdu_len < (LDP_HDR_PDU_LEN + LDP_MSG_SIZE)) ||
+	    (pdu_len > (len - LDP_HDR_DEAD_LEN))) {
+		log_debug("%s: invalid LDP packet length %u, source %s",
+		    __func__, ntohs(ldp_hdr.length), log_addr(af, &src));
+		return (0);
+	}
+	buf += LDP_HDR_SIZE;
+	len -= LDP_HDR_SIZE;
+
+	lsr_id.s_addr = ldp_hdr.lsr_id;
+
+	/*
+	 * For UDP, we process only the first message of each packet. This does
+	 * not impose any restrictions since LDP uses UDP only for sending Hello
+	 * packets.
+	 */
+	memcpy(&ldp_msg, buf, sizeof(ldp_msg));
+
+	/* check "Message Length" field */
+	msg_len = ntohs(ldp_msg.length);
+	if (msg_len < LDP_MSG_LEN || ((msg_len + LDP_MSG_DEAD_LEN) > pdu_len)) {
+		log_debug("%s: invalid LDP message length %u, source %s",
+		    __func__, ntohs(ldp_msg.length), log_addr(af, &src));
+		return (0);
+	}
+	buf += LDP_MSG_SIZE;
+	len -= LDP_MSG_SIZE;
+
+	/* switch LDP packet type */
+	switch (ntohs(ldp_msg.type)) {
+	case MSG_TYPE_HELLO:
+		recv_hello(lsr_id, &ldp_msg, af, &src, iface, multicast,
+		    buf, len);
+		break;
+	default:
+		log_debug("%s: unknown LDP packet type, source %s", __func__,
+		    log_addr(af, &src));
+	}
+
+	return (0);
+}
+
+static struct iface *
+disc_find_iface(unsigned int ifindex, int af, union ldpd_addr *src,
+    int multicast)
+{
+	struct iface	*iface;
+	struct iface_af	*ia;
+	struct if_addr	*if_addr;
+	in_addr_t	 mask;
+
+	iface = if_lookup(leconf, ifindex);
+	if (iface == NULL)
+		return (NULL);
+
+	/*
+	 * For unicast packets, we just need to make sure that the interface
+	 * is enabled for the given address-family.
+	 */
+	if (!multicast) {
+		ia = iface_af_get(iface, af);
+		if (ia->enabled)
+			return (iface);
+		return (NULL);
+	}
+
+	switch (af) {
+	case AF_INET:
+		LIST_FOREACH(if_addr, &iface->addr_list, entry) {
+			if (if_addr->af != AF_INET)
+				continue;
+
+			switch (iface->type) {
+			case IF_TYPE_POINTOPOINT:
+				if (if_addr->dstbrd.v4.s_addr == src->v4.s_addr)
+					return (iface);
+				break;
+			default:
+				mask = prefixlen2mask(if_addr->prefixlen);
+				if ((if_addr->addr.v4.s_addr & mask) ==
+				    (src->v4.s_addr & mask))
+					return (iface);
+				break;
+			}
+		}
+		break;
+	case AF_INET6:
+		if (IN6_IS_ADDR_LINKLOCAL(&src->v6))
+			return (iface);
+		break;
+	default:
+		fatalx("disc_find_iface: unknown af");
+	}
+
+	return (NULL);
+}
+
+int
+session_accept(struct thread *thread)
+{
+	int			 fd = THREAD_FD(thread);
+	struct sockaddr_storage	 src;
+	socklen_t		 len = sizeof(src);
+	int			 newfd;
+	int			 af;
+	union ldpd_addr		 addr;
+	struct nbr		*nbr;
+	struct pending_conn	*pconn;
+
+	newfd = accept(fd, (struct sockaddr *)&src, &len);
+	if (newfd == -1) {
+		/*
+		 * Pause accept if we are out of file descriptors, or
+		 * libevent will haunt us here too.
+		 */
+		if (errno == ENFILE || errno == EMFILE) {
+			accept_pause();
+		} else if (errno != EWOULDBLOCK && errno != EINTR &&
+		    errno != ECONNABORTED)
+			log_debug("%s: accept error: %s", __func__,
+			    strerror(errno));
+		return (0);
+	}
+	sock_set_blockmode(newfd, BM_NONBLOCK);
+
+	sa2addr((struct sockaddr *)&src, &af, &addr, NULL);
+
+	/*
+	 * Since we don't support label spaces, we can identify this neighbor
+	 * just by its source address. This way we don't need to wait for its
+	 * Initialization message to know who we are talking to.
+	 */
+	nbr = nbr_find_addr(af, &addr);
+	if (nbr == NULL) {
+		/*
+		 * According to RFC 5036, we would need to send a No Hello
+		 * Error Notification message and close this TCP connection
+		 * right now. But doing so would trigger the backoff exponential
+		 * timer in the remote peer, which would considerably slow down
+		 * the session establishment process. The trick here is to wait
+		 * five seconds before sending the Notification Message. There's
+		 * a good chance that the remote peer will send us a Hello
+		 * message within this interval, so it's worth waiting before
+		 * taking a more drastic measure.
+		 */
+		pconn = pending_conn_find(af, &addr);
+		if (pconn)
+			close(newfd);
+		else
+			pending_conn_new(newfd, af, &addr);
+		return (0);
+	}
+	/* protection against buggy implementations */
+	if (nbr_session_active_role(nbr)) {
+		close(newfd);
+		return (0);
+	}
+	if (nbr->state != NBR_STA_PRESENT) {
+		log_debug("%s: lsr-id %s: rejecting additional transport "
+		    "connection", __func__, inet_ntoa(nbr->id));
+		close(newfd);
+		return (0);
+	}
+
+	session_accept_nbr(nbr, newfd);
+
+	return (0);
+}
+
+void
+session_accept_nbr(struct nbr *nbr, int fd)
+{
+#ifdef __OpenBSD__
+	struct nbr_params	*nbrp;
+	int			 opt;
+	socklen_t		 len;
+
+	nbrp = nbr_params_find(leconf, nbr->id);
+	if (nbrp && nbrp->auth.method == AUTH_MD5SIG) {
+		if (sysdep.no_pfkey || sysdep.no_md5sig) {
+			log_warnx("md5sig configured but not available");
+			close(fd);
+			return;
+		}
+
+		len = sizeof(opt);
+		if (getsockopt(fd, IPPROTO_TCP, TCP_MD5SIG, &opt, &len) == -1)
+			fatal("getsockopt TCP_MD5SIG");
+		if (!opt) {	/* non-md5'd connection! */
+			log_warnx("connection attempt without md5 signature");
+			close(fd);
+			return;
+		}
+	}
+#endif
+
+	nbr->tcp = tcp_new(fd, nbr);
+	nbr_fsm(nbr, NBR_EVT_MATCH_ADJ);
+}
+
+static int
+session_read(struct thread *thread)
+{
+	int		 fd = THREAD_FD(thread);
+	struct nbr	*nbr = THREAD_ARG(thread);
+	struct tcp_conn	*tcp = nbr->tcp;
+	struct ldp_hdr	*ldp_hdr;
+	struct ldp_msg	*ldp_msg;
+	char		*buf = NULL, *pdu;
+	ssize_t		 n, len;
+	uint16_t	 pdu_len, msg_len, msg_size, max_pdu_len;
+	int		 ret;
+
+	tcp->rev = thread_add_read(master, session_read, nbr, fd);
+
+	if ((n = read(fd, tcp->rbuf->buf + tcp->rbuf->wpos,
+	    sizeof(tcp->rbuf->buf) - tcp->rbuf->wpos)) == -1) {
+		if (errno != EINTR && errno != EAGAIN) {
+			log_warn("%s: read error", __func__);
+			nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
+			return (0);
+		}
+		/* retry read */
+		return (0);
+	}
+	if (n == 0) {
+		/* connection closed */
+		log_debug("%s: connection closed by remote end", __func__);
+		nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
+		return (0);
+	}
+	tcp->rbuf->wpos += n;
+
+	while ((len = session_get_pdu(tcp->rbuf, &buf)) > 0) {
+		pdu = buf;
+		ldp_hdr = (struct ldp_hdr *)pdu;
+		if (ntohs(ldp_hdr->version) != LDP_VERSION) {
+			session_shutdown(nbr, S_BAD_PROTO_VER, 0, 0);
+			free(buf);
+			return (0);
+		}
+
+		pdu_len = ntohs(ldp_hdr->length);
+		/*
+	 	 * RFC 5036 - Section 3.5.3:
+		 * "Prior to completion of the negotiation, the maximum
+		 * allowable length is 4096 bytes".
+		 */
+		if (nbr->state == NBR_STA_OPER)
+			max_pdu_len = nbr->max_pdu_len;
+		else
+			max_pdu_len = LDP_MAX_LEN;
+		if (pdu_len < (LDP_HDR_PDU_LEN + LDP_MSG_SIZE) ||
+		    pdu_len > max_pdu_len) {
+			session_shutdown(nbr, S_BAD_PDU_LEN, 0, 0);
+			free(buf);
+			return (0);
+		}
+		pdu_len -= LDP_HDR_PDU_LEN;
+
+		if (ldp_hdr->lsr_id != nbr->id.s_addr ||
+		    ldp_hdr->lspace_id != 0) {
+			session_shutdown(nbr, S_BAD_LDP_ID, 0, 0);
+			free(buf);
+			return (0);
+		}
+
+		pdu += LDP_HDR_SIZE;
+		len -= LDP_HDR_SIZE;
+
+		if (nbr->state == NBR_STA_OPER)
+			nbr_fsm(nbr, NBR_EVT_PDU_RCVD);
+
+		while (len >= LDP_MSG_SIZE) {
+			uint16_t type;
+
+			ldp_msg = (struct ldp_msg *)pdu;
+			type = ntohs(ldp_msg->type);
+			msg_len = ntohs(ldp_msg->length);
+			msg_size = msg_len + LDP_MSG_DEAD_LEN;
+			if (msg_len < LDP_MSG_LEN || msg_size > pdu_len) {
+				session_shutdown(nbr, S_BAD_TLV_LEN,
+				    ldp_msg->msgid, ldp_msg->type);
+				free(buf);
+				return (0);
+			}
+			pdu_len -= msg_size;
+
+			/* check for error conditions earlier */
+			switch (type) {
+			case MSG_TYPE_INIT:
+				if ((nbr->state != NBR_STA_INITIAL) &&
+				    (nbr->state != NBR_STA_OPENSENT)) {
+					session_shutdown(nbr, S_SHUTDOWN,
+					    ldp_msg->msgid, ldp_msg->type);
+					free(buf);
+					return (0);
+				}
+				break;
+			case MSG_TYPE_KEEPALIVE:
+				if ((nbr->state == NBR_STA_INITIAL) ||
+				    (nbr->state == NBR_STA_OPENSENT)) {
+					session_shutdown(nbr, S_SHUTDOWN,
+					    ldp_msg->msgid, ldp_msg->type);
+					free(buf);
+					return (0);
+				}
+				break;
+			case MSG_TYPE_ADDR:
+			case MSG_TYPE_ADDRWITHDRAW:
+			case MSG_TYPE_LABELMAPPING:
+			case MSG_TYPE_LABELREQUEST:
+			case MSG_TYPE_LABELWITHDRAW:
+			case MSG_TYPE_LABELRELEASE:
+			case MSG_TYPE_LABELABORTREQ:
+				if (nbr->state != NBR_STA_OPER) {
+					session_shutdown(nbr, S_SHUTDOWN,
+					    ldp_msg->msgid, ldp_msg->type);
+					free(buf);
+					return (0);
+				}
+				break;
+			default:
+				break;
+			}
+
+			/* switch LDP packet type */
+			switch (type) {
+			case MSG_TYPE_NOTIFICATION:
+				ret = recv_notification(nbr, pdu, msg_size);
+				break;
+			case MSG_TYPE_INIT:
+				ret = recv_init(nbr, pdu, msg_size);
+				break;
+			case MSG_TYPE_KEEPALIVE:
+				ret = recv_keepalive(nbr, pdu, msg_size);
+				break;
+			case MSG_TYPE_ADDR:
+			case MSG_TYPE_ADDRWITHDRAW:
+				ret = recv_address(nbr, pdu, msg_size);
+				break;
+			case MSG_TYPE_LABELMAPPING:
+			case MSG_TYPE_LABELREQUEST:
+			case MSG_TYPE_LABELWITHDRAW:
+			case MSG_TYPE_LABELRELEASE:
+			case MSG_TYPE_LABELABORTREQ:
+				ret = recv_labelmessage(nbr, pdu, msg_size,
+				    type);
+				break;
+			default:
+				log_debug("%s: unknown LDP packet from nbr %s",
+				    __func__, inet_ntoa(nbr->id));
+				if (!(ntohs(ldp_msg->type) & UNKNOWN_FLAG)) {
+					session_shutdown(nbr, S_UNKNOWN_MSG,
+					    ldp_msg->msgid, ldp_msg->type);
+					free(buf);
+					return (0);
+				}
+				/* unknown flag is set, ignore the message */
+				ret = 0;
+				break;
+			}
+
+			if (ret == -1) {
+				/* parser failed, giving up */
+				free(buf);
+				return (0);
+			}
+
+			/* Analyse the next message */
+			pdu += msg_size;
+			len -= msg_size;
+		}
+		free(buf);
+		if (len != 0) {
+			session_shutdown(nbr, S_BAD_PDU_LEN, 0, 0);
+			return (0);
+		}
+	}
+
+	return (0);
+}
+
+static int
+session_write(struct thread *thread)
+{
+	struct tcp_conn *tcp = THREAD_ARG(thread);
+	struct nbr	*nbr = tcp->nbr;
+
+	tcp->wbuf.ev = NULL;
+
+	if (msgbuf_write(&tcp->wbuf.wbuf) <= 0)
+		if (errno != EAGAIN && nbr)
+			nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
+
+	if (nbr == NULL && !tcp->wbuf.wbuf.queued) {
+		/*
+		 * We are done sending the notification message, now we can
+		 * close the socket.
+		 */
+		tcp_close(tcp);
+		return (0);
+	}
+
+	evbuf_event_add(&tcp->wbuf);
+
+	return (0);
+}
+
+void
+session_shutdown(struct nbr *nbr, uint32_t status, uint32_t msgid,
+    uint32_t type)
+{
+	if (nbr->tcp == NULL)
+		return;
+
+	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));
+
+	send_notification_nbr(nbr, status, msgid, type);
+
+	/* try to flush write buffer, if it fails tough shit */
+	msgbuf_write(&nbr->tcp->wbuf.wbuf);
+
+	nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
+}
+
+void
+session_close(struct nbr *nbr)
+{
+	log_debug("%s: closing session with lsr-id %s", __func__,
+	    inet_ntoa(nbr->id));
+
+	tcp_close(nbr->tcp);
+	nbr_stop_ktimer(nbr);
+	nbr_stop_ktimeout(nbr);
+}
+
+static ssize_t
+session_get_pdu(struct ibuf_read *r, char **b)
+{
+	struct ldp_hdr	l;
+	size_t		av, dlen, left;
+
+	av = r->wpos;
+	if (av < sizeof(l))
+		return (0);
+
+	memcpy(&l, r->buf, sizeof(l));
+	dlen = ntohs(l.length) + LDP_HDR_DEAD_LEN;
+	if (dlen > av)
+		return (0);
+
+	if ((*b = malloc(dlen)) == NULL)
+		return (-1);
+
+	memcpy(*b, r->buf, dlen);
+	if (dlen < av) {
+		left = av - dlen;
+		memmove(r->buf, r->buf + dlen, left);
+		r->wpos = left;
+	} else
+		r->wpos = 0;
+
+	return (dlen);
+}
+
+struct tcp_conn *
+tcp_new(int fd, struct nbr *nbr)
+{
+	struct tcp_conn		*tcp;
+	struct sockaddr_storage	 src;
+	socklen_t		 len = sizeof(src);
+
+	if ((tcp = calloc(1, sizeof(*tcp))) == NULL)
+		fatal(__func__);
+
+	tcp->fd = fd;
+	evbuf_init(&tcp->wbuf, tcp->fd, session_write, tcp);
+
+	if (nbr) {
+		if ((tcp->rbuf = calloc(1, sizeof(struct ibuf_read))) == NULL)
+			fatal(__func__);
+
+		tcp->rev = thread_add_read(master, session_read, nbr, tcp->fd);
+		tcp->nbr = nbr;
+	}
+
+	getsockname(fd, (struct sockaddr *)&src, &len);
+	sa2addr((struct sockaddr *)&src, NULL, NULL, &tcp->lport);
+	getpeername(fd, (struct sockaddr *)&src, &len);
+	sa2addr((struct sockaddr *)&src, NULL, NULL, &tcp->rport);
+
+	return (tcp);
+}
+
+static void
+tcp_close(struct tcp_conn *tcp)
+{
+	evbuf_clear(&tcp->wbuf);
+
+	if (tcp->nbr) {
+		THREAD_READ_OFF(tcp->rev);
+		free(tcp->rbuf);
+		tcp->nbr->tcp = NULL;
+	}
+
+	close(tcp->fd);
+	accept_unpause();
+	free(tcp);
+}
+
+static struct pending_conn *
+pending_conn_new(int fd, int af, union ldpd_addr *addr)
+{
+	struct pending_conn	*pconn;
+
+	if ((pconn = calloc(1, sizeof(*pconn))) == NULL)
+		fatal(__func__);
+
+	pconn->fd = fd;
+	pconn->af = af;
+	pconn->addr = *addr;
+	TAILQ_INSERT_TAIL(&global.pending_conns, pconn, entry);
+	pconn->ev_timeout = thread_add_timer(master, pending_conn_timeout,
+	    pconn, PENDING_CONN_TIMEOUT);
+
+	return (pconn);
+}
+
+void
+pending_conn_del(struct pending_conn *pconn)
+{
+	THREAD_TIMER_OFF(pconn->ev_timeout);
+	TAILQ_REMOVE(&global.pending_conns, pconn, entry);
+	free(pconn);
+}
+
+struct pending_conn *
+pending_conn_find(int af, union ldpd_addr *addr)
+{
+	struct pending_conn	*pconn;
+
+	TAILQ_FOREACH(pconn, &global.pending_conns, entry)
+		if (af == pconn->af &&
+		    ldp_addrcmp(af, addr, &pconn->addr) == 0)
+			return (pconn);
+
+	return (NULL);
+}
+
+static int
+pending_conn_timeout(struct thread *thread)
+{
+	struct pending_conn	*pconn = THREAD_ARG(thread);
+	struct tcp_conn		*tcp;
+
+	pconn->ev_timeout = NULL;
+
+	log_debug("%s: no adjacency with remote end: %s", __func__,
+	    log_addr(pconn->af, &pconn->addr));
+
+	/*
+	 * Create a write buffer detached from any neighbor to send a
+	 * notification message reliably.
+	 */
+	tcp = tcp_new(pconn->fd, NULL);
+	send_notification(S_NO_HELLO, tcp, 0, 0);
+	msgbuf_write(&tcp->wbuf.wbuf);
+
+	pending_conn_del(pconn);
+
+	return (0);
+}
diff --git a/ldpd/pfkey.c b/ldpd/pfkey.c
new file mode 100644
index 0000000..29f763e
--- /dev/null
+++ b/ldpd/pfkey.c
@@ -0,0 +1,469 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ * Copyright (c) 2003, 2004 Markus Friedl <markus@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+
+static int	 pfkey_send(int, uint8_t, uint8_t, uint8_t,
+		    int, union ldpd_addr *, union ldpd_addr *,
+		    uint32_t, uint8_t, int, char *, uint8_t, int, char *,
+		    uint16_t, uint16_t);
+static int	 pfkey_reply(int, uint32_t *);
+static int	 pfkey_sa_add(int, union ldpd_addr *, union ldpd_addr *,
+		    uint8_t, char *, uint32_t *);
+static int	 pfkey_sa_remove(int, union ldpd_addr *, union ldpd_addr *,
+		    uint32_t *);
+static int	 pfkey_md5sig_establish(struct nbr *, struct nbr_params *nbrp);
+static int	 pfkey_md5sig_remove(struct nbr *);
+
+#define	PFKEY2_CHUNK sizeof(uint64_t)
+#define	ROUNDUP(x) (((x) + (PFKEY2_CHUNK - 1)) & ~(PFKEY2_CHUNK - 1))
+#define	IOV_CNT	20
+
+static uint32_t	 sadb_msg_seq;
+static uint32_t	 pid; /* should pid_t but pfkey needs uint32_t */
+static int	 fd;
+
+static int
+pfkey_send(int sd, uint8_t satype, uint8_t mtype, uint8_t dir,
+    int af, union ldpd_addr *src, union ldpd_addr *dst, uint32_t spi,
+    uint8_t aalg, int alen, char *akey, uint8_t ealg, int elen, char *ekey,
+    uint16_t sport, uint16_t dport)
+{
+	struct sadb_msg		smsg;
+	struct sadb_sa		sa;
+	struct sadb_address	sa_src, sa_dst;
+	struct sadb_key		sa_akey, sa_ekey;
+	struct sadb_spirange	sa_spirange;
+	struct iovec		iov[IOV_CNT];
+	ssize_t			n;
+	int			len = 0;
+	int			iov_cnt;
+	struct sockaddr_storage	ssrc, sdst, smask, dmask;
+	struct sockaddr		*saptr;
+
+	if (!pid)
+		pid = getpid();
+
+	/* we need clean sockaddr... no ports set */
+	memset(&ssrc, 0, sizeof(ssrc));
+	memset(&smask, 0, sizeof(smask));
+	if ((saptr = addr2sa(af, src, 0)))
+		memcpy(&ssrc, saptr, sizeof(ssrc));
+	switch (af) {
+	case AF_INET:
+		memset(&((struct sockaddr_in *)&smask)->sin_addr, 0xff, 32/8);
+		break;
+	case AF_INET6:
+		memset(&((struct sockaddr_in6 *)&smask)->sin6_addr, 0xff,
+		    128/8);
+		break;
+	default:
+		return (-1);
+	}
+	smask.ss_family = ssrc.ss_family;
+	smask.ss_len = ssrc.ss_len;
+
+	memset(&sdst, 0, sizeof(sdst));
+	memset(&dmask, 0, sizeof(dmask));
+	if ((saptr = addr2sa(af, dst, 0)))
+		memcpy(&sdst, saptr, sizeof(sdst));
+	switch (af) {
+	case AF_INET:
+		memset(&((struct sockaddr_in *)&dmask)->sin_addr, 0xff, 32/8);
+		break;
+	case AF_INET6:
+		memset(&((struct sockaddr_in6 *)&dmask)->sin6_addr, 0xff,
+		    128/8);
+		break;
+	default:
+		return (-1);
+	}
+	dmask.ss_family = sdst.ss_family;
+	dmask.ss_len = sdst.ss_len;
+
+	memset(&smsg, 0, sizeof(smsg));
+	smsg.sadb_msg_version = PF_KEY_V2;
+	smsg.sadb_msg_seq = ++sadb_msg_seq;
+	smsg.sadb_msg_pid = pid;
+	smsg.sadb_msg_len = sizeof(smsg) / 8;
+	smsg.sadb_msg_type = mtype;
+	smsg.sadb_msg_satype = satype;
+
+	switch (mtype) {
+	case SADB_GETSPI:
+		memset(&sa_spirange, 0, sizeof(sa_spirange));
+		sa_spirange.sadb_spirange_exttype = SADB_EXT_SPIRANGE;
+		sa_spirange.sadb_spirange_len = sizeof(sa_spirange) / 8;
+		sa_spirange.sadb_spirange_min = 0x100;
+		sa_spirange.sadb_spirange_max = 0xffffffff;
+		sa_spirange.sadb_spirange_reserved = 0;
+		break;
+	case SADB_ADD:
+	case SADB_UPDATE:
+	case SADB_DELETE:
+		memset(&sa, 0, sizeof(sa));
+		sa.sadb_sa_exttype = SADB_EXT_SA;
+		sa.sadb_sa_len = sizeof(sa) / 8;
+		sa.sadb_sa_replay = 0;
+		sa.sadb_sa_spi = spi;
+		sa.sadb_sa_state = SADB_SASTATE_MATURE;
+		break;
+	}
+
+	memset(&sa_src, 0, sizeof(sa_src));
+	sa_src.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
+	sa_src.sadb_address_len = (sizeof(sa_src) + ROUNDUP(ssrc.ss_len)) / 8;
+
+	memset(&sa_dst, 0, sizeof(sa_dst));
+	sa_dst.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
+	sa_dst.sadb_address_len = (sizeof(sa_dst) + ROUNDUP(sdst.ss_len)) / 8;
+
+	sa.sadb_sa_auth = aalg;
+	sa.sadb_sa_encrypt = SADB_X_EALG_AES; /* XXX */
+
+	switch (mtype) {
+	case SADB_ADD:
+	case SADB_UPDATE:
+		memset(&sa_akey, 0, sizeof(sa_akey));
+		sa_akey.sadb_key_exttype = SADB_EXT_KEY_AUTH;
+		sa_akey.sadb_key_len = (sizeof(sa_akey) +
+		    ((alen + 7) / 8) * 8) / 8;
+		sa_akey.sadb_key_bits = 8 * alen;
+
+		memset(&sa_ekey, 0, sizeof(sa_ekey));
+		sa_ekey.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
+		sa_ekey.sadb_key_len = (sizeof(sa_ekey) +
+		    ((elen + 7) / 8) * 8) / 8;
+		sa_ekey.sadb_key_bits = 8 * elen;
+
+		break;
+	}
+
+	iov_cnt = 0;
+
+	/* msghdr */
+	iov[iov_cnt].iov_base = &smsg;
+	iov[iov_cnt].iov_len = sizeof(smsg);
+	iov_cnt++;
+
+	switch (mtype) {
+	case SADB_ADD:
+	case SADB_UPDATE:
+	case SADB_DELETE:
+		/* SA hdr */
+		iov[iov_cnt].iov_base = &sa;
+		iov[iov_cnt].iov_len = sizeof(sa);
+		smsg.sadb_msg_len += sa.sadb_sa_len;
+		iov_cnt++;
+		break;
+	case SADB_GETSPI:
+		/* SPI range */
+		iov[iov_cnt].iov_base = &sa_spirange;
+		iov[iov_cnt].iov_len = sizeof(sa_spirange);
+		smsg.sadb_msg_len += sa_spirange.sadb_spirange_len;
+		iov_cnt++;
+		break;
+	}
+
+	/* dest addr */
+	iov[iov_cnt].iov_base = &sa_dst;
+	iov[iov_cnt].iov_len = sizeof(sa_dst);
+	iov_cnt++;
+	iov[iov_cnt].iov_base = &sdst;
+	iov[iov_cnt].iov_len = ROUNDUP(sdst.ss_len);
+	smsg.sadb_msg_len += sa_dst.sadb_address_len;
+	iov_cnt++;
+
+	/* src addr */
+	iov[iov_cnt].iov_base = &sa_src;
+	iov[iov_cnt].iov_len = sizeof(sa_src);
+	iov_cnt++;
+	iov[iov_cnt].iov_base = &ssrc;
+	iov[iov_cnt].iov_len = ROUNDUP(ssrc.ss_len);
+	smsg.sadb_msg_len += sa_src.sadb_address_len;
+	iov_cnt++;
+
+	switch (mtype) {
+	case SADB_ADD:
+	case SADB_UPDATE:
+		if (alen) {
+			/* auth key */
+			iov[iov_cnt].iov_base = &sa_akey;
+			iov[iov_cnt].iov_len = sizeof(sa_akey);
+			iov_cnt++;
+			iov[iov_cnt].iov_base = akey;
+			iov[iov_cnt].iov_len = ((alen + 7) / 8) * 8;
+			smsg.sadb_msg_len += sa_akey.sadb_key_len;
+			iov_cnt++;
+		}
+		if (elen) {
+			/* encryption key */
+			iov[iov_cnt].iov_base = &sa_ekey;
+			iov[iov_cnt].iov_len = sizeof(sa_ekey);
+			iov_cnt++;
+			iov[iov_cnt].iov_base = ekey;
+			iov[iov_cnt].iov_len = ((elen + 7) / 8) * 8;
+			smsg.sadb_msg_len += sa_ekey.sadb_key_len;
+			iov_cnt++;
+		}
+		break;
+	}
+
+	len = smsg.sadb_msg_len * 8;
+	do {
+		n = writev(sd, iov, iov_cnt);
+	} while (n == -1 && (errno == EAGAIN || errno == EINTR));
+
+	if (n == -1) {
+		log_warn("writev (%d/%d)", iov_cnt, len);
+		return (-1);
+	}
+
+	return (0);
+}
+
+int
+pfkey_read(int sd, struct sadb_msg *h)
+{
+	struct sadb_msg hdr;
+
+	if (recv(sd, &hdr, sizeof(hdr), MSG_PEEK) != sizeof(hdr)) {
+		if (errno == EAGAIN || errno == EINTR)
+			return (0);
+		log_warn("pfkey peek");
+		return (-1);
+	}
+
+	/* XXX: Only one message can be outstanding. */
+	if (hdr.sadb_msg_seq == sadb_msg_seq &&
+	    hdr.sadb_msg_pid == pid) {
+		if (h)
+			*h = hdr;
+		return (0);
+	}
+
+	/* not ours, discard */
+	if (read(sd, &hdr, sizeof(hdr)) == -1) {
+		if (errno == EAGAIN || errno == EINTR)
+			return (0);
+		log_warn("pfkey read");
+		return (-1);
+	}
+
+	return (1);
+}
+
+static int
+pfkey_reply(int sd, uint32_t *spip)
+{
+	struct sadb_msg hdr, *msg;
+	struct sadb_ext *ext;
+	struct sadb_sa *sa;
+	uint8_t *data;
+	ssize_t len;
+	int rv;
+
+	do {
+		rv = pfkey_read(sd, &hdr);
+		if (rv == -1)
+			return (-1);
+	} while (rv);
+
+	if (hdr.sadb_msg_errno != 0) {
+		errno = hdr.sadb_msg_errno;
+		if (errno == ESRCH)
+			return (0);
+		else {
+			log_warn("pfkey");
+			return (-1);
+		}
+	}
+	if ((data = reallocarray(NULL, hdr.sadb_msg_len, PFKEY2_CHUNK)) == NULL) {
+		log_warn("pfkey malloc");
+		return (-1);
+	}
+	len = hdr.sadb_msg_len * PFKEY2_CHUNK;
+	if (read(sd, data, len) != len) {
+		log_warn("pfkey read");
+		explicit_bzero(data, len);
+		free(data);
+		return (-1);
+	}
+
+	if (hdr.sadb_msg_type == SADB_GETSPI) {
+		if (spip == NULL) {
+			explicit_bzero(data, len);
+			free(data);
+			return (0);
+		}
+
+		msg = (struct sadb_msg *)data;
+		for (ext = (struct sadb_ext *)(msg + 1);
+		    (size_t)((uint8_t *)ext - (uint8_t *)msg) <
+		    msg->sadb_msg_len * PFKEY2_CHUNK;
+		    ext = (struct sadb_ext *)((uint8_t *)ext +
+		    ext->sadb_ext_len * PFKEY2_CHUNK)) {
+			if (ext->sadb_ext_type == SADB_EXT_SA) {
+				sa = (struct sadb_sa *) ext;
+				*spip = sa->sadb_sa_spi;
+				break;
+			}
+		}
+	}
+	explicit_bzero(data, len);
+	free(data);
+	return (0);
+}
+
+static int
+pfkey_sa_add(int af, union ldpd_addr *src, union ldpd_addr *dst, uint8_t keylen,
+    char *key, uint32_t *spi)
+{
+	if (pfkey_send(fd, SADB_X_SATYPE_TCPSIGNATURE, SADB_GETSPI, 0,
+	    af, src, dst, 0, 0, 0, NULL, 0, 0, NULL, 0, 0) < 0)
+		return (-1);
+	if (pfkey_reply(fd, spi) < 0)
+		return (-1);
+	if (pfkey_send(fd, SADB_X_SATYPE_TCPSIGNATURE, SADB_UPDATE, 0,
+	    af, src, dst, *spi, 0, keylen, key, 0, 0, NULL, 0, 0) < 0)
+		return (-1);
+	if (pfkey_reply(fd, NULL) < 0)
+		return (-1);
+	return (0);
+}
+
+static int
+pfkey_sa_remove(int af, union ldpd_addr *src, union ldpd_addr *dst,
+    uint32_t *spi)
+{
+	if (pfkey_send(fd, SADB_X_SATYPE_TCPSIGNATURE, SADB_DELETE, 0,
+	    af, src, dst, *spi, 0, 0, NULL, 0, 0, NULL, 0, 0) < 0)
+		return (-1);
+	if (pfkey_reply(fd, NULL) < 0)
+		return (-1);
+	*spi = 0;
+	return (0);
+}
+
+static int
+pfkey_md5sig_establish(struct nbr *nbr, struct nbr_params *nbrp)
+{
+	sleep(1);
+
+	if (!nbr->auth.spi_out)
+		if (pfkey_sa_add(nbr->af, &nbr->laddr, &nbr->raddr,
+		    nbrp->auth.md5key_len, nbrp->auth.md5key,
+		    &nbr->auth.spi_out) == -1)
+			return (-1);
+	if (!nbr->auth.spi_in)
+		if (pfkey_sa_add(nbr->af, &nbr->raddr, &nbr->laddr,
+		    nbrp->auth.md5key_len, nbrp->auth.md5key,
+		    &nbr->auth.spi_in) == -1)
+			return (-1);
+
+	nbr->auth.established = 1;
+	return (0);
+}
+
+static int
+pfkey_md5sig_remove(struct nbr *nbr)
+{
+	if (nbr->auth.spi_out)
+		if (pfkey_sa_remove(nbr->af, &nbr->laddr, &nbr->raddr,
+		    &nbr->auth.spi_out) == -1)
+			return (-1);
+	if (nbr->auth.spi_in)
+		if (pfkey_sa_remove(nbr->af, &nbr->raddr, &nbr->laddr,
+		    &nbr->auth.spi_in) == -1)
+			return (-1);
+
+	nbr->auth.established = 0;
+	nbr->auth.spi_in = 0;
+	nbr->auth.spi_out = 0;
+	nbr->auth.method = AUTH_NONE;
+	memset(nbr->auth.md5key, 0, sizeof(nbr->auth.md5key));
+
+	return (0);
+}
+
+int
+pfkey_establish(struct nbr *nbr, struct nbr_params *nbrp)
+{
+	if (nbrp->auth.method == AUTH_NONE)
+		return (0);
+
+	/*
+	 * make sure we keep copies of everything we need to
+	 * remove SAs and flows later again.
+	 */
+	nbr->auth.method = nbrp->auth.method;
+
+	switch (nbr->auth.method) {
+	case AUTH_MD5SIG:
+		strlcpy(nbr->auth.md5key, nbrp->auth.md5key,
+		    sizeof(nbr->auth.md5key));
+		return (pfkey_md5sig_establish(nbr, nbrp));
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+int
+pfkey_remove(struct nbr *nbr)
+{
+	if (nbr->auth.method == AUTH_NONE || !nbr->auth.established)
+		return (0);
+
+	switch (nbr->auth.method) {
+	case AUTH_MD5SIG:
+		return (pfkey_md5sig_remove(nbr));
+	default:
+		break;
+	}
+
+	return (0);
+}
+
+int
+pfkey_init(void)
+{
+	if ((fd = socket(PF_KEY, SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK,
+	    PF_KEY_V2)) == -1) {
+		if (errno == EPROTONOSUPPORT) {
+			log_warnx("PF_KEY not available");
+			sysdep.no_pfkey = 1;
+			return (-1);
+		} else
+			fatal("pfkey setup failed");
+	}
+	return (fd);
+}
+#endif /* __OpenBSD__ */
diff --git a/ldpd/socket.c b/ldpd/socket.c
new file mode 100644
index 0000000..a6a1377
--- /dev/null
+++ b/ldpd/socket.c
@@ -0,0 +1,436 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2016 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2009 Michele Marchetto <michele@openbsd.org>
+ * Copyright (c) 2005 Claudio Jeker <claudio@openbsd.org>
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "ldpe.h"
+#include "log.h"
+
+#include "lib/log.h"
+#include "privs.h"
+#include "sockopt.h"
+
+extern struct zebra_privs_t	 ldpd_privs;
+extern struct zebra_privs_t	 ldpe_privs;
+
+int
+ldp_create_socket(int af, enum socket_type type)
+{
+	int			 fd, domain, proto;
+	union ldpd_addr		 addr;
+	struct sockaddr_storage	 local_sa;
+#ifdef __OpenBSD__
+	int			 opt;
+#endif
+	int			 save_errno;
+
+	/* create socket */
+	switch (type) {
+	case LDP_SOCKET_DISC:
+	case LDP_SOCKET_EDISC:
+		domain = SOCK_DGRAM;
+		proto = IPPROTO_UDP;
+		break;
+	case LDP_SOCKET_SESSION:
+		domain = SOCK_STREAM;
+		proto = IPPROTO_TCP;
+		break;
+	default:
+		fatalx("ldp_create_socket: unknown socket type");
+	}
+	fd = socket(af, domain, proto);
+	if (fd == -1) {
+		log_warn("%s: error creating socket", __func__);
+		return (-1);
+	}
+	sock_set_blockmode(fd, BM_NONBLOCK);
+	sockopt_v6only(af, fd);
+
+	/* bind to a local address/port */
+	switch (type) {
+	case LDP_SOCKET_DISC:
+		/* listen on all addresses */
+		memset(&addr, 0, sizeof(addr));
+		memcpy(&local_sa, addr2sa(af, &addr, LDP_PORT),
+		    sizeof(local_sa));
+		break;
+	case LDP_SOCKET_EDISC:
+	case LDP_SOCKET_SESSION:
+		addr = (ldp_af_conf_get(ldpd_conf, af))->trans_addr;
+		memcpy(&local_sa, addr2sa(af, &addr, LDP_PORT),
+		    sizeof(local_sa));
+		/* ignore any possible error */
+		sock_set_bindany(fd, 1);
+		break;
+	}
+	if (ldpd_privs.change(ZPRIVS_RAISE))
+		log_warn("%s: could not raise privs", __func__);
+	if (sock_set_reuse(fd, 1) == -1) {
+		close(fd);
+		return (-1);
+	}
+	if (bind(fd, (struct sockaddr *)&local_sa,
+	    sockaddr_len((struct sockaddr *)&local_sa)) == -1) {
+		save_errno = errno;
+		if (ldpd_privs.change(ZPRIVS_LOWER))
+			log_warn("%s: could not lower privs", __func__);
+		log_warnx("%s: error binding socket: %s", __func__,
+		    safe_strerror(save_errno));
+		close(fd);
+		return (-1);
+	}
+	if (ldpd_privs.change(ZPRIVS_LOWER))
+		log_warn("%s: could not lower privs", __func__);
+
+	/* set options */
+	switch (af) {
+	case AF_INET:
+		if (sock_set_ipv4_tos(fd, IPTOS_PREC_INTERNETCONTROL) == -1) {
+			close(fd);
+			return (-1);
+		}
+		if (type == LDP_SOCKET_DISC) {
+			if (sock_set_ipv4_mcast_ttl(fd,
+			    IP_DEFAULT_MULTICAST_TTL) == -1) {
+				close(fd);
+				return (-1);
+			}
+			if (sock_set_ipv4_mcast_loop(fd) == -1) {
+				close(fd);
+				return (-1);
+			}
+		}
+		if (type == LDP_SOCKET_DISC || type == LDP_SOCKET_EDISC) {
+			if (sock_set_ipv4_recvif(fd, 1) == -1) {
+				close(fd);
+				return (-1);
+			}
+#ifndef MSG_MCAST
+#if defined(HAVE_IP_PKTINFO)
+			if (sock_set_ipv4_pktinfo(fd, 1) == -1) {
+				close(fd);
+				return (-1);
+			}
+#elif defined(HAVE_IP_RECVDSTADDR)
+			if (sock_set_ipv4_recvdstaddr(fd, 1) == -1) {
+				close(fd);
+				return (-1);
+			}
+#else
+#error "Unsupported socket API"
+#endif
+#endif /* MSG_MCAST */
+		}
+		break;
+	case AF_INET6:
+		if (sock_set_ipv6_dscp(fd, IPTOS_PREC_INTERNETCONTROL) == -1) {
+			close(fd);
+			return (-1);
+		}
+		if (type == LDP_SOCKET_DISC) {
+			if (sock_set_ipv6_mcast_loop(fd) == -1) {
+				close(fd);
+				return (-1);
+			}
+		}
+		if (type == LDP_SOCKET_DISC || type == LDP_SOCKET_EDISC) {
+			if (sock_set_ipv6_pktinfo(fd, 1) == -1) {
+				close(fd);
+				return (-1);
+			}
+		}
+		break;
+	}
+	switch (type) {
+	case LDP_SOCKET_DISC:
+	case LDP_SOCKET_EDISC:
+		sock_set_recvbuf(fd);
+		break;
+	case LDP_SOCKET_SESSION:
+		if (listen(fd, LDP_BACKLOG) == -1)
+			log_warn("%s: error listening on socket", __func__);
+
+#ifdef __OpenBSD__
+		opt = 1;
+		if (setsockopt(fd, IPPROTO_TCP, TCP_MD5SIG, &opt,
+		    sizeof(opt)) == -1) {
+			if (errno == ENOPROTOOPT) {	/* system w/o md5sig */
+				log_warnx("md5sig not available, disabling");
+				sysdep.no_md5sig = 1;
+			} else {
+				close(fd);
+				return (-1);
+			}
+		}
+#endif
+		break;
+	}
+
+	return (fd);
+}
+
+void
+sock_set_blockmode(int fd, enum blockmodes bm)
+{
+	int	flags;
+
+	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
+		fatal("fcntl F_GETFL");
+
+	if (bm == BM_NONBLOCK)
+		flags |= O_NONBLOCK;
+	else
+		flags &= ~O_NONBLOCK;
+
+	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
+		fatal("fcntl F_SETFL");
+}
+
+void
+sock_set_recvbuf(int fd)
+{
+	int	bsize;
+
+	bsize = 65535;
+	while (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &bsize,
+	    sizeof(bsize)) == -1)
+		bsize /= 2;
+}
+
+int
+sock_set_reuse(int fd, int enable)
+{
+	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &enable,
+	    sizeof(int)) < 0) {
+		log_warn("%s: error setting SO_REUSEADDR", __func__);
+		return (-1);
+	}
+
+	return (0);
+}
+
+int
+sock_set_bindany(int fd, int enable)
+{
+#ifdef HAVE_SO_BINDANY
+	if (ldpd_privs.change(ZPRIVS_RAISE))
+		log_warn("%s: could not raise privs", __func__);
+	if (setsockopt(fd, SOL_SOCKET, SO_BINDANY, &enable,
+	    sizeof(int)) < 0) {
+		if (ldpd_privs.change(ZPRIVS_LOWER))
+			log_warn("%s: could not lower privs", __func__);
+		log_warn("%s: error setting SO_BINDANY", __func__);
+		return (-1);
+	}
+	if (ldpd_privs.change(ZPRIVS_LOWER))
+		log_warn("%s: could not lower privs", __func__);
+	return (0);
+#elif defined(HAVE_IP_FREEBIND)
+	if (setsockopt(fd, IPPROTO_IP, IP_FREEBIND, &enable, sizeof(int)) < 0) {
+		log_warn("%s: error setting IP_FREEBIND", __func__);
+		return (-1);
+	}
+	return (0);
+#else
+	log_warnx("%s: missing SO_BINDANY and IP_FREEBIND, unable to bind "
+	    "to a nonlocal IP address", __func__);
+	return (-1);
+#endif /* HAVE_SO_BINDANY */
+}
+
+#ifndef __OpenBSD__
+/*
+ * Set MD5 key for the socket, for the given peer address. If the password
+ * is NULL or zero-length, the option will be disabled.
+ */
+int
+sock_set_md5sig(int fd, int af, union ldpd_addr *addr, const char *password)
+{
+	int		 ret = -1;
+	int		 save_errno = ENOSYS;
+#if HAVE_DECL_TCP_MD5SIG
+	union sockunion	 su;
+#endif
+
+	if (fd == -1)
+		return (0);
+#if HAVE_DECL_TCP_MD5SIG
+	memcpy(&su, addr2sa(af, addr, 0), sizeof(su));
+
+	if (ldpe_privs.change(ZPRIVS_RAISE)) {
+		log_warn("%s: could not raise privs", __func__);
+		return (-1);
+	}
+	ret = sockopt_tcp_signature(fd, &su, password);
+	save_errno = errno;
+	if (ldpe_privs.change(ZPRIVS_LOWER))
+		log_warn("%s: could not lower privs", __func__);
+#endif /* HAVE_TCP_MD5SIG */
+	if (ret < 0)
+		log_warnx("%s: can't set TCP_MD5SIG option on fd %d: %s",
+		    __func__, fd, safe_strerror(save_errno));
+
+	return (ret);
+}
+#endif
+
+int
+sock_set_ipv4_mcast_ttl(int fd, uint8_t ttl)
+{
+	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,
+	    (char *)&ttl, sizeof(ttl)) < 0) {
+		log_warn("%s: error setting IP_MULTICAST_TTL to %d",
+		    __func__, ttl);
+		return (-1);
+	}
+
+	return (0);
+}
+
+int
+sock_set_ipv4_tos(int fd, int tos)
+{
+	if (setsockopt(fd, IPPROTO_IP, IP_TOS, (int *)&tos, sizeof(tos)) < 0) {
+		log_warn("%s: error setting IP_TOS to 0x%x", __func__, tos);
+		return (-1);
+	}
+
+	return (0);
+}
+
+#ifndef MSG_MCAST
+#if defined(HAVE_IP_PKTINFO)
+int
+sock_set_ipv4_pktinfo(int fd, int enable)
+{
+	if (setsockopt(fd, IPPROTO_IP, IP_PKTINFO, &enable,
+	    sizeof(enable)) < 0) {
+		log_warn("%s: error setting IP_PKTINFO", __func__);
+		return (-1);
+	}
+
+	return (0);
+}
+#elif defined(HAVE_IP_RECVDSTADDR)
+int
+sock_set_ipv4_recvdstaddr(int fd, int enable)
+{
+	if (setsockopt(fd, IPPROTO_IP, IP_RECVDSTADDR, &enable,
+	    sizeof(enable)) < 0) {
+		log_warn("%s: error setting IP_RECVDSTADDR", __func__);
+		return (-1);
+	}
+
+	return (0);
+}
+#else
+#error "Unsupported socket API"
+#endif
+#endif /* MSG_MCAST */
+
+int
+sock_set_ipv4_recvif(int fd, int enable)
+{
+	return (setsockopt_ifindex(AF_INET, fd, enable));
+}
+
+int
+sock_set_ipv4_mcast(struct iface *iface)
+{
+	struct in_addr		 if_addr;
+
+	if_addr.s_addr = if_get_ipv4_addr(iface);
+
+	if (setsockopt_ipv4_multicast_if(global.ipv4.ldp_disc_socket,
+	    if_addr, iface->ifindex) < 0) {
+		log_warn("%s: error setting IP_MULTICAST_IF, interface %s",
+		    __func__, iface->name);
+		return (-1);
+	}
+
+	return (0);
+}
+
+int
+sock_set_ipv4_mcast_loop(int fd)
+{
+	uint8_t	loop = 0;
+
+	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,
+	    (char *)&loop, sizeof(loop)) < 0) {
+		log_warn("%s: error setting IP_MULTICAST_LOOP", __func__);
+		return (-1);
+	}
+
+	return (0);
+}
+
+int
+sock_set_ipv6_dscp(int fd, int dscp)
+{
+	if (setsockopt(fd, IPPROTO_IPV6, IPV6_TCLASS, &dscp,
+	    sizeof(dscp)) < 0) {
+		log_warn("%s: error setting IPV6_TCLASS", __func__);
+		return (-1);
+	}
+
+	return (0);
+}
+
+int
+sock_set_ipv6_pktinfo(int fd, int enable)
+{
+	if (setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO, &enable,
+	    sizeof(enable)) < 0) {
+		log_warn("%s: error setting IPV6_RECVPKTINFO", __func__);
+		return (-1);
+	}
+
+	return (0);
+}
+
+int
+sock_set_ipv6_mcast(struct iface *iface)
+{
+	if (setsockopt(global.ipv6.ldp_disc_socket, IPPROTO_IPV6,
+	    IPV6_MULTICAST_IF, &iface->ifindex, sizeof(iface->ifindex)) < 0) {
+		log_warn("%s: error setting IPV6_MULTICAST_IF, interface %s",
+		    __func__, iface->name);
+		return (-1);
+	}
+
+	return (0);
+}
+
+int
+sock_set_ipv6_mcast_loop(int fd)
+{
+	unsigned int	loop = 0;
+
+	if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,
+	    (unsigned int *)&loop, sizeof(loop)) < 0) {
+		log_warn("%s: error setting IPV6_MULTICAST_LOOP", __func__);
+		return (-1);
+	}
+
+	return (0);
+}
diff --git a/ldpd/util.c b/ldpd/util.c
new file mode 100644
index 0000000..e735263
--- /dev/null
+++ b/ldpd/util.c
@@ -0,0 +1,385 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2015 Renato Westphal <renato@openbsd.org>
+ * Copyright (c) 2012 Alexander Bluhm <bluhm@openbsd.org>
+ * Copyright (c) 2004 Esben Norby <norby@openbsd.org>
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "ldpd.h"
+#include "log.h"
+
+uint8_t
+mask2prefixlen(in_addr_t ina)
+{
+	if (ina == 0)
+		return (0);
+	else
+		return (33 - ffs(ntohl(ina)));
+}
+
+uint8_t
+mask2prefixlen6(struct sockaddr_in6 *sa_in6)
+{
+	uint8_t	l = 0, *ap, *ep;
+
+	/*
+	 * sin6_len is the size of the sockaddr so substract the offset of
+	 * the possibly truncated sin6_addr struct.
+	 */
+	ap = (uint8_t *)&sa_in6->sin6_addr;
+	ep = (uint8_t *)sa_in6 + sockaddr_len((struct sockaddr *)sa_in6);
+	for (; ap < ep; ap++) {
+		/* this "beauty" is adopted from sbin/route/show.c ... */
+		switch (*ap) {
+		case 0xff:
+			l += 8;
+			break;
+		case 0xfe:
+			l += 7;
+			return (l);
+		case 0xfc:
+			l += 6;
+			return (l);
+		case 0xf8:
+			l += 5;
+			return (l);
+		case 0xf0:
+			l += 4;
+			return (l);
+		case 0xe0:
+			l += 3;
+			return (l);
+		case 0xc0:
+			l += 2;
+			return (l);
+		case 0x80:
+			l += 1;
+			return (l);
+		case 0x00:
+			return (l);
+		default:
+			fatalx("non contiguous inet6 netmask");
+		}
+	}
+
+	return (l);
+}
+
+in_addr_t
+prefixlen2mask(uint8_t prefixlen)
+{
+	if (prefixlen == 0)
+		return (0);
+
+	return (htonl(0xffffffff << (32 - prefixlen)));
+}
+
+struct in6_addr *
+prefixlen2mask6(uint8_t prefixlen)
+{
+	static struct in6_addr	mask;
+	int			i;
+
+	memset(&mask, 0, sizeof(mask));
+	for (i = 0; i < prefixlen / 8; i++)
+		mask.s6_addr[i] = 0xff;
+	i = prefixlen % 8;
+	if (i)
+		mask.s6_addr[prefixlen / 8] = 0xff00 >> i;
+
+	return (&mask);
+}
+
+void
+ldp_applymask(int af, union ldpd_addr *dest, const union ldpd_addr *src,
+    int prefixlen)
+{
+	struct in6_addr	mask;
+	int		i;
+
+	switch (af) {
+	case AF_INET:
+		dest->v4.s_addr = src->v4.s_addr & prefixlen2mask(prefixlen);
+		break;
+	case AF_INET6:
+		memset(&mask, 0, sizeof(mask));
+		for (i = 0; i < prefixlen / 8; i++)
+			mask.s6_addr[i] = 0xff;
+		i = prefixlen % 8;
+		if (i)
+			mask.s6_addr[prefixlen / 8] = 0xff00 >> i;
+
+		for (i = 0; i < 16; i++)
+			dest->v6.s6_addr[i] = src->v6.s6_addr[i] &
+			    mask.s6_addr[i];
+		break;
+	default:
+		fatalx("ldp_applymask: unknown af");
+	}
+}
+
+int
+ldp_addrcmp(int af, const union ldpd_addr *a, const union ldpd_addr *b)
+{
+	switch (af) {
+	case AF_INET:
+		if (a->v4.s_addr == b->v4.s_addr)
+			return (0);
+		return ((ntohl(a->v4.s_addr) > ntohl(b->v4.s_addr)) ? 1 : -1);
+	case AF_INET6:
+		return (memcmp(&a->v6, &b->v6, sizeof(struct in6_addr)));
+	default:
+		fatalx("ldp_addrcmp: unknown af");
+	}
+}
+
+int
+ldp_addrisset(int af, const union ldpd_addr *addr)
+{
+	switch (af) {
+	case AF_UNSPEC:
+		return (0);
+	case AF_INET:
+		if (addr->v4.s_addr != INADDR_ANY)
+			return (1);
+		break;
+	case AF_INET6:
+		if (!IN6_IS_ADDR_UNSPECIFIED(&addr->v6))
+			return (1);
+		break;
+	default:
+		fatalx("ldp_addrisset: unknown af");
+	}
+
+	return (0);
+}
+
+int
+ldp_prefixcmp(int af, const union ldpd_addr *a, const union ldpd_addr *b,
+    uint8_t prefixlen)
+{
+	in_addr_t	mask, aa, ba;
+	int		i;
+	uint8_t		m;
+
+	switch (af) {
+	case AF_INET:
+		if (prefixlen == 0)
+			return (0);
+		if (prefixlen > 32)
+			fatalx("ldp_prefixcmp: bad IPv4 prefixlen");
+		mask = htonl(prefixlen2mask(prefixlen));
+		aa = htonl(a->v4.s_addr) & mask;
+		ba = htonl(b->v4.s_addr) & mask;
+		return (aa - ba);
+	case AF_INET6:
+		if (prefixlen == 0)
+			return (0);
+		if (prefixlen > 128)
+			fatalx("ldp_prefixcmp: bad IPv6 prefixlen");
+		for (i = 0; i < prefixlen / 8; i++)
+			if (a->v6.s6_addr[i] != b->v6.s6_addr[i])
+				return (a->v6.s6_addr[i] - b->v6.s6_addr[i]);
+		i = prefixlen % 8;
+		if (i) {
+			m = 0xff00 >> i;
+			if ((a->v6.s6_addr[prefixlen / 8] & m) !=
+			    (b->v6.s6_addr[prefixlen / 8] & m))
+				return ((a->v6.s6_addr[prefixlen / 8] & m) -
+				    (b->v6.s6_addr[prefixlen / 8] & m));
+		}
+		return (0);
+	default:
+		fatalx("ldp_prefixcmp: unknown af");
+	}
+	return (-1);
+}
+
+int
+bad_addr_v4(struct in_addr addr)
+{
+	uint32_t	 a = ntohl(addr.s_addr);
+
+	if (((a >> IN_CLASSA_NSHIFT) == 0) ||
+	    ((a >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET) ||
+	    IN_MULTICAST(a) || IN_BADCLASS(a))
+		return (1);
+
+	return (0);
+}
+
+int
+bad_addr_v6(struct in6_addr *addr)
+{
+	if (IN6_IS_ADDR_UNSPECIFIED(addr) ||
+	    IN6_IS_ADDR_LOOPBACK(addr) ||
+	    IN6_IS_ADDR_MULTICAST(addr) ||
+	    IN6_IS_ADDR_SITELOCAL(addr) ||
+	    IN6_IS_ADDR_V4MAPPED(addr) ||
+	    IN6_IS_ADDR_V4COMPAT(addr))
+		return (1);
+
+	return (0);
+}
+
+int
+bad_addr(int af, union ldpd_addr *addr)
+{
+	switch (af) {
+	case AF_INET:
+		return (bad_addr_v4(addr->v4));
+	case AF_INET6:
+		return (bad_addr_v6(&addr->v6));
+	default:
+		fatalx("bad_addr: unknown af");
+	}
+}
+
+void
+embedscope(struct sockaddr_in6 *sin6)
+{
+	uint16_t	 tmp16;
+
+	if (IN6_IS_SCOPE_EMBED(&sin6->sin6_addr)) {
+		memcpy(&tmp16, &sin6->sin6_addr.s6_addr[2], sizeof(tmp16));
+		if (tmp16 != 0) {
+			log_warnx("%s: address %s already has embeded scope %u",
+			    __func__, log_sockaddr(sin6), ntohs(tmp16));
+		}
+		tmp16 = htons(sin6->sin6_scope_id);
+		memcpy(&sin6->sin6_addr.s6_addr[2], &tmp16, sizeof(tmp16));
+		sin6->sin6_scope_id = 0;
+	}
+}
+
+void
+recoverscope(struct sockaddr_in6 *sin6)
+{
+	uint16_t	 tmp16;
+
+	if (sin6->sin6_scope_id != 0)
+		log_warnx("%s: address %s already has scope id %u",
+		    __func__, log_sockaddr(sin6), sin6->sin6_scope_id);
+
+	if (IN6_IS_SCOPE_EMBED(&sin6->sin6_addr)) {
+		memcpy(&tmp16, &sin6->sin6_addr.s6_addr[2], sizeof(tmp16));
+		sin6->sin6_scope_id = ntohs(tmp16);
+		sin6->sin6_addr.s6_addr[2] = 0;
+		sin6->sin6_addr.s6_addr[3] = 0;
+	}
+}
+
+void
+addscope(struct sockaddr_in6 *sin6, uint32_t id)
+{
+	if (sin6->sin6_scope_id != 0)
+		log_warnx("%s: address %s already has scope id %u", __func__,
+		    log_sockaddr(sin6), sin6->sin6_scope_id);
+
+	if (IN6_IS_SCOPE_EMBED(&sin6->sin6_addr))
+		sin6->sin6_scope_id = id;
+}
+
+void
+clearscope(struct in6_addr *in6)
+{
+	if (IN6_IS_SCOPE_EMBED(in6)) {
+		in6->s6_addr[2] = 0;
+		in6->s6_addr[3] = 0;
+	}
+}
+
+struct sockaddr *
+addr2sa(int af, union ldpd_addr *addr, uint16_t port)
+{
+	static struct sockaddr_storage	 ss;
+	struct sockaddr_in		*sa_in = (struct sockaddr_in *)&ss;
+	struct sockaddr_in6		*sa_in6 = (struct sockaddr_in6 *)&ss;
+
+	memset(&ss, 0, sizeof(ss));
+	switch (af) {
+	case AF_INET:
+		sa_in->sin_family = AF_INET;
+#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
+		sa_in->sin_len = sizeof(struct sockaddr_in);
+#endif
+		sa_in->sin_addr = addr->v4;
+		sa_in->sin_port = htons(port);
+		break;
+	case AF_INET6:
+		sa_in6->sin6_family = AF_INET6;
+#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
+		sa_in6->sin6_len = sizeof(struct sockaddr_in6);
+#endif
+		sa_in6->sin6_addr = addr->v6;
+		sa_in6->sin6_port = htons(port);
+		break;
+	default:
+		fatalx("addr2sa: unknown af");
+	}
+
+	return ((struct sockaddr *)&ss);
+}
+
+void
+sa2addr(struct sockaddr *sa, int *af, union ldpd_addr *addr, in_port_t *port)
+{
+	struct sockaddr_in		*sa_in = (struct sockaddr_in *)sa;
+	struct sockaddr_in6		*sa_in6 = (struct sockaddr_in6 *)sa;
+
+	if (addr)
+		memset(addr, 0, sizeof(*addr));
+	switch (sa->sa_family) {
+	case AF_INET:
+		if (af)
+			*af = AF_INET;
+		if (addr)
+			addr->v4 = sa_in->sin_addr;
+		if (port)
+			*port = sa_in->sin_port;
+		break;
+	case AF_INET6:
+		if (af)
+			*af = AF_INET6;
+		if (addr)
+			addr->v6 = sa_in6->sin6_addr;
+		if (port)
+			*port = sa_in6->sin6_port;
+		break;
+	default:
+		fatalx("sa2addr: unknown af");
+	}
+}
+
+socklen_t
+sockaddr_len(struct sockaddr *sa)
+{
+#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
+	return (sa->sa_len);
+#else
+	switch (sa->sa_family) {
+	case AF_INET:
+		return (sizeof(struct sockaddr_in));
+	case AF_INET6:
+		return (sizeof(struct sockaddr_in6));
+	default:
+		fatalx("sockaddr_len: unknown af");
+	}
+#endif
+}
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 57e859d..2049ccd 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -13,7 +13,8 @@ libzebra_la_SOURCES = \
 	sockunion.c prefix.c thread.c if.c memory.c buffer.c table.c hash.c \
 	filter.c routemap.c distribute.c stream.c str.c log.c plist.c \
 	zclient.c sockopt.c smux.c agentx.c snmp.c md5.c if_rmap.c keychain.c privs.c \
-	sigevent.c pqueue.c jhash.c memtypes.c workqueue.c vrf.c
+	sigevent.c pqueue.c jhash.c memtypes.c workqueue.c vrf.c \
+	imsg-buffer.c imsg.c
 
 BUILT_SOURCES = memtypes.h route_types.h gitversion.h
 
@@ -28,7 +29,8 @@ pkginclude_HEADERS = \
 	str.h stream.h table.h thread.h vector.h version.h vty.h zebra.h \
 	plist.h zclient.h sockopt.h smux.h md5.h if_rmap.h keychain.h \
 	privs.h sigevent.h pqueue.h jhash.h zassert.h memtypes.h \
-	workqueue.h route_types.h libospf.h vrf.h fifo.h
+	workqueue.h route_types.h libospf.h vrf.h fifo.h mpls.h \
+	imsg.h openbsd-queue.h openbsd-tree.h
 
 noinst_HEADERS = \
 	plist_int.h
diff --git a/lib/command.c b/lib/command.c
index 8089360..4fac26b 100644
--- a/lib/command.c
+++ b/lib/command.c
@@ -2602,6 +2602,19 @@ node_parent ( enum node_type node )
     case KEYCHAIN_KEY_NODE:
       ret = KEYCHAIN_NODE;
       break;
+    case LDP_IPV4_NODE:
+    case LDP_IPV6_NODE:
+      ret = LDP_NODE;
+      break;
+    case LDP_IPV4_IFACE_NODE:
+      ret = LDP_IPV4_NODE;
+      break;
+    case LDP_IPV6_IFACE_NODE:
+      ret = LDP_IPV6_NODE;
+      break;
+    case LDP_PSEUDOWIRE_NODE:
+      ret = LDP_L2VPN_NODE;
+      break;
     default:
       ret = CONFIG_NODE;
     }
@@ -2952,6 +2965,8 @@ DEFUN (config_exit,
     case BABEL_NODE:
     case OSPF_NODE:
     case OSPF6_NODE:
+    case LDP_NODE:
+    case LDP_L2VPN_NODE:
     case ISIS_NODE:
     case KEYCHAIN_NODE:
     case MASC_NODE:
@@ -2970,6 +2985,19 @@ DEFUN (config_exit,
     case BGP_IPV6M_NODE:
       vty->node = BGP_NODE;
       break;
+    case LDP_IPV4_NODE:
+    case LDP_IPV6_NODE:
+      vty->node = LDP_NODE;
+      break;
+    case LDP_IPV4_IFACE_NODE:
+      vty->node = LDP_IPV4_NODE;
+      break;
+    case LDP_IPV6_IFACE_NODE:
+      vty->node = LDP_IPV6_NODE;
+      break;
+    case LDP_PSEUDOWIRE_NODE:
+      vty->node = LDP_L2VPN_NODE;
+      break;
     case KEYCHAIN_KEY_NODE:
       vty->node = KEYCHAIN_NODE;
       break;
@@ -3016,6 +3044,13 @@ DEFUN (config_end,
     case RMAP_NODE:
     case OSPF_NODE:
     case OSPF6_NODE:
+    case LDP_NODE:
+    case LDP_IPV4_NODE:
+    case LDP_IPV6_NODE:
+    case LDP_IPV4_IFACE_NODE:
+    case LDP_IPV6_IFACE_NODE:
+    case LDP_L2VPN_NODE:
+    case LDP_PSEUDOWIRE_NODE:
     case ISIS_NODE:
     case KEYCHAIN_NODE:
     case KEYCHAIN_KEY_NODE:
diff --git a/lib/command.h b/lib/command.h
index 6a20e23..4c32267 100644
--- a/lib/command.h
+++ b/lib/command.h
@@ -91,6 +91,13 @@ enum node_type
   BGP_ENCAPV6_NODE,		/* BGP ENCAP SAFI */
   OSPF_NODE,			/* OSPF protocol mode */
   OSPF6_NODE,			/* OSPF protocol for IPv6 mode */
+  LDP_NODE,			/* LDP protocol mode */
+  LDP_IPV4_NODE,		/* LDP IPv4 address family */
+  LDP_IPV6_NODE,		/* LDP IPv6 address family */
+  LDP_IPV4_IFACE_NODE,		/* LDP IPv4 Interface */
+  LDP_IPV6_IFACE_NODE,		/* LDP IPv6 Interface */
+  LDP_L2VPN_NODE,		/* LDP L2VPN node */
+  LDP_PSEUDOWIRE_NODE,		/* LDP Pseudowire node */
   ISIS_NODE,			/* ISIS protocol mode */
   PIM_NODE,			/* PIM protocol mode */
   MASC_NODE,			/* MASC for multicast.  */
@@ -107,6 +114,7 @@ enum node_type
   DUMP_NODE,			/* Packet dump node. */
   FORWARDING_NODE,		/* IP forwarding node. */
   PROTOCOL_NODE,                /* protocol filtering node */
+  MPLS_NODE,                    /* MPLS config node */
   VTY_NODE,			/* Vty node. */
 };
 
@@ -505,6 +513,8 @@ struct cmd_token
 "(neighbor|interface|area|lsa|zebra|config|dbex|spf|route|lsdb|redistribute|hook|asbr|prefix|abr)"
 #define ISIS_STR "IS-IS information\n"
 #define AREA_TAG_STR "[area tag]\n"
+#define MPLS_STR "MPLS information\n"
+
 
 #define CONF_BACKUP_EXT ".sav"
 
diff --git a/lib/imsg-buffer.c b/lib/imsg-buffer.c
new file mode 100644
index 0000000..a486fc1
--- /dev/null
+++ b/lib/imsg-buffer.c
@@ -0,0 +1,301 @@
+/*	$OpenBSD$	*/
+
+/*
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "openbsd-queue.h"
+#include "imsg.h"
+
+int	ibuf_realloc(struct ibuf *, size_t);
+void	ibuf_enqueue(struct msgbuf *, struct ibuf *);
+void	ibuf_dequeue(struct msgbuf *, struct ibuf *);
+
+struct ibuf *
+ibuf_open(size_t len)
+{
+	struct ibuf	*buf;
+
+	if ((buf = calloc(1, sizeof(struct ibuf))) == NULL)
+		return (NULL);
+	if ((buf->buf = malloc(len)) == NULL) {
+		free(buf);
+		return (NULL);
+	}
+	buf->size = buf->max = len;
+	buf->fd = -1;
+
+	return (buf);
+}
+
+struct ibuf *
+ibuf_dynamic(size_t len, size_t max)
+{
+	struct ibuf	*buf;
+
+	if (max < len)
+		return (NULL);
+
+	if ((buf = ibuf_open(len)) == NULL)
+		return (NULL);
+
+	if (max > 0)
+		buf->max = max;
+
+	return (buf);
+}
+
+int
+ibuf_realloc(struct ibuf *buf, size_t len)
+{
+	u_char	*b;
+
+	/* on static buffers max is eq size and so the following fails */
+	if (buf->wpos + len > buf->max) {
+		errno = ERANGE;
+		return (-1);
+	}
+
+	b = realloc(buf->buf, buf->wpos + len);
+	if (b == NULL)
+		return (-1);
+	buf->buf = b;
+	buf->size = buf->wpos + len;
+
+	return (0);
+}
+
+int
+ibuf_add(struct ibuf *buf, const void *data, size_t len)
+{
+	if (buf->wpos + len > buf->size)
+		if (ibuf_realloc(buf, len) == -1)
+			return (-1);
+
+	memcpy(buf->buf + buf->wpos, data, len);
+	buf->wpos += len;
+	return (0);
+}
+
+void *
+ibuf_reserve(struct ibuf *buf, size_t len)
+{
+	void	*b;
+
+	if (buf->wpos + len > buf->size)
+		if (ibuf_realloc(buf, len) == -1)
+			return (NULL);
+
+	b = buf->buf + buf->wpos;
+	buf->wpos += len;
+	return (b);
+}
+
+void *
+ibuf_seek(struct ibuf *buf, size_t pos, size_t len)
+{
+	/* only allowed to seek in already written parts */
+	if (pos + len > buf->wpos)
+		return (NULL);
+
+	return (buf->buf + pos);
+}
+
+size_t
+ibuf_size(struct ibuf *buf)
+{
+	return (buf->wpos);
+}
+
+size_t
+ibuf_left(struct ibuf *buf)
+{
+	return (buf->max - buf->wpos);
+}
+
+void
+ibuf_close(struct msgbuf *msgbuf, struct ibuf *buf)
+{
+	ibuf_enqueue(msgbuf, buf);
+}
+
+int
+ibuf_write(struct msgbuf *msgbuf)
+{
+	struct iovec	 iov[IOV_MAX];
+	struct ibuf	*buf;
+	unsigned int	 i = 0;
+	ssize_t	n;
+
+	memset(&iov, 0, sizeof(iov));
+	TAILQ_FOREACH(buf, &msgbuf->bufs, entry) {
+		if (i >= IOV_MAX)
+			break;
+		iov[i].iov_base = buf->buf + buf->rpos;
+		iov[i].iov_len = buf->wpos - buf->rpos;
+		i++;
+	}
+
+again:
+	if ((n = writev(msgbuf->fd, iov, i)) == -1) {
+		if (errno == EINTR)
+			goto again;
+		if (errno == ENOBUFS)
+			errno = EAGAIN;
+		return (-1);
+	}
+
+	if (n == 0) {			/* connection closed */
+		errno = 0;
+		return (0);
+	}
+
+	msgbuf_drain(msgbuf, n);
+
+	return (1);
+}
+
+void
+ibuf_free(struct ibuf *buf)
+{
+	if (buf == NULL)
+		return;
+	free(buf->buf);
+	free(buf);
+}
+
+void
+msgbuf_init(struct msgbuf *msgbuf)
+{
+	msgbuf->queued = 0;
+	msgbuf->fd = -1;
+	TAILQ_INIT(&msgbuf->bufs);
+}
+
+void
+msgbuf_drain(struct msgbuf *msgbuf, size_t n)
+{
+	struct ibuf	*buf, *next;
+
+	for (buf = TAILQ_FIRST(&msgbuf->bufs); buf != NULL && n > 0;
+	    buf = next) {
+		next = TAILQ_NEXT(buf, entry);
+		if (buf->rpos + n >= buf->wpos) {
+			n -= buf->wpos - buf->rpos;
+			ibuf_dequeue(msgbuf, buf);
+		} else {
+			buf->rpos += n;
+			n = 0;
+		}
+	}
+}
+
+void
+msgbuf_clear(struct msgbuf *msgbuf)
+{
+	struct ibuf	*buf;
+
+	while ((buf = TAILQ_FIRST(&msgbuf->bufs)) != NULL)
+		ibuf_dequeue(msgbuf, buf);
+}
+
+int
+msgbuf_write(struct msgbuf *msgbuf)
+{
+	struct iovec	 iov[IOV_MAX];
+	struct ibuf	*buf;
+	unsigned int	 i = 0;
+	ssize_t		 n;
+	struct msghdr	 msg;
+	struct cmsghdr	*cmsg;
+	union {
+		struct cmsghdr	hdr;
+		char		buf[CMSG_SPACE(sizeof(int))];
+	} cmsgbuf;
+
+	memset(&iov, 0, sizeof(iov));
+	memset(&msg, 0, sizeof(msg));
+	memset(&cmsgbuf, 0, sizeof(cmsgbuf));
+	TAILQ_FOREACH(buf, &msgbuf->bufs, entry) {
+		if (i >= IOV_MAX)
+			break;
+		iov[i].iov_base = buf->buf + buf->rpos;
+		iov[i].iov_len = buf->wpos - buf->rpos;
+		i++;
+		if (buf->fd != -1)
+			break;
+	}
+
+	msg.msg_iov = iov;
+	msg.msg_iovlen = i;
+
+	if (buf != NULL && buf->fd != -1) {
+		msg.msg_control = (caddr_t)&cmsgbuf.buf;
+		msg.msg_controllen = sizeof(cmsgbuf.buf);
+		cmsg = CMSG_FIRSTHDR(&msg);
+		cmsg->cmsg_len = CMSG_LEN(sizeof(int));
+		cmsg->cmsg_level = SOL_SOCKET;
+		cmsg->cmsg_type = SCM_RIGHTS;
+		memcpy(CMSG_DATA(cmsg), &buf->fd, sizeof(int));
+	}
+
+again:
+	if ((n = sendmsg(msgbuf->fd, &msg, 0)) == -1) {
+		if (errno == EINTR)
+			goto again;
+		if (errno == ENOBUFS)
+			errno = EAGAIN;
+		return (-1);
+	}
+
+	if (n == 0) {			/* connection closed */
+		errno = 0;
+		return (0);
+	}
+
+	/*
+	 * assumption: fd got sent if sendmsg sent anything
+	 * this works because fds are passed one at a time
+	 */
+	if (buf != NULL && buf->fd != -1) {
+		close(buf->fd);
+		buf->fd = -1;
+	}
+
+	msgbuf_drain(msgbuf, n);
+
+	return (1);
+}
+
+void
+ibuf_enqueue(struct msgbuf *msgbuf, struct ibuf *buf)
+{
+	TAILQ_INSERT_TAIL(&msgbuf->bufs, buf, entry);
+	msgbuf->queued++;
+}
+
+void
+ibuf_dequeue(struct msgbuf *msgbuf, struct ibuf *buf)
+{
+	TAILQ_REMOVE(&msgbuf->bufs, buf, entry);
+
+	if (buf->fd != -1)
+		close(buf->fd);
+
+	msgbuf->queued--;
+	ibuf_free(buf);
+}
diff --git a/lib/imsg.c b/lib/imsg.c
new file mode 100644
index 0000000..246430c
--- /dev/null
+++ b/lib/imsg.c
@@ -0,0 +1,334 @@
+/*	$OpenBSD$	*/
+
+/*
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <zebra.h>
+
+#include "openbsd-queue.h"
+#include "imsg.h"
+
+int	 imsg_fd_overhead = 0;
+
+int	 imsg_get_fd(struct imsgbuf *);
+
+#ifndef __OpenBSD__
+/*
+ * The original code calls getdtablecount() which is OpenBSD specific. Use
+ * available_fds() from OpenSMTPD instead.
+ */
+static int
+available_fds(unsigned int n)
+{
+	unsigned int	i;
+	int		ret, fds[256];
+
+	if (n > (sizeof(fds)/sizeof(fds[0])))
+		return (1);
+
+	ret = 0;
+	for (i = 0; i < n; i++) {
+		fds[i] = -1;
+		if ((fds[i] = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+			if (errno == EAFNOSUPPORT || errno == EPROTONOSUPPORT)
+				fds[i] = socket(AF_INET6, SOCK_DGRAM, 0);
+			if (fds[i] < 0) {
+				ret = 1;
+				break;
+			}
+		}
+	}
+
+	for (i = 0; i < n && fds[i] >= 0; i++)
+		close(fds[i]);
+
+	return (ret);
+}
+#endif
+
+void
+imsg_init(struct imsgbuf *ibuf, int fd)
+{
+	msgbuf_init(&ibuf->w);
+	memset(&ibuf->r, 0, sizeof(ibuf->r));
+	ibuf->fd = fd;
+	ibuf->w.fd = fd;
+	ibuf->pid = getpid();
+	TAILQ_INIT(&ibuf->fds);
+}
+
+ssize_t
+imsg_read(struct imsgbuf *ibuf)
+{
+	struct msghdr		 msg;
+	struct cmsghdr		*cmsg;
+	union {
+		struct cmsghdr hdr;
+		char	buf[CMSG_SPACE(sizeof(int) * 1)];
+	} cmsgbuf;
+	struct iovec		 iov;
+	ssize_t			 n = -1;
+	int			 fd;
+	struct imsg_fd		*ifd;
+
+	memset(&msg, 0, sizeof(msg));
+	memset(&cmsgbuf, 0, sizeof(cmsgbuf));
+
+	iov.iov_base = ibuf->r.buf + ibuf->r.wpos;
+	iov.iov_len = sizeof(ibuf->r.buf) - ibuf->r.wpos;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = &cmsgbuf.buf;
+	msg.msg_controllen = sizeof(cmsgbuf.buf);
+
+	if ((ifd = calloc(1, sizeof(struct imsg_fd))) == NULL)
+		return (-1);
+
+again:
+#ifdef __OpenBSD__
+	if (getdtablecount() + imsg_fd_overhead +
+	    (int)((CMSG_SPACE(sizeof(int))-CMSG_SPACE(0))/sizeof(int))
+	    >= getdtablesize()) {
+#else
+	if (available_fds(imsg_fd_overhead +
+	    (CMSG_SPACE(sizeof(int))-CMSG_SPACE(0))/sizeof(int))) {
+#endif
+		errno = EAGAIN;
+		free(ifd);
+		return (-1);
+	}
+
+	if ((n = recvmsg(ibuf->fd, &msg, 0)) == -1) {
+		if (errno == EINTR)
+			goto again;
+		goto fail;
+	}
+
+	ibuf->r.wpos += n;
+
+	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
+	    cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+		if (cmsg->cmsg_level == SOL_SOCKET &&
+		    cmsg->cmsg_type == SCM_RIGHTS) {
+			int i;
+			int j;
+
+			/*
+			 * We only accept one file descriptor.  Due to C
+			 * padding rules, our control buffer might contain
+			 * more than one fd, and we must close them.
+			 */
+			j = ((char *)cmsg + cmsg->cmsg_len -
+			    (char *)CMSG_DATA(cmsg)) / sizeof(int);
+			for (i = 0; i < j; i++) {
+				fd = ((int *)CMSG_DATA(cmsg))[i];
+				if (ifd != NULL) {
+					ifd->fd = fd;
+					TAILQ_INSERT_TAIL(&ibuf->fds, ifd,
+					    entry);
+					ifd = NULL;
+				} else
+					close(fd);
+			}
+		}
+		/* we do not handle other ctl data level */
+	}
+
+fail:
+	free(ifd);
+	return (n);
+}
+
+ssize_t
+imsg_get(struct imsgbuf *ibuf, struct imsg *imsg)
+{
+	size_t			 av, left, datalen;
+
+	av = ibuf->r.wpos;
+
+	if (IMSG_HEADER_SIZE > av)
+		return (0);
+
+	memcpy(&imsg->hdr, ibuf->r.buf, sizeof(imsg->hdr));
+	if (imsg->hdr.len < IMSG_HEADER_SIZE ||
+	    imsg->hdr.len > MAX_IMSGSIZE) {
+		errno = ERANGE;
+		return (-1);
+	}
+	if (imsg->hdr.len > av)
+		return (0);
+	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;
+	ibuf->r.rptr = ibuf->r.buf + IMSG_HEADER_SIZE;
+	if (datalen == 0)
+		imsg->data = NULL;
+	else if ((imsg->data = malloc(datalen)) == NULL)
+		return (-1);
+
+	if (imsg->hdr.flags & IMSGF_HASFD)
+		imsg->fd = imsg_get_fd(ibuf);
+	else
+		imsg->fd = -1;
+
+	memcpy(imsg->data, ibuf->r.rptr, datalen);
+
+	if (imsg->hdr.len < av) {
+		left = av - imsg->hdr.len;
+		memmove(&ibuf->r.buf, ibuf->r.buf + imsg->hdr.len, left);
+		ibuf->r.wpos = left;
+	} else
+		ibuf->r.wpos = 0;
+
+	return (datalen + IMSG_HEADER_SIZE);
+}
+
+int
+imsg_compose(struct imsgbuf *ibuf, u_int32_t type, u_int32_t peerid,
+    pid_t pid, int fd, const void *data, u_int16_t datalen)
+{
+	struct ibuf	*wbuf;
+
+	if ((wbuf = imsg_create(ibuf, type, peerid, pid, datalen)) == NULL)
+		return (-1);
+
+	if (imsg_add(wbuf, data, datalen) == -1)
+		return (-1);
+
+	wbuf->fd = fd;
+
+	imsg_close(ibuf, wbuf);
+
+	return (1);
+}
+
+int
+imsg_composev(struct imsgbuf *ibuf, u_int32_t type, u_int32_t peerid,
+    pid_t pid, int fd, const struct iovec *iov, int iovcnt)
+{
+	struct ibuf	*wbuf;
+	int		 i, datalen = 0;
+
+	for (i = 0; i < iovcnt; i++)
+		datalen += iov[i].iov_len;
+
+	if ((wbuf = imsg_create(ibuf, type, peerid, pid, datalen)) == NULL)
+		return (-1);
+
+	for (i = 0; i < iovcnt; i++)
+		if (imsg_add(wbuf, iov[i].iov_base, iov[i].iov_len) == -1)
+			return (-1);
+
+	wbuf->fd = fd;
+
+	imsg_close(ibuf, wbuf);
+
+	return (1);
+}
+
+/* ARGSUSED */
+struct ibuf *
+imsg_create(struct imsgbuf *ibuf, u_int32_t type, u_int32_t peerid,
+    pid_t pid, u_int16_t datalen)
+{
+	struct ibuf	*wbuf;
+	struct imsg_hdr	 hdr;
+
+	datalen += IMSG_HEADER_SIZE;
+	if (datalen > MAX_IMSGSIZE) {
+		errno = ERANGE;
+		return (NULL);
+	}
+
+	hdr.type = type;
+	hdr.flags = 0;
+	hdr.peerid = peerid;
+	if ((hdr.pid = pid) == 0)
+		hdr.pid = ibuf->pid;
+	if ((wbuf = ibuf_dynamic(datalen, MAX_IMSGSIZE)) == NULL) {
+		return (NULL);
+	}
+	if (imsg_add(wbuf, &hdr, sizeof(hdr)) == -1)
+		return (NULL);
+
+	return (wbuf);
+}
+
+int
+imsg_add(struct ibuf *msg, const void *data, u_int16_t datalen)
+{
+	if (datalen)
+		if (ibuf_add(msg, data, datalen) == -1) {
+			ibuf_free(msg);
+			return (-1);
+		}
+	return (datalen);
+}
+
+void
+imsg_close(struct imsgbuf *ibuf, struct ibuf *msg)
+{
+	struct imsg_hdr	*hdr;
+
+	hdr = (struct imsg_hdr *)msg->buf;
+
+	hdr->flags &= ~IMSGF_HASFD;
+	if (msg->fd != -1)
+		hdr->flags |= IMSGF_HASFD;
+
+	hdr->len = (u_int16_t)msg->wpos;
+
+	ibuf_close(&ibuf->w, msg);
+}
+
+void
+imsg_free(struct imsg *imsg)
+{
+	free(imsg->data);
+}
+
+int
+imsg_get_fd(struct imsgbuf *ibuf)
+{
+	int		 fd;
+	struct imsg_fd	*ifd;
+
+	if ((ifd = TAILQ_FIRST(&ibuf->fds)) == NULL)
+		return (-1);
+
+	fd = ifd->fd;
+	TAILQ_REMOVE(&ibuf->fds, ifd, entry);
+	free(ifd);
+
+	return (fd);
+}
+
+int
+imsg_flush(struct imsgbuf *ibuf)
+{
+	while (ibuf->w.queued)
+		if (msgbuf_write(&ibuf->w) <= 0)
+			return (-1);
+	return (0);
+}
+
+void
+imsg_clear(struct imsgbuf *ibuf)
+{
+	int	fd;
+
+	msgbuf_clear(&ibuf->w);
+	while ((fd = imsg_get_fd(ibuf)) != -1)
+		close(fd);
+}
diff --git a/lib/imsg.h b/lib/imsg.h
new file mode 100644
index 0000000..d053d01
--- /dev/null
+++ b/lib/imsg.h
@@ -0,0 +1,112 @@
+/*	$OpenBSD$	*/
+
+/*
+ * Copyright (c) 2006, 2007 Pierre-Yves Ritschard <pyr@openbsd.org>
+ * Copyright (c) 2006, 2007, 2008 Reyk Floeter <reyk@openbsd.org>
+ * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _IMSG_H_
+#define _IMSG_H_
+
+#define IBUF_READ_SIZE		65535
+#define IMSG_HEADER_SIZE	sizeof(struct imsg_hdr)
+#define MAX_IMSGSIZE		16384
+
+struct ibuf {
+	TAILQ_ENTRY(ibuf)	 entry;
+	u_char			*buf;
+	size_t			 size;
+	size_t			 max;
+	size_t			 wpos;
+	size_t			 rpos;
+	int			 fd;
+};
+
+struct msgbuf {
+	TAILQ_HEAD(, ibuf)	 bufs;
+	u_int32_t		 queued;
+	int			 fd;
+};
+
+struct ibuf_read {
+	u_char			 buf[IBUF_READ_SIZE];
+	u_char			*rptr;
+	size_t			 wpos;
+};
+
+struct imsg_fd {
+	TAILQ_ENTRY(imsg_fd)	entry;
+	int			fd;
+};
+
+struct imsgbuf {
+	TAILQ_HEAD(, imsg_fd)	 fds;
+	struct ibuf_read	 r;
+	struct msgbuf		 w;
+	int			 fd;
+	pid_t			 pid;
+};
+
+#define IMSGF_HASFD	1
+
+struct imsg_hdr {
+	u_int32_t	 type;
+	u_int16_t	 len;
+	u_int16_t	 flags;
+	u_int32_t	 peerid;
+	u_int32_t	 pid;
+};
+
+struct imsg {
+	struct imsg_hdr	 hdr;
+	int		 fd;
+	void		*data;
+};
+
+
+/* buffer.c */
+struct ibuf	*ibuf_open(size_t);
+struct ibuf	*ibuf_dynamic(size_t, size_t);
+int		 ibuf_add(struct ibuf *, const void *, size_t);
+void		*ibuf_reserve(struct ibuf *, size_t);
+void		*ibuf_seek(struct ibuf *, size_t, size_t);
+size_t		 ibuf_size(struct ibuf *);
+size_t		 ibuf_left(struct ibuf *);
+void		 ibuf_close(struct msgbuf *, struct ibuf *);
+int		 ibuf_write(struct msgbuf *);
+void		 ibuf_free(struct ibuf *);
+void		 msgbuf_init(struct msgbuf *);
+void		 msgbuf_clear(struct msgbuf *);
+int		 msgbuf_write(struct msgbuf *);
+void		 msgbuf_drain(struct msgbuf *, size_t);
+
+/* imsg.c */
+void	 imsg_init(struct imsgbuf *, int);
+ssize_t	 imsg_read(struct imsgbuf *);
+ssize_t	 imsg_get(struct imsgbuf *, struct imsg *);
+int	 imsg_compose(struct imsgbuf *, u_int32_t, u_int32_t, pid_t,
+	    int, const void *, u_int16_t);
+int	 imsg_composev(struct imsgbuf *, u_int32_t, u_int32_t,  pid_t,
+	    int, const struct iovec *, int);
+struct ibuf *imsg_create(struct imsgbuf *, u_int32_t, u_int32_t, pid_t,
+	    u_int16_t);
+int	 imsg_add(struct ibuf *, const void *, u_int16_t);
+void	 imsg_close(struct imsgbuf *, struct ibuf *);
+void	 imsg_free(struct imsg *);
+int	 imsg_flush(struct imsgbuf *);
+void	 imsg_clear(struct imsgbuf *);
+
+#endif
diff --git a/lib/log.c b/lib/log.c
index 0914bf8..fa55103 100644
--- a/lib/log.c
+++ b/lib/log.c
@@ -50,6 +50,7 @@ const char *zlog_proto_names[] =
   "RIPNG",
   "BABEL",
   "OSPF6",
+  "LDP",
   "ISIS",
   "PIM",
   "MASC",
@@ -148,7 +149,7 @@ time_print(FILE *fp, struct timestamp_control *ctl)
   
 
 /* va_list version of zlog. */
-static void
+void
 vzlog (struct zlog *zl, int priority, const char *format, va_list args)
 {
   int original_errno = errno;
@@ -979,6 +980,8 @@ proto_redistnum(int afi, const char *s)
 	return ZEBRA_ROUTE_OSPF;
       else if (strncmp (s, "i", 1) == 0)
 	return ZEBRA_ROUTE_ISIS;
+      else if (strncmp (s, "l", 1) == 0)
+	return ZEBRA_ROUTE_LDP;
       else if (strncmp (s, "bg", 2) == 0)
 	return ZEBRA_ROUTE_BGP;
       else if (strncmp (s, "ba", 2) == 0)
@@ -998,6 +1001,8 @@ proto_redistnum(int afi, const char *s)
 	return ZEBRA_ROUTE_OSPF6;
       else if (strncmp (s, "i", 1) == 0)
 	return ZEBRA_ROUTE_ISIS;
+      else if (strncmp (s, "l", 1) == 0)
+	return ZEBRA_ROUTE_LDP;
       else if (strncmp (s, "bg", 2) == 0)
 	return ZEBRA_ROUTE_BGP;
       else if (strncmp (s, "ba", 2) == 0)
diff --git a/lib/log.h b/lib/log.h
index 514884c..faf567c 100644
--- a/lib/log.h
+++ b/lib/log.h
@@ -52,6 +52,7 @@ typedef enum
   ZLOG_RIPNG,
   ZLOG_BABEL,
   ZLOG_OSPF6,
+  ZLOG_LDP,
   ZLOG_ISIS,
   ZLOG_PIM,
   ZLOG_MASC
@@ -115,6 +116,7 @@ extern void zlog (struct zlog *zl, int priority, const char *format, ...)
   PRINTF_ATTRIBUTE(3, 4);
 
 /* Handy zlog functions. */
+extern void vzlog (struct zlog *zl, int priority, const char *format, va_list args);
 extern void zlog_err (const char *format, ...) PRINTF_ATTRIBUTE(1, 2);
 extern void zlog_warn (const char *format, ...) PRINTF_ATTRIBUTE(1, 2);
 extern void zlog_info (const char *format, ...) PRINTF_ATTRIBUTE(1, 2);
diff --git a/lib/memtypes.c b/lib/memtypes.c
index 6df1448..24ab30d 100644
--- a/lib/memtypes.c
+++ b/lib/memtypes.c
@@ -86,6 +86,11 @@ struct memory_list memory_list_zebra[] =
   { MTYPE_RIB_DEST,		"RIB destination"		},
   { MTYPE_RIB_TABLE_INFO,	"RIB table info"		},
   { MTYPE_NETLINK_NAME,	"Netlink name"			},
+  { MTYPE_SLSP,                 "MPLS static LSP config"        },
+  { MTYPE_LSP,                  "MPLS LSP object"               },
+  { MTYPE_SNHLFE,               "MPLS static nexthop object"    },
+  { MTYPE_NHLFE,                "MPLS nexthop object"           },
+  { MTYPE_NH_LABEL,             "Nexthop label"                 },
   { -1, NULL },
 };
 
diff --git a/lib/mpls.h b/lib/mpls.h
new file mode 100644
index 0000000..bbe29ad
--- /dev/null
+++ b/lib/mpls.h
@@ -0,0 +1,195 @@
+/*
+ * MPLS definitions
+ * Copyright 2015 Cumulus Networks, Inc.
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2, or (at your
+ * option) any later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _QUAGGA_MPLS_H
+#define _QUAGGA_MPLS_H
+
+/* Well-known MPLS label values (RFC 3032 etc). */
+#define MPLS_V4_EXP_NULL_LABEL             0
+#define MPLS_RA_LABEL                      1
+#define MPLS_V6_EXP_NULL_LABEL             2
+#define MPLS_IMP_NULL_LABEL                3
+#define MPLS_ENTROPY_LABEL_INDICATOR       7
+#define MPLS_GAL_LABEL                     13
+#define MPLS_OAM_ALERT_LABEL               14
+#define MPLS_EXTENSION_LABEL               15
+
+/* Minimum and maximum label values */
+#define MPLS_MIN_RESERVED_LABEL            0
+#define MPLS_MAX_RESERVED_LABEL            15
+#define MPLS_MIN_UNRESERVED_LABEL          16
+#define MPLS_MAX_UNRESERVED_LABEL          1048575
+
+#define IS_MPLS_RESERVED_LABEL(label) \
+        (label >= MPLS_MIN_RESERVED_LABEL && label <= MPLS_MAX_RESERVED_LABEL)
+
+#define IS_MPLS_UNRESERVED_LABEL(label) \
+        (label >= MPLS_MIN_UNRESERVED_LABEL && label <= MPLS_MAX_UNRESERVED_LABEL)
+
+/* Definitions for a MPLS label stack entry (RFC 3032). This encodes the
+ * label, EXP, BOS and TTL fields.
+ */
+typedef unsigned int mpls_lse_t;
+
+#define MPLS_LS_LABEL_MASK             0xFFFFF000
+#define MPLS_LS_LABEL_SHIFT            12
+#define MPLS_LS_EXP_MASK               0x00000E00
+#define MPLS_LS_EXP_SHIFT              9
+#define MPLS_LS_S_MASK                 0x00000100
+#define MPLS_LS_S_SHIFT                8
+#define MPLS_LS_TTL_MASK               0x000000FF
+#define MPLS_LS_TTL_SHIFT              0
+
+#define MPLS_LABEL_VALUE(lse) \
+        ((lse & MPLS_LS_LABEL_MASK) >> MPLS_LS_LABEL_SHIFT)
+#define MPLS_LABEL_EXP(lse) \
+        ((lse & MPLS_LS_EXP_MASK) >> MPLS_LS_EXP_SHIFT)
+#define MPLS_LABEL_BOS(lse) \
+        ((lse & MPLS_LS_S_MASK) >> MPLS_LS_S_SHIFT)
+#define MPLS_LABEL_TTL(lse) \
+        ((lse & MPLS_LS_TTL_MASK) >> MPLS_LS_TTL_SHIFT)
+
+#define IS_MPLS_LABEL_BOS(ls)          (MPLS_LABEL_BOS(ls) == 1)
+
+#define MPLS_LABEL_LEN_BITS            20
+
+/* MPLS label value as a 32-bit (mostly we only care about the label value). */
+typedef unsigned int mpls_label_t;
+
+#define MPLS_NO_LABEL                      0xFFFFFFFF
+#define MPLS_INVALID_LABEL                 0xFFFFFFFF
+
+/* LSP types. */
+enum lsp_types_t
+{
+  ZEBRA_LSP_INVALID = 0,     /* Invalid. */
+  ZEBRA_LSP_STATIC = 1,      /* Static LSP. */
+  ZEBRA_LSP_LDP = 2          /* LDP LSP. */
+};
+
+/* TODO - Temporary definitions, need to refine. */
+#ifndef AF_MPLS
+#define AF_MPLS 28
+#endif
+
+/* Functions for basic label operations. */
+
+/* Encode a label stack entry from fields; convert to network byte-order as
+ * the Netlink interface expects MPLS labels to be in this format.
+ */
+static inline mpls_lse_t
+mpls_lse_encode (mpls_label_t label, u_int32_t ttl,
+                 u_int32_t exp, u_int32_t bos)
+{
+  mpls_lse_t lse;
+  lse = htonl ((label << MPLS_LS_LABEL_SHIFT) |
+               (exp << MPLS_LS_EXP_SHIFT) |
+               (bos ? (1 << MPLS_LS_S_SHIFT) : 0) |
+               (ttl << MPLS_LS_TTL_SHIFT));
+  return lse;
+}
+
+/* Extract the fields from a label stack entry after converting to host-byte
+ * order. This is expected to be called only for messages received over the
+ * Netlink interface.
+ */
+static inline void
+mpls_lse_decode (mpls_lse_t lse, mpls_label_t *label,
+                 u_int32_t *ttl, u_int32_t *exp, u_int32_t *bos)
+{
+  mpls_lse_t local_lse;
+
+  local_lse = ntohl (lse);
+  *label = MPLS_LABEL_VALUE(local_lse);
+  *exp = MPLS_LABEL_EXP(local_lse);
+  *bos = MPLS_LABEL_BOS(local_lse);
+  *ttl = MPLS_LABEL_TTL(local_lse);
+}
+
+
+/* Printable string for labels (with consideration for reserved values). */
+static inline char *
+label2str (mpls_label_t label, char *buf, int len)
+{
+  switch(label) {
+  case MPLS_V4_EXP_NULL_LABEL:
+    strncpy(buf, "IPv4 Explicit Null", len);
+    return(buf);
+    break;
+  case MPLS_RA_LABEL:
+    strncpy(buf, "Router Alert", len);
+    return(buf);
+    break;
+  case MPLS_V6_EXP_NULL_LABEL:
+    strncpy(buf, "IPv6 Explict Null", len);
+    return(buf);
+    break;
+  case MPLS_IMP_NULL_LABEL:
+    strncpy(buf, "implicit-null", len);
+    return(buf);
+    break;
+  case MPLS_ENTROPY_LABEL_INDICATOR:
+    strncpy(buf, "Entropy Label Indicator", len);
+    return(buf);
+    break;
+  case MPLS_GAL_LABEL:
+    strncpy(buf, "Generic Associated Channel", len);
+    return(buf);
+    break;
+  case MPLS_OAM_ALERT_LABEL:
+    strncpy(buf, "OAM Alert", len);
+    return(buf);
+    break;
+  case MPLS_EXTENSION_LABEL:
+    strncpy(buf, "Extension", len);
+    return(buf);
+    break;
+  case 4:
+  case 5:
+  case 6:
+  case 8:
+  case 9:
+  case 10:
+  case 11:
+  case 12:
+    strncpy(buf, "Reserved", len);
+    return(buf);
+    break;
+  default:
+    sprintf(buf, "%u", label);
+    return(buf);
+  }
+
+  strncpy(buf, "Error", len);
+  return(buf);
+}
+
+/* constants used by ldpd */
+#define MPLS_LABEL_IPV4NULL	0               /* IPv4 Explicit NULL Label */
+#define MPLS_LABEL_RTALERT	1               /* Router Alert Label       */
+#define MPLS_LABEL_IPV6NULL	2               /* IPv6 Explicit NULL Label */
+#define MPLS_LABEL_IMPLNULL	3               /* Implicit NULL Label      */
+/*      MPLS_LABEL_RESERVED	4-15 */		/* Values 4-15 are reserved */
+#define MPLS_LABEL_RESERVED_MAX 15
+#define MPLS_LABEL_MAX		((1 << 20) - 1)
+
+#endif
diff --git a/lib/openbsd-queue.h b/lib/openbsd-queue.h
new file mode 100644
index 0000000..5e81fdd
--- /dev/null
+++ b/lib/openbsd-queue.h
@@ -0,0 +1,533 @@
+/*	$OpenBSD: queue.h,v 1.43 2015/12/28 19:38:40 millert Exp $	*/
+/*	$NetBSD: queue.h,v 1.11 1996/05/16 05:17:14 mycroft Exp $	*/
+
+/*
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)queue.h	8.5 (Berkeley) 8/20/94
+ */
+
+#ifndef	_SYS_QUEUE_H_
+#define	_SYS_QUEUE_H_
+
+/*
+ * This file defines five types of data structures: singly-linked lists,
+ * lists, simple queues, tail queues and XOR simple queues.
+ *
+ *
+ * A singly-linked list is headed by a single forward pointer. The elements
+ * are singly linked for minimum space and pointer manipulation overhead at
+ * the expense of O(n) removal for arbitrary elements. New elements can be
+ * added to the list after an existing element or at the head of the list.
+ * Elements being removed from the head of the list should use the explicit
+ * macro for this purpose for optimum efficiency. A singly-linked list may
+ * only be traversed in the forward direction.  Singly-linked lists are ideal
+ * for applications with large datasets and few or no removals or for
+ * implementing a LIFO queue.
+ *
+ * A list is headed by a single forward pointer (or an array of forward
+ * pointers for a hash table header). The elements are doubly linked
+ * so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before
+ * or after an existing element or at the head of the list. A list
+ * may only be traversed in the forward direction.
+ *
+ * A simple queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are singly
+ * linked to save space, so elements can only be removed from the
+ * head of the list. New elements can be added to the list before or after
+ * an existing element, at the head of the list, or at the end of the
+ * list. A simple queue may only be traversed in the forward direction.
+ *
+ * A tail queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are doubly
+ * linked so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before or
+ * after an existing element, at the head of the list, or at the end of
+ * the list. A tail queue may be traversed in either direction.
+ *
+ * An XOR simple queue is used in the same way as a regular simple queue.
+ * The difference is that the head structure also includes a "cookie" that
+ * is XOR'd with the queue pointer (first, last or next) to generate the
+ * real pointer value.
+ *
+ * For details on the use of these macros, see the queue(3) manual page.
+ */
+
+#if defined(QUEUE_MACRO_DEBUG) || (defined(_KERNEL) && defined(DIAGNOSTIC))
+#define _Q_INVALIDATE(a) (a) = ((void *)-1)
+#else
+#define _Q_INVALIDATE(a)
+#endif
+
+/*
+ * Singly-linked List definitions.
+ */
+#define SLIST_HEAD(name, type)						\
+struct name {								\
+	struct type *slh_first;	/* first element */			\
+}
+
+#define	SLIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define SLIST_ENTRY(type)						\
+struct {								\
+	struct type *sle_next;	/* next element */			\
+}
+
+/*
+ * Singly-linked List access methods.
+ */
+#define	SLIST_FIRST(head)	((head)->slh_first)
+#define	SLIST_END(head)		NULL
+#define	SLIST_EMPTY(head)	(SLIST_FIRST(head) == SLIST_END(head))
+#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
+
+#define	SLIST_FOREACH(var, head, field)					\
+	for((var) = SLIST_FIRST(head);					\
+	    (var) != SLIST_END(head);					\
+	    (var) = SLIST_NEXT(var, field))
+
+#define	SLIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = SLIST_FIRST(head);				\
+	    (var) && ((tvar) = SLIST_NEXT(var, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Singly-linked List functions.
+ */
+#define	SLIST_INIT(head) {						\
+	SLIST_FIRST(head) = SLIST_END(head);				\
+}
+
+#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
+	(elm)->field.sle_next = (slistelm)->field.sle_next;		\
+	(slistelm)->field.sle_next = (elm);				\
+} while (0)
+
+#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
+	(elm)->field.sle_next = (head)->slh_first;			\
+	(head)->slh_first = (elm);					\
+} while (0)
+
+#define	SLIST_REMOVE_AFTER(elm, field) do {				\
+	(elm)->field.sle_next = (elm)->field.sle_next->field.sle_next;	\
+} while (0)
+
+#define	SLIST_REMOVE_HEAD(head, field) do {				\
+	(head)->slh_first = (head)->slh_first->field.sle_next;		\
+} while (0)
+
+#define SLIST_REMOVE(head, elm, type, field) do {			\
+	if ((head)->slh_first == (elm)) {				\
+		SLIST_REMOVE_HEAD((head), field);			\
+	} else {							\
+		struct type *curelm = (head)->slh_first;		\
+									\
+		while (curelm->field.sle_next != (elm))			\
+			curelm = curelm->field.sle_next;		\
+		curelm->field.sle_next =				\
+		    curelm->field.sle_next->field.sle_next;		\
+	}								\
+	_Q_INVALIDATE((elm)->field.sle_next);				\
+} while (0)
+
+/*
+ * List definitions.
+ */
+#define LIST_HEAD(name, type)						\
+struct name {								\
+	struct type *lh_first;	/* first element */			\
+}
+
+#define LIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define LIST_ENTRY(type)						\
+struct {								\
+	struct type *le_next;	/* next element */			\
+	struct type **le_prev;	/* address of previous next element */	\
+}
+
+/*
+ * List access methods.
+ */
+#define	LIST_FIRST(head)		((head)->lh_first)
+#define	LIST_END(head)			NULL
+#define	LIST_EMPTY(head)		(LIST_FIRST(head) == LIST_END(head))
+#define	LIST_NEXT(elm, field)		((elm)->field.le_next)
+
+#define LIST_FOREACH(var, head, field)					\
+	for((var) = LIST_FIRST(head);					\
+	    (var)!= LIST_END(head);					\
+	    (var) = LIST_NEXT(var, field))
+
+#define	LIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = LIST_FIRST(head);				\
+	    (var) && ((tvar) = LIST_NEXT(var, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * List functions.
+ */
+#define	LIST_INIT(head) do {						\
+	LIST_FIRST(head) = LIST_END(head);				\
+} while (0)
+
+#define LIST_INSERT_AFTER(listelm, elm, field) do {			\
+	if (((elm)->field.le_next = (listelm)->field.le_next) != NULL)	\
+		(listelm)->field.le_next->field.le_prev =		\
+		    &(elm)->field.le_next;				\
+	(listelm)->field.le_next = (elm);				\
+	(elm)->field.le_prev = &(listelm)->field.le_next;		\
+} while (0)
+
+#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
+	(elm)->field.le_prev = (listelm)->field.le_prev;		\
+	(elm)->field.le_next = (listelm);				\
+	*(listelm)->field.le_prev = (elm);				\
+	(listelm)->field.le_prev = &(elm)->field.le_next;		\
+} while (0)
+
+#define LIST_INSERT_HEAD(head, elm, field) do {				\
+	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
+		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
+	(head)->lh_first = (elm);					\
+	(elm)->field.le_prev = &(head)->lh_first;			\
+} while (0)
+
+#define LIST_REMOVE(elm, field) do {					\
+	if ((elm)->field.le_next != NULL)				\
+		(elm)->field.le_next->field.le_prev =			\
+		    (elm)->field.le_prev;				\
+	*(elm)->field.le_prev = (elm)->field.le_next;			\
+	_Q_INVALIDATE((elm)->field.le_prev);				\
+	_Q_INVALIDATE((elm)->field.le_next);				\
+} while (0)
+
+#define LIST_REPLACE(elm, elm2, field) do {				\
+	if (((elm2)->field.le_next = (elm)->field.le_next) != NULL)	\
+		(elm2)->field.le_next->field.le_prev =			\
+		    &(elm2)->field.le_next;				\
+	(elm2)->field.le_prev = (elm)->field.le_prev;			\
+	*(elm2)->field.le_prev = (elm2);				\
+	_Q_INVALIDATE((elm)->field.le_prev);				\
+	_Q_INVALIDATE((elm)->field.le_next);				\
+} while (0)
+
+/*
+ * Simple queue definitions.
+ */
+#define SIMPLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *sqh_first;	/* first element */			\
+	struct type **sqh_last;	/* addr of last next element */		\
+}
+
+#define SIMPLEQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).sqh_first }
+
+#define SIMPLEQ_ENTRY(type)						\
+struct {								\
+	struct type *sqe_next;	/* next element */			\
+}
+
+/*
+ * Simple queue access methods.
+ */
+#define	SIMPLEQ_FIRST(head)	    ((head)->sqh_first)
+#define	SIMPLEQ_END(head)	    NULL
+#define	SIMPLEQ_EMPTY(head)	    (SIMPLEQ_FIRST(head) == SIMPLEQ_END(head))
+#define	SIMPLEQ_NEXT(elm, field)    ((elm)->field.sqe_next)
+
+#define SIMPLEQ_FOREACH(var, head, field)				\
+	for((var) = SIMPLEQ_FIRST(head);				\
+	    (var) != SIMPLEQ_END(head);					\
+	    (var) = SIMPLEQ_NEXT(var, field))
+
+#define	SIMPLEQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = SIMPLEQ_FIRST(head);				\
+	    (var) && ((tvar) = SIMPLEQ_NEXT(var, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Simple queue functions.
+ */
+#define	SIMPLEQ_INIT(head) do {						\
+	(head)->sqh_first = NULL;					\
+	(head)->sqh_last = &(head)->sqh_first;				\
+} while (0)
+
+#define SIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.sqe_next = (head)->sqh_first) == NULL)	\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+	(head)->sqh_first = (elm);					\
+} while (0)
+
+#define SIMPLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.sqe_next = NULL;					\
+	*(head)->sqh_last = (elm);					\
+	(head)->sqh_last = &(elm)->field.sqe_next;			\
+} while (0)
+
+#define SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.sqe_next = (listelm)->field.sqe_next) == NULL)\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+	(listelm)->field.sqe_next = (elm);				\
+} while (0)
+
+#define SIMPLEQ_REMOVE_HEAD(head, field) do {			\
+	if (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \
+		(head)->sqh_last = &(head)->sqh_first;			\
+} while (0)
+
+#define SIMPLEQ_REMOVE_AFTER(head, elm, field) do {			\
+	if (((elm)->field.sqe_next = (elm)->field.sqe_next->field.sqe_next) \
+	    == NULL)							\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+} while (0)
+
+#define SIMPLEQ_CONCAT(head1, head2) do {				\
+	if (!SIMPLEQ_EMPTY((head2))) {					\
+		*(head1)->sqh_last = (head2)->sqh_first;		\
+		(head1)->sqh_last = (head2)->sqh_last;			\
+		SIMPLEQ_INIT((head2));					\
+	}								\
+} while (0)
+
+/*
+ * XOR Simple queue definitions.
+ */
+#define XSIMPLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *sqx_first;	/* first element */			\
+	struct type **sqx_last;	/* addr of last next element */		\
+	unsigned long sqx_cookie;					\
+}
+
+#define XSIMPLEQ_ENTRY(type)						\
+struct {								\
+	struct type *sqx_next;	/* next element */			\
+}
+
+/*
+ * XOR Simple queue access methods.
+ */
+#define XSIMPLEQ_XOR(head, ptr)	    ((__typeof(ptr))((head)->sqx_cookie ^ \
+					(unsigned long)(ptr)))
+#define	XSIMPLEQ_FIRST(head)	    XSIMPLEQ_XOR(head, ((head)->sqx_first))
+#define	XSIMPLEQ_END(head)	    NULL
+#define	XSIMPLEQ_EMPTY(head)	    (XSIMPLEQ_FIRST(head) == XSIMPLEQ_END(head))
+#define	XSIMPLEQ_NEXT(head, elm, field)    XSIMPLEQ_XOR(head, ((elm)->field.sqx_next))
+
+
+#define XSIMPLEQ_FOREACH(var, head, field)				\
+	for ((var) = XSIMPLEQ_FIRST(head);				\
+	    (var) != XSIMPLEQ_END(head);				\
+	    (var) = XSIMPLEQ_NEXT(head, var, field))
+
+#define	XSIMPLEQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = XSIMPLEQ_FIRST(head);				\
+	    (var) && ((tvar) = XSIMPLEQ_NEXT(head, var, field), 1);	\
+	    (var) = (tvar))
+
+/*
+ * XOR Simple queue functions.
+ */
+#define	XSIMPLEQ_INIT(head) do {					\
+	arc4random_buf(&(head)->sqx_cookie, sizeof((head)->sqx_cookie)); \
+	(head)->sqx_first = XSIMPLEQ_XOR(head, NULL);			\
+	(head)->sqx_last = XSIMPLEQ_XOR(head, &(head)->sqx_first);	\
+} while (0)
+
+#define XSIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.sqx_next = (head)->sqx_first) ==		\
+	    XSIMPLEQ_XOR(head, NULL))					\
+		(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next); \
+	(head)->sqx_first = XSIMPLEQ_XOR(head, (elm));			\
+} while (0)
+
+#define XSIMPLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.sqx_next = XSIMPLEQ_XOR(head, NULL);		\
+	*(XSIMPLEQ_XOR(head, (head)->sqx_last)) = XSIMPLEQ_XOR(head, (elm)); \
+	(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next);	\
+} while (0)
+
+#define XSIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.sqx_next = (listelm)->field.sqx_next) ==	\
+	    XSIMPLEQ_XOR(head, NULL))					\
+		(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next); \
+	(listelm)->field.sqx_next = XSIMPLEQ_XOR(head, (elm));		\
+} while (0)
+
+#define XSIMPLEQ_REMOVE_HEAD(head, field) do {				\
+	if (((head)->sqx_first = XSIMPLEQ_XOR(head,			\
+	    (head)->sqx_first)->field.sqx_next) == XSIMPLEQ_XOR(head, NULL)) \
+		(head)->sqx_last = XSIMPLEQ_XOR(head, &(head)->sqx_first); \
+} while (0)
+
+#define XSIMPLEQ_REMOVE_AFTER(head, elm, field) do {			\
+	if (((elm)->field.sqx_next = XSIMPLEQ_XOR(head,			\
+	    (elm)->field.sqx_next)->field.sqx_next)			\
+	    == XSIMPLEQ_XOR(head, NULL))				\
+		(head)->sqx_last = 					\
+		    XSIMPLEQ_XOR(head, &(elm)->field.sqx_next);		\
+} while (0)
+
+
+/*
+ * Tail queue definitions.
+ */
+#define TAILQ_HEAD(name, type)						\
+struct name {								\
+	struct type *tqh_first;	/* first element */			\
+	struct type **tqh_last;	/* addr of last next element */		\
+}
+
+#define TAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).tqh_first }
+
+#define TAILQ_ENTRY(type)						\
+struct {								\
+	struct type *tqe_next;	/* next element */			\
+	struct type **tqe_prev;	/* address of previous next element */	\
+}
+
+/*
+ * Tail queue access methods.
+ */
+#define	TAILQ_FIRST(head)		((head)->tqh_first)
+#define	TAILQ_END(head)			NULL
+#define	TAILQ_NEXT(elm, field)		((elm)->field.tqe_next)
+#define TAILQ_LAST(head, headname)					\
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+/* XXX */
+#define TAILQ_PREV(elm, headname, field)				\
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+#define	TAILQ_EMPTY(head)						\
+	(TAILQ_FIRST(head) == TAILQ_END(head))
+
+#define TAILQ_FOREACH(var, head, field)					\
+	for((var) = TAILQ_FIRST(head);					\
+	    (var) != TAILQ_END(head);					\
+	    (var) = TAILQ_NEXT(var, field))
+
+#define	TAILQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = TAILQ_FIRST(head);					\
+	    (var) != TAILQ_END(head) &&					\
+	    ((tvar) = TAILQ_NEXT(var, field), 1);			\
+	    (var) = (tvar))
+
+
+#define TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
+	for((var) = TAILQ_LAST(head, headname);				\
+	    (var) != TAILQ_END(head);					\
+	    (var) = TAILQ_PREV(var, headname, field))
+
+#define	TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
+	for ((var) = TAILQ_LAST(head, headname);			\
+	    (var) != TAILQ_END(head) &&					\
+	    ((tvar) = TAILQ_PREV(var, headname, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Tail queue functions.
+ */
+#define	TAILQ_INIT(head) do {						\
+	(head)->tqh_first = NULL;					\
+	(head)->tqh_last = &(head)->tqh_first;				\
+} while (0)
+
+#define TAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.tqe_next = (head)->tqh_first) != NULL)	\
+		(head)->tqh_first->field.tqe_prev =			\
+		    &(elm)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm)->field.tqe_next;		\
+	(head)->tqh_first = (elm);					\
+	(elm)->field.tqe_prev = &(head)->tqh_first;			\
+} while (0)
+
+#define TAILQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.tqe_next = NULL;					\
+	(elm)->field.tqe_prev = (head)->tqh_last;			\
+	*(head)->tqh_last = (elm);					\
+	(head)->tqh_last = &(elm)->field.tqe_next;			\
+} while (0)
+
+#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
+		(elm)->field.tqe_next->field.tqe_prev =			\
+		    &(elm)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm)->field.tqe_next;		\
+	(listelm)->field.tqe_next = (elm);				\
+	(elm)->field.tqe_prev = &(listelm)->field.tqe_next;		\
+} while (0)
+
+#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
+	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
+	(elm)->field.tqe_next = (listelm);				\
+	*(listelm)->field.tqe_prev = (elm);				\
+	(listelm)->field.tqe_prev = &(elm)->field.tqe_next;		\
+} while (0)
+
+#define TAILQ_REMOVE(head, elm, field) do {				\
+	if (((elm)->field.tqe_next) != NULL)				\
+		(elm)->field.tqe_next->field.tqe_prev =			\
+		    (elm)->field.tqe_prev;				\
+	else								\
+		(head)->tqh_last = (elm)->field.tqe_prev;		\
+	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
+	_Q_INVALIDATE((elm)->field.tqe_prev);				\
+	_Q_INVALIDATE((elm)->field.tqe_next);				\
+} while (0)
+
+#define TAILQ_REPLACE(head, elm, elm2, field) do {			\
+	if (((elm2)->field.tqe_next = (elm)->field.tqe_next) != NULL)	\
+		(elm2)->field.tqe_next->field.tqe_prev =		\
+		    &(elm2)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm2)->field.tqe_next;		\
+	(elm2)->field.tqe_prev = (elm)->field.tqe_prev;			\
+	*(elm2)->field.tqe_prev = (elm2);				\
+	_Q_INVALIDATE((elm)->field.tqe_prev);				\
+	_Q_INVALIDATE((elm)->field.tqe_next);				\
+} while (0)
+
+#define TAILQ_CONCAT(head1, head2, field) do {				\
+	if (!TAILQ_EMPTY(head2)) {					\
+		*(head1)->tqh_last = (head2)->tqh_first;		\
+		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;	\
+		(head1)->tqh_last = (head2)->tqh_last;			\
+		TAILQ_INIT((head2));					\
+	}								\
+} while (0)
+
+#endif	/* !_SYS_QUEUE_H_ */
diff --git a/lib/openbsd-tree.h b/lib/openbsd-tree.h
new file mode 100644
index 0000000..e6502b1
--- /dev/null
+++ b/lib/openbsd-tree.h
@@ -0,0 +1,748 @@
+/*	$OpenBSD: tree.h,v 1.14 2015/05/25 03:07:49 deraadt Exp $	*/
+/*
+ * Copyright 2002 Niels Provos <provos@citi.umich.edu>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	_SYS_TREE_H_
+#define	_SYS_TREE_H_
+
+/*
+ * This file defines data structures for different types of trees:
+ * splay trees and red-black trees.
+ *
+ * A splay tree is a self-organizing data structure.  Every operation
+ * on the tree causes a splay to happen.  The splay moves the requested
+ * node to the root of the tree and partly rebalances it.
+ *
+ * This has the benefit that request locality causes faster lookups as
+ * the requested nodes move to the top of the tree.  On the other hand,
+ * every lookup causes memory writes.
+ *
+ * The Balance Theorem bounds the total access time for m operations
+ * and n inserts on an initially empty tree as O((m + n)lg n).  The
+ * amortized cost for a sequence of m accesses to a splay tree is O(lg n);
+ *
+ * A red-black tree is a binary search tree with the node color as an
+ * extra attribute.  It fulfills a set of conditions:
+ *	- every search path from the root to a leaf consists of the
+ *	  same number of black nodes,
+ *	- each red node (except for the root) has a black parent,
+ *	- each leaf node is black.
+ *
+ * Every operation on a red-black tree is bounded as O(lg n).
+ * The maximum height of a red-black tree is 2lg (n+1).
+ */
+
+#define SPLAY_HEAD(name, type)						\
+struct name {								\
+	struct type *sph_root; /* root of the tree */			\
+}
+
+#define SPLAY_INITIALIZER(root)						\
+	{ NULL }
+
+#define SPLAY_INIT(root) do {						\
+	(root)->sph_root = NULL;					\
+} while (0)
+
+#define SPLAY_ENTRY(type)						\
+struct {								\
+	struct type *spe_left; /* left element */			\
+	struct type *spe_right; /* right element */			\
+}
+
+#define SPLAY_LEFT(elm, field)		(elm)->field.spe_left
+#define SPLAY_RIGHT(elm, field)		(elm)->field.spe_right
+#define SPLAY_ROOT(head)		(head)->sph_root
+#define SPLAY_EMPTY(head)		(SPLAY_ROOT(head) == NULL)
+
+/* SPLAY_ROTATE_{LEFT,RIGHT} expect that tmp hold SPLAY_{RIGHT,LEFT} */
+#define SPLAY_ROTATE_RIGHT(head, tmp, field) do {			\
+	SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field);	\
+	SPLAY_RIGHT(tmp, field) = (head)->sph_root;			\
+	(head)->sph_root = tmp;						\
+} while (0)
+
+#define SPLAY_ROTATE_LEFT(head, tmp, field) do {			\
+	SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field);	\
+	SPLAY_LEFT(tmp, field) = (head)->sph_root;			\
+	(head)->sph_root = tmp;						\
+} while (0)
+
+#define SPLAY_LINKLEFT(head, tmp, field) do {				\
+	SPLAY_LEFT(tmp, field) = (head)->sph_root;			\
+	tmp = (head)->sph_root;						\
+	(head)->sph_root = SPLAY_LEFT((head)->sph_root, field);		\
+} while (0)
+
+#define SPLAY_LINKRIGHT(head, tmp, field) do {				\
+	SPLAY_RIGHT(tmp, field) = (head)->sph_root;			\
+	tmp = (head)->sph_root;						\
+	(head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);	\
+} while (0)
+
+#define SPLAY_ASSEMBLE(head, node, left, right, field) do {		\
+	SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field);	\
+	SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);\
+	SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field);	\
+	SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field);	\
+} while (0)
+
+/* Generates prototypes and inline functions */
+
+#define SPLAY_PROTOTYPE(name, type, field, cmp)				\
+void name##_SPLAY(struct name *, struct type *);			\
+void name##_SPLAY_MINMAX(struct name *, int);				\
+struct type *name##_SPLAY_INSERT(struct name *, struct type *);		\
+struct type *name##_SPLAY_REMOVE(struct name *, struct type *);		\
+									\
+/* Finds the node with the same key as elm */				\
+static __inline struct type *						\
+name##_SPLAY_FIND(struct name *head, struct type *elm)			\
+{									\
+	if (SPLAY_EMPTY(head))						\
+		return(NULL);						\
+	name##_SPLAY(head, elm);					\
+	if ((cmp)(elm, (head)->sph_root) == 0)				\
+		return (head->sph_root);				\
+	return (NULL);							\
+}									\
+									\
+static __inline struct type *						\
+name##_SPLAY_NEXT(struct name *head, struct type *elm)			\
+{									\
+	name##_SPLAY(head, elm);					\
+	if (SPLAY_RIGHT(elm, field) != NULL) {				\
+		elm = SPLAY_RIGHT(elm, field);				\
+		while (SPLAY_LEFT(elm, field) != NULL) {		\
+			elm = SPLAY_LEFT(elm, field);			\
+		}							\
+	} else								\
+		elm = NULL;						\
+	return (elm);							\
+}									\
+									\
+static __inline struct type *						\
+name##_SPLAY_MIN_MAX(struct name *head, int val)			\
+{									\
+	name##_SPLAY_MINMAX(head, val);					\
+        return (SPLAY_ROOT(head));					\
+}
+
+/* Main splay operation.
+ * Moves node close to the key of elm to top
+ */
+#define SPLAY_GENERATE(name, type, field, cmp)				\
+struct type *								\
+name##_SPLAY_INSERT(struct name *head, struct type *elm)		\
+{									\
+    if (SPLAY_EMPTY(head)) {						\
+	    SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL;	\
+    } else {								\
+	    int __comp;							\
+	    name##_SPLAY(head, elm);					\
+	    __comp = (cmp)(elm, (head)->sph_root);			\
+	    if(__comp < 0) {						\
+		    SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);\
+		    SPLAY_RIGHT(elm, field) = (head)->sph_root;		\
+		    SPLAY_LEFT((head)->sph_root, field) = NULL;		\
+	    } else if (__comp > 0) {					\
+		    SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);\
+		    SPLAY_LEFT(elm, field) = (head)->sph_root;		\
+		    SPLAY_RIGHT((head)->sph_root, field) = NULL;	\
+	    } else							\
+		    return ((head)->sph_root);				\
+    }									\
+    (head)->sph_root = (elm);						\
+    return (NULL);							\
+}									\
+									\
+struct type *								\
+name##_SPLAY_REMOVE(struct name *head, struct type *elm)		\
+{									\
+	struct type *__tmp;						\
+	if (SPLAY_EMPTY(head))						\
+		return (NULL);						\
+	name##_SPLAY(head, elm);					\
+	if ((cmp)(elm, (head)->sph_root) == 0) {			\
+		if (SPLAY_LEFT((head)->sph_root, field) == NULL) {	\
+			(head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);\
+		} else {						\
+			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
+			(head)->sph_root = SPLAY_LEFT((head)->sph_root, field);\
+			name##_SPLAY(head, elm);			\
+			SPLAY_RIGHT((head)->sph_root, field) = __tmp;	\
+		}							\
+		return (elm);						\
+	}								\
+	return (NULL);							\
+}									\
+									\
+void									\
+name##_SPLAY(struct name *head, struct type *elm)			\
+{									\
+	struct type __node, *__left, *__right, *__tmp;			\
+	int __comp;							\
+\
+	SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\
+	__left = __right = &__node;					\
+\
+	while ((__comp = (cmp)(elm, (head)->sph_root))) {		\
+		if (__comp < 0) {					\
+			__tmp = SPLAY_LEFT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if ((cmp)(elm, __tmp) < 0){			\
+				SPLAY_ROTATE_RIGHT(head, __tmp, field);	\
+				if (SPLAY_LEFT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKLEFT(head, __right, field);		\
+		} else if (__comp > 0) {				\
+			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if ((cmp)(elm, __tmp) > 0){			\
+				SPLAY_ROTATE_LEFT(head, __tmp, field);	\
+				if (SPLAY_RIGHT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKRIGHT(head, __left, field);		\
+		}							\
+	}								\
+	SPLAY_ASSEMBLE(head, &__node, __left, __right, field);		\
+}									\
+									\
+/* Splay with either the minimum or the maximum element			\
+ * Used to find minimum or maximum element in tree.			\
+ */									\
+void name##_SPLAY_MINMAX(struct name *head, int __comp) \
+{									\
+	struct type __node, *__left, *__right, *__tmp;			\
+\
+	SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\
+	__left = __right = &__node;					\
+\
+	while (1) {							\
+		if (__comp < 0) {					\
+			__tmp = SPLAY_LEFT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if (__comp < 0){				\
+				SPLAY_ROTATE_RIGHT(head, __tmp, field);	\
+				if (SPLAY_LEFT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKLEFT(head, __right, field);		\
+		} else if (__comp > 0) {				\
+			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if (__comp > 0) {				\
+				SPLAY_ROTATE_LEFT(head, __tmp, field);	\
+				if (SPLAY_RIGHT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKRIGHT(head, __left, field);		\
+		}							\
+	}								\
+	SPLAY_ASSEMBLE(head, &__node, __left, __right, field);		\
+}
+
+#define SPLAY_NEGINF	-1
+#define SPLAY_INF	1
+
+#define SPLAY_INSERT(name, x, y)	name##_SPLAY_INSERT(x, y)
+#define SPLAY_REMOVE(name, x, y)	name##_SPLAY_REMOVE(x, y)
+#define SPLAY_FIND(name, x, y)		name##_SPLAY_FIND(x, y)
+#define SPLAY_NEXT(name, x, y)		name##_SPLAY_NEXT(x, y)
+#define SPLAY_MIN(name, x)		(SPLAY_EMPTY(x) ? NULL	\
+					: name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))
+#define SPLAY_MAX(name, x)		(SPLAY_EMPTY(x) ? NULL	\
+					: name##_SPLAY_MIN_MAX(x, SPLAY_INF))
+
+#define SPLAY_FOREACH(x, name, head)					\
+	for ((x) = SPLAY_MIN(name, head);				\
+	     (x) != NULL;						\
+	     (x) = SPLAY_NEXT(name, head, x))
+
+/* Macros that define a red-black tree */
+#define RB_HEAD(name, type)						\
+struct name {								\
+	struct type *rbh_root; /* root of the tree */			\
+}
+
+#define RB_INITIALIZER(root)						\
+	{ NULL }
+
+#define RB_INIT(root) do {						\
+	(root)->rbh_root = NULL;					\
+} while (0)
+
+#define RB_BLACK	0
+#define RB_RED		1
+#define RB_ENTRY(type)							\
+struct {								\
+	struct type *rbe_left;		/* left element */		\
+	struct type *rbe_right;		/* right element */		\
+	struct type *rbe_parent;	/* parent element */		\
+	int rbe_color;			/* node color */		\
+}
+
+#define RB_LEFT(elm, field)		(elm)->field.rbe_left
+#define RB_RIGHT(elm, field)		(elm)->field.rbe_right
+#define RB_PARENT(elm, field)		(elm)->field.rbe_parent
+#define RB_COLOR(elm, field)		(elm)->field.rbe_color
+#define RB_ROOT(head)			(head)->rbh_root
+#define RB_EMPTY(head)			(RB_ROOT(head) == NULL)
+
+#define RB_SET(elm, parent, field) do {					\
+	RB_PARENT(elm, field) = parent;					\
+	RB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL;		\
+	RB_COLOR(elm, field) = RB_RED;					\
+} while (0)
+
+#define RB_SET_BLACKRED(black, red, field) do {				\
+	RB_COLOR(black, field) = RB_BLACK;				\
+	RB_COLOR(red, field) = RB_RED;					\
+} while (0)
+
+#ifndef RB_AUGMENT
+#define RB_AUGMENT(x)	do {} while (0)
+#endif
+
+#define RB_ROTATE_LEFT(head, elm, tmp, field) do {			\
+	(tmp) = RB_RIGHT(elm, field);					\
+	if ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field))) {		\
+		RB_PARENT(RB_LEFT(tmp, field), field) = (elm);		\
+	}								\
+	RB_AUGMENT(elm);						\
+	if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) {		\
+		if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))	\
+			RB_LEFT(RB_PARENT(elm, field), field) = (tmp);	\
+		else							\
+			RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);	\
+	} else								\
+		(head)->rbh_root = (tmp);				\
+	RB_LEFT(tmp, field) = (elm);					\
+	RB_PARENT(elm, field) = (tmp);					\
+	RB_AUGMENT(tmp);						\
+	if ((RB_PARENT(tmp, field)))					\
+		RB_AUGMENT(RB_PARENT(tmp, field));			\
+} while (0)
+
+#define RB_ROTATE_RIGHT(head, elm, tmp, field) do {			\
+	(tmp) = RB_LEFT(elm, field);					\
+	if ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field))) {		\
+		RB_PARENT(RB_RIGHT(tmp, field), field) = (elm);		\
+	}								\
+	RB_AUGMENT(elm);						\
+	if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) {		\
+		if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))	\
+			RB_LEFT(RB_PARENT(elm, field), field) = (tmp);	\
+		else							\
+			RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);	\
+	} else								\
+		(head)->rbh_root = (tmp);				\
+	RB_RIGHT(tmp, field) = (elm);					\
+	RB_PARENT(elm, field) = (tmp);					\
+	RB_AUGMENT(tmp);						\
+	if ((RB_PARENT(tmp, field)))					\
+		RB_AUGMENT(RB_PARENT(tmp, field));			\
+} while (0)
+
+/* Generates prototypes and inline functions */
+#define	RB_PROTOTYPE(name, type, field, cmp)				\
+	RB_PROTOTYPE_INTERNAL(name, type, field, cmp,)
+#define	RB_PROTOTYPE_STATIC(name, type, field, cmp)			\
+	RB_PROTOTYPE_INTERNAL(name, type, field, cmp, __attribute__((__unused__)) static)
+#define RB_PROTOTYPE_INTERNAL(name, type, field, cmp, attr)		\
+attr void name##_RB_INSERT_COLOR(struct name *, struct type *);		\
+attr void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);\
+attr struct type *name##_RB_REMOVE(struct name *, struct type *);	\
+attr struct type *name##_RB_INSERT(struct name *, struct type *);	\
+attr struct type *name##_RB_FIND(struct name *, struct type *);		\
+attr struct type *name##_RB_NFIND(struct name *, struct type *);	\
+attr struct type *name##_RB_NEXT(struct type *);			\
+attr struct type *name##_RB_PREV(struct type *);			\
+attr struct type *name##_RB_MINMAX(struct name *, int);			\
+									\
+
+/* Main rb operation.
+ * Moves node close to the key of elm to top
+ */
+#define	RB_GENERATE(name, type, field, cmp)				\
+	RB_GENERATE_INTERNAL(name, type, field, cmp,)
+#define	RB_GENERATE_STATIC(name, type, field, cmp)			\
+	RB_GENERATE_INTERNAL(name, type, field, cmp, __attribute__((__unused__)) static)
+#define RB_GENERATE_INTERNAL(name, type, field, cmp, attr)		\
+attr void								\
+name##_RB_INSERT_COLOR(struct name *head, struct type *elm)		\
+{									\
+	struct type *parent, *gparent, *tmp;				\
+	while ((parent = RB_PARENT(elm, field)) &&			\
+	    RB_COLOR(parent, field) == RB_RED) {			\
+		gparent = RB_PARENT(parent, field);			\
+		if (parent == RB_LEFT(gparent, field)) {		\
+			tmp = RB_RIGHT(gparent, field);			\
+			if (tmp && RB_COLOR(tmp, field) == RB_RED) {	\
+				RB_COLOR(tmp, field) = RB_BLACK;	\
+				RB_SET_BLACKRED(parent, gparent, field);\
+				elm = gparent;				\
+				continue;				\
+			}						\
+			if (RB_RIGHT(parent, field) == elm) {		\
+				RB_ROTATE_LEFT(head, parent, tmp, field);\
+				tmp = parent;				\
+				parent = elm;				\
+				elm = tmp;				\
+			}						\
+			RB_SET_BLACKRED(parent, gparent, field);	\
+			RB_ROTATE_RIGHT(head, gparent, tmp, field);	\
+		} else {						\
+			tmp = RB_LEFT(gparent, field);			\
+			if (tmp && RB_COLOR(tmp, field) == RB_RED) {	\
+				RB_COLOR(tmp, field) = RB_BLACK;	\
+				RB_SET_BLACKRED(parent, gparent, field);\
+				elm = gparent;				\
+				continue;				\
+			}						\
+			if (RB_LEFT(parent, field) == elm) {		\
+				RB_ROTATE_RIGHT(head, parent, tmp, field);\
+				tmp = parent;				\
+				parent = elm;				\
+				elm = tmp;				\
+			}						\
+			RB_SET_BLACKRED(parent, gparent, field);	\
+			RB_ROTATE_LEFT(head, gparent, tmp, field);	\
+		}							\
+	}								\
+	RB_COLOR(head->rbh_root, field) = RB_BLACK;			\
+}									\
+									\
+attr void								\
+name##_RB_REMOVE_COLOR(struct name *head, struct type *parent, struct type *elm) \
+{									\
+	struct type *tmp;						\
+	while ((elm == NULL || RB_COLOR(elm, field) == RB_BLACK) &&	\
+	    elm != RB_ROOT(head)) {					\
+		if (RB_LEFT(parent, field) == elm) {			\
+			tmp = RB_RIGHT(parent, field);			\
+			if (RB_COLOR(tmp, field) == RB_RED) {		\
+				RB_SET_BLACKRED(tmp, parent, field);	\
+				RB_ROTATE_LEFT(head, parent, tmp, field);\
+				tmp = RB_RIGHT(parent, field);		\
+			}						\
+			if ((RB_LEFT(tmp, field) == NULL ||		\
+			    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&\
+			    (RB_RIGHT(tmp, field) == NULL ||		\
+			    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {\
+				RB_COLOR(tmp, field) = RB_RED;		\
+				elm = parent;				\
+				parent = RB_PARENT(elm, field);		\
+			} else {					\
+				if (RB_RIGHT(tmp, field) == NULL ||	\
+				    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK) {\
+					struct type *oleft;		\
+					if ((oleft = RB_LEFT(tmp, field)))\
+						RB_COLOR(oleft, field) = RB_BLACK;\
+					RB_COLOR(tmp, field) = RB_RED;	\
+					RB_ROTATE_RIGHT(head, tmp, oleft, field);\
+					tmp = RB_RIGHT(parent, field);	\
+				}					\
+				RB_COLOR(tmp, field) = RB_COLOR(parent, field);\
+				RB_COLOR(parent, field) = RB_BLACK;	\
+				if (RB_RIGHT(tmp, field))		\
+					RB_COLOR(RB_RIGHT(tmp, field), field) = RB_BLACK;\
+				RB_ROTATE_LEFT(head, parent, tmp, field);\
+				elm = RB_ROOT(head);			\
+				break;					\
+			}						\
+		} else {						\
+			tmp = RB_LEFT(parent, field);			\
+			if (RB_COLOR(tmp, field) == RB_RED) {		\
+				RB_SET_BLACKRED(tmp, parent, field);	\
+				RB_ROTATE_RIGHT(head, parent, tmp, field);\
+				tmp = RB_LEFT(parent, field);		\
+			}						\
+			if ((RB_LEFT(tmp, field) == NULL ||		\
+			    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&\
+			    (RB_RIGHT(tmp, field) == NULL ||		\
+			    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {\
+				RB_COLOR(tmp, field) = RB_RED;		\
+				elm = parent;				\
+				parent = RB_PARENT(elm, field);		\
+			} else {					\
+				if (RB_LEFT(tmp, field) == NULL ||	\
+				    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) {\
+					struct type *oright;		\
+					if ((oright = RB_RIGHT(tmp, field)))\
+						RB_COLOR(oright, field) = RB_BLACK;\
+					RB_COLOR(tmp, field) = RB_RED;	\
+					RB_ROTATE_LEFT(head, tmp, oright, field);\
+					tmp = RB_LEFT(parent, field);	\
+				}					\
+				RB_COLOR(tmp, field) = RB_COLOR(parent, field);\
+				RB_COLOR(parent, field) = RB_BLACK;	\
+				if (RB_LEFT(tmp, field))		\
+					RB_COLOR(RB_LEFT(tmp, field), field) = RB_BLACK;\
+				RB_ROTATE_RIGHT(head, parent, tmp, field);\
+				elm = RB_ROOT(head);			\
+				break;					\
+			}						\
+		}							\
+	}								\
+	if (elm)							\
+		RB_COLOR(elm, field) = RB_BLACK;			\
+}									\
+									\
+attr struct type *							\
+name##_RB_REMOVE(struct name *head, struct type *elm)			\
+{									\
+	struct type *child, *parent, *old = elm;			\
+	int color;							\
+	if (RB_LEFT(elm, field) == NULL)				\
+		child = RB_RIGHT(elm, field);				\
+	else if (RB_RIGHT(elm, field) == NULL)				\
+		child = RB_LEFT(elm, field);				\
+	else {								\
+		struct type *left;					\
+		elm = RB_RIGHT(elm, field);				\
+		while ((left = RB_LEFT(elm, field)))			\
+			elm = left;					\
+		child = RB_RIGHT(elm, field);				\
+		parent = RB_PARENT(elm, field);				\
+		color = RB_COLOR(elm, field);				\
+		if (child)						\
+			RB_PARENT(child, field) = parent;		\
+		if (parent) {						\
+			if (RB_LEFT(parent, field) == elm)		\
+				RB_LEFT(parent, field) = child;		\
+			else						\
+				RB_RIGHT(parent, field) = child;	\
+			RB_AUGMENT(parent);				\
+		} else							\
+			RB_ROOT(head) = child;				\
+		if (RB_PARENT(elm, field) == old)			\
+			parent = elm;					\
+		(elm)->field = (old)->field;				\
+		if (RB_PARENT(old, field)) {				\
+			if (RB_LEFT(RB_PARENT(old, field), field) == old)\
+				RB_LEFT(RB_PARENT(old, field), field) = elm;\
+			else						\
+				RB_RIGHT(RB_PARENT(old, field), field) = elm;\
+			RB_AUGMENT(RB_PARENT(old, field));		\
+		} else							\
+			RB_ROOT(head) = elm;				\
+		RB_PARENT(RB_LEFT(old, field), field) = elm;		\
+		if (RB_RIGHT(old, field))				\
+			RB_PARENT(RB_RIGHT(old, field), field) = elm;	\
+		if (parent) {						\
+			left = parent;					\
+			do {						\
+				RB_AUGMENT(left);			\
+			} while ((left = RB_PARENT(left, field)));	\
+		}							\
+		goto color;						\
+	}								\
+	parent = RB_PARENT(elm, field);					\
+	color = RB_COLOR(elm, field);					\
+	if (child)							\
+		RB_PARENT(child, field) = parent;			\
+	if (parent) {							\
+		if (RB_LEFT(parent, field) == elm)			\
+			RB_LEFT(parent, field) = child;			\
+		else							\
+			RB_RIGHT(parent, field) = child;		\
+		RB_AUGMENT(parent);					\
+	} else								\
+		RB_ROOT(head) = child;					\
+color:									\
+	if (color == RB_BLACK)						\
+		name##_RB_REMOVE_COLOR(head, parent, child);		\
+	return (old);							\
+}									\
+									\
+/* Inserts a node into the RB tree */					\
+attr struct type *							\
+name##_RB_INSERT(struct name *head, struct type *elm)			\
+{									\
+	struct type *tmp;						\
+	struct type *parent = NULL;					\
+	int comp = 0;							\
+	tmp = RB_ROOT(head);						\
+	while (tmp) {							\
+		parent = tmp;						\
+		comp = (cmp)(elm, parent);				\
+		if (comp < 0)						\
+			tmp = RB_LEFT(tmp, field);			\
+		else if (comp > 0)					\
+			tmp = RB_RIGHT(tmp, field);			\
+		else							\
+			return (tmp);					\
+	}								\
+	RB_SET(elm, parent, field);					\
+	if (parent != NULL) {						\
+		if (comp < 0)						\
+			RB_LEFT(parent, field) = elm;			\
+		else							\
+			RB_RIGHT(parent, field) = elm;			\
+		RB_AUGMENT(parent);					\
+	} else								\
+		RB_ROOT(head) = elm;					\
+	name##_RB_INSERT_COLOR(head, elm);				\
+	return (NULL);							\
+}									\
+									\
+/* Finds the node with the same key as elm */				\
+attr struct type *							\
+name##_RB_FIND(struct name *head, struct type *elm)			\
+{									\
+	struct type *tmp = RB_ROOT(head);				\
+	int comp;							\
+	while (tmp) {							\
+		comp = cmp(elm, tmp);					\
+		if (comp < 0)						\
+			tmp = RB_LEFT(tmp, field);			\
+		else if (comp > 0)					\
+			tmp = RB_RIGHT(tmp, field);			\
+		else							\
+			return (tmp);					\
+	}								\
+	return (NULL);							\
+}									\
+									\
+/* Finds the first node greater than or equal to the search key */	\
+attr struct type *							\
+name##_RB_NFIND(struct name *head, struct type *elm)			\
+{									\
+	struct type *tmp = RB_ROOT(head);				\
+	struct type *res = NULL;					\
+	int comp;							\
+	while (tmp) {							\
+		comp = cmp(elm, tmp);					\
+		if (comp < 0) {						\
+			res = tmp;					\
+			tmp = RB_LEFT(tmp, field);			\
+		}							\
+		else if (comp > 0)					\
+			tmp = RB_RIGHT(tmp, field);			\
+		else							\
+			return (tmp);					\
+	}								\
+	return (res);							\
+}									\
+									\
+/* ARGSUSED */								\
+attr struct type *							\
+name##_RB_NEXT(struct type *elm)					\
+{									\
+	if (RB_RIGHT(elm, field)) {					\
+		elm = RB_RIGHT(elm, field);				\
+		while (RB_LEFT(elm, field))				\
+			elm = RB_LEFT(elm, field);			\
+	} else {							\
+		if (RB_PARENT(elm, field) &&				\
+		    (elm == RB_LEFT(RB_PARENT(elm, field), field)))	\
+			elm = RB_PARENT(elm, field);			\
+		else {							\
+			while (RB_PARENT(elm, field) &&			\
+			    (elm == RB_RIGHT(RB_PARENT(elm, field), field)))\
+				elm = RB_PARENT(elm, field);		\
+			elm = RB_PARENT(elm, field);			\
+		}							\
+	}								\
+	return (elm);							\
+}									\
+									\
+/* ARGSUSED */								\
+attr struct type *							\
+name##_RB_PREV(struct type *elm)					\
+{									\
+	if (RB_LEFT(elm, field)) {					\
+		elm = RB_LEFT(elm, field);				\
+		while (RB_RIGHT(elm, field))				\
+			elm = RB_RIGHT(elm, field);			\
+	} else {							\
+		if (RB_PARENT(elm, field) &&				\
+		    (elm == RB_RIGHT(RB_PARENT(elm, field), field)))	\
+			elm = RB_PARENT(elm, field);			\
+		else {							\
+			while (RB_PARENT(elm, field) &&			\
+			    (elm == RB_LEFT(RB_PARENT(elm, field), field)))\
+				elm = RB_PARENT(elm, field);		\
+			elm = RB_PARENT(elm, field);			\
+		}							\
+	}								\
+	return (elm);							\
+}									\
+									\
+attr struct type *							\
+name##_RB_MINMAX(struct name *head, int val)				\
+{									\
+	struct type *tmp = RB_ROOT(head);				\
+	struct type *parent = NULL;					\
+	while (tmp) {							\
+		parent = tmp;						\
+		if (val < 0)						\
+			tmp = RB_LEFT(tmp, field);			\
+		else							\
+			tmp = RB_RIGHT(tmp, field);			\
+	}								\
+	return (parent);						\
+}
+
+#define RB_NEGINF	-1
+#define RB_INF	1
+
+#define RB_INSERT(name, x, y)	name##_RB_INSERT(x, y)
+#define RB_REMOVE(name, x, y)	name##_RB_REMOVE(x, y)
+#define RB_FIND(name, x, y)	name##_RB_FIND(x, y)
+#define RB_NFIND(name, x, y)	name##_RB_NFIND(x, y)
+#define RB_NEXT(name, x, y)	name##_RB_NEXT(y)
+#define RB_PREV(name, x, y)	name##_RB_PREV(y)
+#define RB_MIN(name, x)		name##_RB_MINMAX(x, RB_NEGINF)
+#define RB_MAX(name, x)		name##_RB_MINMAX(x, RB_INF)
+
+#define RB_FOREACH(x, name, head)					\
+	for ((x) = RB_MIN(name, head);					\
+	     (x) != NULL;						\
+	     (x) = name##_RB_NEXT(x))
+
+#define RB_FOREACH_SAFE(x, name, head, y)				\
+	for ((x) = RB_MIN(name, head);					\
+	    ((x) != NULL) && ((y) = name##_RB_NEXT(x), 1);		\
+	     (x) = (y))
+
+#define RB_FOREACH_REVERSE(x, name, head)				\
+	for ((x) = RB_MAX(name, head);					\
+	     (x) != NULL;						\
+	     (x) = name##_RB_PREV(x))
+
+#define RB_FOREACH_REVERSE_SAFE(x, name, head, y)			\
+	for ((x) = RB_MAX(name, head);					\
+	    ((x) != NULL) && ((y) = name##_RB_PREV(x), 1);		\
+	     (x) = (y))
+
+#endif	/* _SYS_TREE_H_ */
diff --git a/lib/privs.c b/lib/privs.c
index 0ca8783..638aa12 100644
--- a/lib/privs.c
+++ b/lib/privs.c
@@ -248,10 +248,7 @@ zprivs_caps_init (struct zebra_privs_t *zprivs)
     }
 
   if ( !zprivs_state.syscaps_p )
-    {
-      fprintf (stderr, "privs_init: capabilities enabled, "
-                       "but no capabilities supplied\n");
-    }
+    return;
 
   /* we have caps, we have no need to ever change back the original user */
   if (zprivs_state.zuid)
diff --git a/lib/route_types.txt b/lib/route_types.txt
index 1b85607..aa7e3ec 100644
--- a/lib/route_types.txt
+++ b/lib/route_types.txt
@@ -60,6 +60,7 @@ ZEBRA_ROUTE_PIM,	pim,	   pimd,   'P', 1, 0, "PIM"
 ZEBRA_ROUTE_HSLS,       hsls,      hslsd,  'H', 0, 0, "HSLS"
 ZEBRA_ROUTE_OLSR,       olsr,      olsrd,  'o', 0, 0, "OLSR"
 ZEBRA_ROUTE_BABEL,      babel,     babeld, 'A', 1, 1, "Babel"
+ZEBRA_ROUTE_LDP,        ldp,       ldpd,   'L', 1, 1, "LDP"
 
 ## help strings
 ZEBRA_ROUTE_SYSTEM, "Reserved route type, for internal use only"
@@ -76,3 +77,4 @@ ZEBRA_ROUTE_PIM,    "Protocol Independent Multicast (PIM)"
 ZEBRA_ROUTE_HSLS,   "Hazy-Sighted Link State Protocol (HSLS)"
 ZEBRA_ROUTE_OLSR,   "Optimised Link State Routing (OLSR)"
 ZEBRA_ROUTE_BABEL,  "Babel routing protocol (Babel)"
+ZEBRA_ROUTE_LDP,    "Label Distribution Protocol (LDP)"
diff --git a/lib/sockopt.c b/lib/sockopt.c
index 3014237..31b2edb 100644
--- a/lib/sockopt.c
+++ b/lib/sockopt.c
@@ -219,6 +219,7 @@ setsockopt_ipv6_tclass(int sock, int tclass)
 int
 setsockopt_ipv4_multicast(int sock,
 			int optname, 
+			struct in_addr if_addr,
 			unsigned int mcast_addr,
 			ifindex_t ifindex)
 {
@@ -279,18 +280,20 @@ setsockopt_ipv4_multicast(int sock,
 #elif defined(HAVE_BSD_STRUCT_IP_MREQ_HACK) /* #if OS_TYPE */ 
   /* standard BSD API */
 
-  struct in_addr m;
   struct ip_mreq mreq;
   int ret;
 
   assert(optname == IP_ADD_MEMBERSHIP || optname == IP_DROP_MEMBERSHIP);
 
-  m.s_addr = htonl(ifindex);
 
   memset (&mreq, 0, sizeof(mreq));
   mreq.imr_multiaddr.s_addr = mcast_addr;
-  mreq.imr_interface = m;
-  
+#if !defined __OpenBSD__
+  mreq.imr_interface.s_addr = htonl (ifindex);
+#else
+  mreq.imr_interface.s_addr = if_addr.s_addr;
+#endif
+
   ret = setsockopt (sock, IPPROTO_IP, optname, (void *)&mreq, sizeof(mreq));
   if ((ret < 0) && (optname == IP_ADD_MEMBERSHIP) && (errno == EADDRINUSE))
     {
@@ -318,7 +321,8 @@ setsockopt_ipv4_multicast(int sock,
  * Set IP_MULTICAST_IF socket option in an OS-dependent manner.
  */
 int
-setsockopt_ipv4_multicast_if(int sock, ifindex_t ifindex)
+setsockopt_ipv4_multicast_if(int sock, struct in_addr if_addr,
+			     ifindex_t ifindex)
 {
 
 #ifdef HAVE_STRUCT_IP_MREQN_IMR_IFINDEX
@@ -335,7 +339,11 @@ setsockopt_ipv4_multicast_if(int sock, ifindex_t ifindex)
 #elif defined(HAVE_BSD_STRUCT_IP_MREQ_HACK)
   struct in_addr m;
 
-  m.s_addr = htonl(ifindex);
+#if !defined __OpenBSD__
+  m.s_addr = htonl (ifindex);
+#else
+  m.s_addr = if_addr.s_addr;
+#endif
 
   return setsockopt (sock, IPPROTO_IP, IP_MULTICAST_IF, (void *)&m, sizeof(m));
 #else
diff --git a/lib/sockopt.h b/lib/sockopt.h
index a9b8aca..d67b510 100644
--- a/lib/sockopt.h
+++ b/lib/sockopt.h
@@ -83,8 +83,10 @@ extern int setsockopt_ipv6_tclass (int, int);
   (((af) == AF_INET) : SOPT_SIZE_CMSG_IFINDEX_IPV4() \
                     ? SOPT_SIZE_CMSG_PKTINFO_IPV6())
 
-extern int setsockopt_ipv4_multicast_if(int sock, ifindex_t ifindex);
+extern int setsockopt_ipv4_multicast_if(int sock, struct in_addr if_addr,
+					ifindex_t ifindex);
 extern int setsockopt_ipv4_multicast(int sock, int optname,
+                                     struct in_addr if_addr,
                                      unsigned int mcast_addr,
 			             ifindex_t ifindex);
 extern int setsockopt_ipv4_tos(int sock, int tos);
diff --git a/lib/str.c b/lib/str.c
index d8f039a..16f759c 100644
--- a/lib/str.c
+++ b/lib/str.c
@@ -54,26 +54,34 @@ snprintf(char *str, size_t size, const char *format, ...)
 #endif
 
 #ifndef HAVE_STRLCPY
-/**
- * Like strncpy but does not 0 fill the buffer and always null 
- * terminates.
- *
- * @param bufsize is the size of the destination buffer.
- *
- * @return index of the terminating byte.
- **/
+/*
+ * Copy string src to buffer dst of size dsize.  At most dsize-1
+ * chars will be copied.  Always NUL terminates (unless dsize == 0).
+ * Returns strlen(src); if retval >= dsize, truncation occurred.
+ */
 size_t
-strlcpy(char *d, const char *s, size_t bufsize)
+strlcpy(char *dst, const char *src, size_t dsize)
 {
-	size_t len = strlen(s);
-	size_t ret = len;
-	if (bufsize > 0) {
-		if (len >= bufsize)
-			len = bufsize-1;
-		memcpy(d, s, len);
-		d[len] = 0;
+	const char *osrc = src;
+	size_t nleft = dsize;
+
+	/* Copy as many bytes as will fit. */
+	if (nleft != 0) {
+		while (--nleft != 0) {
+			if ((*dst++ = *src++) == '\0')
+				break;
+		}
 	}
-	return ret;
+
+	/* Not enough room in dst, add NUL and traverse rest of src. */
+	if (nleft == 0) {
+		if (dsize != 0)
+			*dst = '\0';		/* NUL-terminate dst */
+		while (*src++)
+			;
+	}
+
+	return(src - osrc - 1);	/* count does not include NUL */
 }
 #endif
 
diff --git a/lib/vty.c b/lib/vty.c
index e4510f8..63dde82 100644
--- a/lib/vty.c
+++ b/lib/vty.c
@@ -747,6 +747,13 @@ vty_end_config (struct vty *vty)
     case RMAP_NODE:
     case OSPF_NODE:
     case OSPF6_NODE:
+    case LDP_NODE:
+    case LDP_IPV4_NODE:
+    case LDP_IPV6_NODE:
+    case LDP_IPV4_IFACE_NODE:
+    case LDP_IPV6_IFACE_NODE:
+    case LDP_L2VPN_NODE:
+    case LDP_PSEUDOWIRE_NODE:
     case ISIS_NODE:
     case KEYCHAIN_NODE:
     case KEYCHAIN_KEY_NODE:
@@ -1152,6 +1159,13 @@ vty_stop_input (struct vty *vty)
     case RMAP_NODE:
     case OSPF_NODE:
     case OSPF6_NODE:
+    case LDP_NODE:
+    case LDP_IPV4_NODE:
+    case LDP_IPV6_NODE:
+    case LDP_IPV4_IFACE_NODE:
+    case LDP_IPV6_IFACE_NODE:
+    case LDP_L2VPN_NODE:
+    case LDP_PSEUDOWIRE_NODE:
     case ISIS_NODE:
     case KEYCHAIN_NODE:
     case KEYCHAIN_KEY_NODE:
@@ -3125,3 +3139,29 @@ vty_terminate (void)
       vector_free (Vvty_serv_thread);
     }
 }
+
+/* Utility functions to get arguments from commands generated
+   by the xml2cli.pl script. */
+const char *
+vty_get_arg_value (struct vty_arg *args[], const char *arg)
+{
+  while (*args)
+    {
+      if (strcmp ((*args)->name, arg) == 0)
+        return (*args)->value;
+      args++;
+    }
+  return NULL;
+}
+
+struct vty_arg *
+vty_get_arg (struct vty_arg *args[], const char *arg)
+{
+  while (*args)
+    {
+      if (strcmp ((*args)->name, arg) == 0)
+        return *args;
+      args++;
+    }
+  return NULL;
+}
diff --git a/lib/vty.h b/lib/vty.h
index 806f2c6..785b2e9 100644
--- a/lib/vty.h
+++ b/lib/vty.h
@@ -124,6 +124,14 @@ struct vty
   char address[SU_ADDRSTRLEN];
 };
 
+struct vty_arg
+{
+  const char *name;
+  const char *value;
+  const char **argv;
+  int argc;
+};
+
 /* Integrated configuration file. */
 #define INTEGRATE_DEFAULT_CONFIG "Quagga.conf"
 
@@ -256,4 +264,7 @@ extern void vty_hello (struct vty *);
    an async-signal-safe function. */
 extern void vty_log_fixed (char *buf, size_t len);
 
+extern const char *vty_get_arg_value (struct vty_arg **, const char *);
+extern struct vty_arg *vty_get_arg (struct vty_arg **, const char *);
+
 #endif /* _ZEBRA_VTY_H */
diff --git a/lib/zclient.c b/lib/zclient.c
index 9d50ebc..629333d 100644
--- a/lib/zclient.c
+++ b/lib/zclient.c
@@ -543,6 +543,10 @@ zapi_ipv4_route (u_char cmd, struct zclient *zclient, struct prefix_ipv4 *p,
   stream_putc (s, p->prefixlen);
   stream_write (s, (u_char *) & p->prefix, psize);
 
+  /* MPLS label */
+  if (CHECK_FLAG (api->message, ZAPI_MESSAGE_LABEL))
+    stream_putl (s, api->label);
+
   /* Nexthop, ifindex, distance and metric information. */
   if (CHECK_FLAG (api->message, ZAPI_MESSAGE_NEXTHOP))
     {
@@ -607,6 +611,10 @@ zapi_ipv6_route (u_char cmd, struct zclient *zclient, struct prefix_ipv6 *p,
   stream_putc (s, p->prefixlen);
   stream_write (s, (u_char *)&p->prefix, psize);
 
+  /* MPLS label */
+  if (CHECK_FLAG (api->message, ZAPI_MESSAGE_LABEL))
+    stream_putl (s, api->label);
+
   /* Nexthop, ifindex, distance and metric information. */
   if (CHECK_FLAG (api->message, ZAPI_MESSAGE_NEXTHOP))
     {
diff --git a/lib/zclient.h b/lib/zclient.h
index d069eb2..b38ad8e 100644
--- a/lib/zclient.h
+++ b/lib/zclient.h
@@ -97,6 +97,7 @@ struct zclient
 #define ZAPI_MESSAGE_DISTANCE 0x04
 #define ZAPI_MESSAGE_METRIC   0x08
 #define ZAPI_MESSAGE_MTU      0x10
+#define ZAPI_MESSAGE_LABEL    0x20
 
 /* Zserv protocol message header */
 struct zserv_header
@@ -134,6 +135,8 @@ struct zapi_ipv4
 
   u_int32_t mtu;
 
+  u_int32_t label;
+
   vrf_id_t vrf_id;
 };
 
@@ -209,6 +212,8 @@ struct zapi_ipv6
 
   u_int32_t mtu;
 
+  u_int32_t label;
+
   vrf_id_t vrf_id;
 };
 
diff --git a/lib/zebra.h b/lib/zebra.h
index d980283..97aaeae 100644
--- a/lib/zebra.h
+++ b/lib/zebra.h
@@ -415,7 +415,9 @@ struct in_pktinfo
 #define ZEBRA_HELLO                       23
 #define ZEBRA_IPV4_NEXTHOP_LOOKUP_MRIB    24
 #define ZEBRA_VRF_UNREGISTER              25
-#define ZEBRA_MESSAGE_MAX                 26
+#define ZEBRA_MPLS_LSP_ADD                26
+#define ZEBRA_MPLS_LSP_DELETE             27
+#define ZEBRA_MESSAGE_MAX                 28
 
 /* Marker value used in new Zserv, in the byte location corresponding
  * the command value in the old zserv header. To allow old and new
diff --git a/ospf6d/ospf6_network.c b/ospf6d/ospf6_network.c
index a773750..d0c75e5 100644
--- a/ospf6d/ospf6_network.c
+++ b/ospf6d/ospf6_network.c
@@ -155,14 +155,18 @@ ospf6_sendmsg (struct in6_addr *src, struct in6_addr *dst,
   int retval;
   struct msghdr smsghdr;
   struct cmsghdr *scmsgp;
-  u_char cmsgbuf[CMSG_SPACE(sizeof (struct in6_pktinfo))];
+  union
+  {
+    struct cmsghdr hdr;
+    u_char buf[CMSG_SPACE (sizeof (struct in6_pktinfo))];
+  } cmsgbuf;
   struct in6_pktinfo *pktinfo;
   struct sockaddr_in6 dst_sin6;
 
   assert (dst);
   assert (*ifindex);
 
-  scmsgp = (struct cmsghdr *)cmsgbuf;
+  scmsgp = (struct cmsghdr *)&cmsgbuf;
   pktinfo = (struct in6_pktinfo *)(CMSG_DATA(scmsgp));
   memset (&dst_sin6, 0, sizeof (struct sockaddr_in6));
 
@@ -179,7 +183,7 @@ ospf6_sendmsg (struct in6_addr *src, struct in6_addr *dst,
   dst_sin6.sin6_len = sizeof (struct sockaddr_in6);
 #endif /*SIN6_LEN*/
   memcpy (&dst_sin6.sin6_addr, dst, sizeof (struct in6_addr));
-#ifdef HAVE_SIN6_SCOPE_ID
+#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
   dst_sin6.sin6_scope_id = *ifindex;
 #endif
 
@@ -195,8 +199,8 @@ ospf6_sendmsg (struct in6_addr *src, struct in6_addr *dst,
   smsghdr.msg_iovlen = iov_count (message);
   smsghdr.msg_name = (caddr_t) &dst_sin6;
   smsghdr.msg_namelen = sizeof (struct sockaddr_in6);
-  smsghdr.msg_control = (caddr_t) cmsgbuf;
-  smsghdr.msg_controllen = scmsgp->cmsg_len;
+  smsghdr.msg_control = (caddr_t) &cmsgbuf.buf;
+  smsghdr.msg_controllen = sizeof(cmsgbuf.buf);
 
   retval = sendmsg (ospf6_sock, &smsghdr, 0);
   if (retval != iov_totallen (message))
diff --git a/ospfd/ospf_network.c b/ospfd/ospf_network.c
index 02ddf92..633491a 100644
--- a/ospfd/ospf_network.c
+++ b/ospfd/ospf_network.c
@@ -53,7 +53,7 @@ ospf_if_add_allspfrouters (struct ospf *top, struct prefix *p,
   int ret;
   
   ret = setsockopt_ipv4_multicast (top->fd, IP_ADD_MEMBERSHIP,
-                                   htonl (OSPF_ALLSPFROUTERS),
+                                   p->u.prefix4, htonl (OSPF_ALLSPFROUTERS),
                                    ifindex);
   if (ret < 0)
     zlog_warn ("can't setsockopt IP_ADD_MEMBERSHIP (fd %d, addr %s, "
@@ -74,7 +74,7 @@ ospf_if_drop_allspfrouters (struct ospf *top, struct prefix *p,
   int ret;
 
   ret = setsockopt_ipv4_multicast (top->fd, IP_DROP_MEMBERSHIP,
-                                   htonl (OSPF_ALLSPFROUTERS),
+                                   p->u.prefix4, htonl (OSPF_ALLSPFROUTERS),
                                    ifindex);
   if (ret < 0)
     zlog_warn ("can't setsockopt IP_DROP_MEMBERSHIP (fd %d, addr %s, "
@@ -94,7 +94,7 @@ ospf_if_add_alldrouters (struct ospf *top, struct prefix *p, ifindex_t ifindex)
   int ret;
 
   ret = setsockopt_ipv4_multicast (top->fd, IP_ADD_MEMBERSHIP,
-                                   htonl (OSPF_ALLDROUTERS),
+                                   p->u.prefix4, htonl (OSPF_ALLDROUTERS),
                                    ifindex);
   if (ret < 0)
     zlog_warn ("can't setsockopt IP_ADD_MEMBERSHIP (fd %d, addr %s, "
@@ -114,7 +114,7 @@ ospf_if_drop_alldrouters (struct ospf *top, struct prefix *p, ifindex_t ifindex)
   int ret;
 
   ret = setsockopt_ipv4_multicast (top->fd, IP_DROP_MEMBERSHIP,
-                                   htonl (OSPF_ALLDROUTERS),
+                                   p->u.prefix4, htonl (OSPF_ALLDROUTERS),
                                    ifindex);
   if (ret < 0)
     zlog_warn ("can't setsockopt IP_DROP_MEMBERSHIP (fd %d, addr %s, "
@@ -149,7 +149,7 @@ ospf_if_ipmulticast (struct ospf *top, struct prefix *p, ifindex_t ifindex)
     zlog_warn ("can't setsockopt IP_MULTICAST_TTL(1) for fd %d: %s",
 	       top->fd, safe_strerror (errno));
 
-  ret = setsockopt_ipv4_multicast_if (top->fd, ifindex);
+  ret = setsockopt_ipv4_multicast_if (top->fd, p->u.prefix4, ifindex);
   if (ret < 0)
     zlog_warn("can't setsockopt IP_MULTICAST_IF(fd %d, addr %s, "
 	      "ifindex %u): %s",
diff --git a/redhat/Makefile.am b/redhat/Makefile.am
index fadfe64..c4a234c 100644
--- a/redhat/Makefile.am
+++ b/redhat/Makefile.am
@@ -1,7 +1,7 @@
 
 EXTRA_DIST = bgpd.init bgpd.service isisd.init \
 	isisd.service ospf6d.init ospf6d.service ospfd.init ospfd.service \
-	quagga.logrotate quagga.pam quagga.spec \
+	quagga.logrotate quagga.pam quagga.spec ldpd.init ldpd.service \
 	quagga.sysconfig ripd.init ripd.service ripngd.init ripngd.service \
 	watchquagga.init pimd.init pimd.service zebra.init zebra.service \
 	README.rpm_build.md
diff --git a/redhat/README.rpm_build.md b/redhat/README.rpm_build.md
index 3e8fa05..b456b71 100644
--- a/redhat/README.rpm_build.md
+++ b/redhat/README.rpm_build.md
@@ -52,6 +52,7 @@ Building your own Quagga RPM
 		%{!?with_rtadv:        %global  with_rtadv      1 }
 		%{!?with_isisd:        %global  with_isisd      1 }
 		%{!?with_pimd:         %global  with_pimd       1 }
+		%{!?with_ldpd:         %global  with_ldpd       0 }
 		%{!?with_shared:       %global  with_shared     1 }
 		%{!?with_multipath:    %global  with_multipath  64 }
 		%{!?quagga_user:       %global  quagga_user     quagga }
diff --git a/redhat/ldpd.init b/redhat/ldpd.init
new file mode 100644
index 0000000..b9b9538
--- /dev/null
+++ b/redhat/ldpd.init
@@ -0,0 +1,72 @@
+#!/bin/bash
+# chkconfig: - 16 84
+# config: /etc/quagga/ldpd.conf
+
+### BEGIN INIT INFO
+# Provides: ldpd
+# Short-Description: LDP engine
+# Description: LDP engine for use with Zebra
+### END INIT INFO
+
+# source function library
+. /etc/rc.d/init.d/functions
+
+# Get network config
+. /etc/sysconfig/network
+
+# quagga command line options
+. /etc/sysconfig/quagga
+
+RETVAL=0
+PROG="ldpd"
+cmd=ldpd
+LOCK_FILE=/var/lock/subsys/ldpd
+CONF_FILE=/etc/quagga/ldpd.conf
+
+case "$1" in
+  start)
+	# Check that networking is up.
+	[ "${NETWORKING}" = "no" ] && exit 1
+
+	# The process must be configured first.
+	[ -f $CONF_FILE ] || exit 6
+	if [ `id -u` -ne 0 ]; then
+		echo $"Insufficient privilege" 1>&2
+		exit 4
+	fi
+
+	echo -n $"Starting $PROG: "
+	daemon $cmd -d $LDPD_OPTS -f $CONF_FILE
+	RETVAL=$?
+	[ $RETVAL -eq 0 ] && touch $LOCK_FILE
+	echo
+	;;
+  stop)
+	echo -n $"Shutting down $PROG: "
+	killproc $cmd
+	RETVAL=$?
+	[ $RETVAL -eq 0 ] && rm -f $LOCK_FILE
+	echo
+	;;
+  restart|reload|force-reload)
+	$0 stop
+	$0 start
+	RETVAL=$?
+	;;
+  condrestart|try-restart)
+	if [ -f $LOCK_FILE ]; then
+		$0 stop
+		$0 start
+	fi
+	RETVAL=$?
+	;;
+  status)
+	status $cmd
+	RETVAL=$?
+	;;
+  *)
+	echo $"Usage: $0 {start|stop|restart|reload|force-reload|condrestart|try-restart|status}"
+	exit 2
+esac
+
+exit $RETVAL
diff --git a/redhat/ldpd.service b/redhat/ldpd.service
new file mode 100644
index 0000000..22421de
--- /dev/null
+++ b/redhat/ldpd.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=LDP daemon
+BindTo=zebra.service
+After=syslog.target network.target zebra.service
+ConditionPathExists=/etc/quagga/ldpd.conf
+
+[Service]
+Type=forking
+EnvironmentFile=/etc/sysconfig/quagga
+ExecStart=/usr/sbin/ldpd -d $LDPD_OPTS -f /etc/quagga/ldpd.conf
+Restart=on-abort
+
+[Install]
+WantedBy=network.target
diff --git a/redhat/quagga.logrotate b/redhat/quagga.logrotate
index afbd40c..1f1baea 100644
--- a/redhat/quagga.logrotate
+++ b/redhat/quagga.logrotate
@@ -53,3 +53,11 @@
 	/bin/kill -USR1 `cat /var/run/quagga/ripngd.pid 2> /dev/null` 2> /dev/null || true
     endscript
 }
+
+/var/log/quagga/ldpd.log {
+    notifempty
+    missingok
+    postrotate
+	/bin/kill -USR1 `cat /var/run/quagga/ldpd.pid 2> /dev/null` 2> /dev/null || true
+    endscript
+}
diff --git a/redhat/quagga.spec.in b/redhat/quagga.spec.in
index a1263d1..9cc2bd2 100644
--- a/redhat/quagga.spec.in
+++ b/redhat/quagga.spec.in
@@ -21,6 +21,7 @@
 %{!?with_rtadv:			%global	with_rtadv		1 }
 %{!?with_isisd:			%global	with_isisd		1 }
 %{!?with_pimd:			%global	with_pimd		1 }
+%{!?with_ldpd:			%global	with_ldpd		0 }
 %{!?with_shared:		%global	with_shared		1 }
 %{!?with_multipath:		%global	with_multipath		64 }
 %{!?quagga_user:		%global	quagga_user		quagga }
@@ -87,13 +88,19 @@
 %define		daemon_pimd	""
 %endif
 
+%if %{with_ldpd}
+%define         daemon_ldpd	ldpd
+%else
+%define		daemon_ldpd	""
+%endif
+
 %if %{with_watchquagga}
 %define         daemon_watchquagga	watchquagga
 %else
 %define		daemon_watchquagga	""
 %endif
 
-%define		all_daemons	%{daemon_list} %{daemonv6_list} %{daemon_isisd} %{daemon_pimd} %{daemon_watchquagga}
+%define		all_daemons	%{daemon_list} %{daemonv6_list} %{daemon_isisd} %{daemon_pimd} %{daemon_ldpd} %{daemon_watchquagga}
 
 # allow build dir to be kept
 %{!?keep_build:		%global		keep_build	0 }
@@ -229,6 +236,11 @@ developing OSPF-API and quagga applications.
 %else
 	--disable-isisd \
 %endif
+%if %{with_ldpd}
+	--enable-ldpd \
+%else
+	--disable-ldpd \
+%endif
 %if %{with_pam}
 	--with-libpam \
 %endif
@@ -345,6 +357,9 @@ zebra_spec_add_service isisd    2608/tcp "ISISd vty"
 %if %{with_pimd}
 zebra_spec_add_service pimd     2611/tcp "PIMd vty"
 %endif
+%if %{with_ldpd}
+zebra_spec_add_service ldpd     2612/tcp "LDPd vty"
+%endif
 
 %if "%{initsystem}" == "systemd"
 for daemon in %all_daemons ; do
@@ -519,6 +534,9 @@ rm -rf %{buildroot}
 %if %{with_pimd}
 %{_sbindir}/pimd
 %endif
+%if %{with_ldpd}
+%{_sbindir}/ldpd
+%endif
 %if %{with_isisd}
 %{_sbindir}/isisd
 %endif
@@ -548,6 +566,9 @@ rm -rf %{buildroot}
 	%if %{with_pimd}
 		%config /etc/rc.d/init.d/pimd
 	%endif
+	%if %{with_ldpd}
+		%config /etc/rc.d/init.d/ldpd
+	%endif
 %endif
 %config(noreplace) /etc/sysconfig/quagga
 %config(noreplace) /etc/pam.d/quagga
diff --git a/redhat/quagga.sysconfig b/redhat/quagga.sysconfig
index caa0fff..41a9693 100644
--- a/redhat/quagga.sysconfig
+++ b/redhat/quagga.sysconfig
@@ -10,6 +10,7 @@ RIPD_OPTS="-A 127.0.0.1"
 RIPNGD_OPTS="-A ::1"
 ZEBRA_OPTS="-A 127.0.0.1"
 PIMD_OPTS="-A 127.0.0.1"
+LDPD_OPTS="-A 127.0.0.1"
 
 # Watchquagga configuration for LSB initscripts
 #
diff --git a/ripd/rip_interface.c b/ripd/rip_interface.c
index 7bdcf46..ac394ca 100644
--- a/ripd/rip_interface.c
+++ b/ripd/rip_interface.c
@@ -80,6 +80,7 @@ ipv4_multicast_join (int sock,
 
   ret = setsockopt_ipv4_multicast (sock,
 				   IP_ADD_MEMBERSHIP, 
+				   ifa,
 				   group.s_addr, 
 				   ifindex); 
 
@@ -101,6 +102,7 @@ ipv4_multicast_leave (int sock,
 
   ret = setsockopt_ipv4_multicast (sock,
 				   IP_DROP_MEMBERSHIP, 
+				   ifa,
 				   group.s_addr, 
 				   ifindex);
 
@@ -136,9 +138,13 @@ rip_interface_new (void)
 void
 rip_interface_multicast_set (int sock, struct connected *connected)
 {
+  struct in_addr addr;
+
   assert (connected != NULL);
-  
-  if (setsockopt_ipv4_multicast_if (sock, connected->ifp->ifindex) < 0)
+
+  addr = CONNECTED_ID(connected)->u.prefix4;
+
+  if (setsockopt_ipv4_multicast_if (sock, addr, connected->ifp->ifindex) < 0)
     {
       zlog_warn ("Can't setsockopt IP_MULTICAST_IF on fd %d to "
 		 "ifindex %d for interface %s",
diff --git a/tools/xml2cli.pl b/tools/xml2cli.pl
new file mode 100755
index 0000000..91312cf
--- /dev/null
+++ b/tools/xml2cli.pl
@@ -0,0 +1,431 @@
+#!/usr/bin/perl
+##
+## Parse a XML file containing a tree-like representation of Quagga CLI
+## commands and generate a file with:
+##
+## - a DEFUN function for each command;
+## - an initialization function.
+##
+##
+## Copyright (C) 2012 Renato Westphal <renatow@digistar.com.br>
+## This file is part of GNU Zebra.
+##
+## GNU Zebra is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 2, or (at your option) any
+## later version.
+##
+## GNU Zebra is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with GNU Zebra; see the file COPYING.  If not, write to the Free
+## Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+## 02111-1307, USA.
+##
+
+use strict;
+use warnings;
+use Getopt::Std;
+use vars qw($opt_d);
+use File::Basename qw(fileparse);
+use XML::LibXML;
+
+%::input_strs = (
+		"ifname"		=> "IFNAME",
+		"word"			=> "WORD",
+		"line"			=> ".LINE",
+		"ipv4"			=> "A.B.C.D",
+		"ipv4m"			=> "A.B.C.D/M",
+		"ipv6"			=> "X:X::X:X",
+		"ipv6m"			=> "X:X::X:X/M",
+		"mtu"			=> "<1500-9180>",
+		# BGP specific
+		"rd"			=> "ASN:nn_or_IP-address:nn",
+		"asn"			=> "<1-4294967295>",
+		"community"		=> "AA:NN",
+		"clist"			=> "<1-500>",
+		# LDP specific
+		"disc_time"		=> "<1-65535>",
+		"session_time"		=> "<15-65535>",
+		"pwid"			=> "<1-4294967295>"
+		);
+
+# parse options node and store the corresponding information
+# into a global hash of hashes
+sub parse_options {
+	my $xml_node = $_[0];
+	my @cmdstr;
+
+	my $options_name = $xml_node->findvalue('./@name');
+	if (not $options_name) {
+		die('error: "options" node without "name" attribute');
+	}
+
+	# initialize hash
+	$::options{$options_name}{'cmdstr'} = "";
+	$::options{$options_name}{'help'} = "";
+
+	my @children = $xml_node->getChildnodes();
+	foreach my $child(@children) {
+		# skip comments, random text, etc
+		if ($child->getType() != XML_ELEMENT_NODE) {
+			next;
+		}
+
+		# check for error/special conditions
+		if ($child->getName() ne "option") {
+			die('error: invalid node type: "' . $child->getName() . '"');
+		}
+
+		my $name = $child->findvalue('./@name');
+		my $input = $child->findvalue('./@input');
+		my $help = $child->findvalue('./@help');
+		if ($input) {
+			$name = $::input_strs{$input};
+		}
+
+		push (@cmdstr, $name);
+		$::options{$options_name}{'help'} .= "\n       \"" . $help . "\\n\"";
+	}
+	$::options{$options_name}{'cmdstr'} = "(" . join('|', @cmdstr) . ")";
+}
+
+# given a subtree, replace all the corresponding include nodes by
+# this subtree
+sub subtree_replace_includes {
+	my $subtree = $_[0];
+
+	my $subtree_name = $subtree->findvalue('./@name');
+	if (not $subtree_name) {
+		die("subtree without \"name\" attribute");
+	}
+
+	my $query = "//include[\@subtree='$subtree_name']";
+	foreach my $include_node($::xml->findnodes($query)) {
+		my @children = $subtree->getChildnodes();
+		foreach my $child(reverse @children) {
+			my $include_node_parent = $include_node->getParentNode();
+			$include_node_parent->insertAfter($child->cloneNode(1),
+					$include_node);
+		}
+		$include_node->unbindNode();
+	}
+	$subtree->unbindNode();
+}
+
+# generate arguments for a given command
+sub generate_arguments {
+	my @nodes = @_;
+	my $arguments;
+	my $no_args = 1;
+	my $argc = 0;
+
+	$arguments .= "  struct vty_arg *args[] =\n";
+	$arguments .= "    {\n";
+	for (my $i = 0; $i < @nodes; $i++) {
+		my %node = %{$nodes[$i]};
+		my $arg_value;
+
+		if (not $node{'arg'}) {
+			next;
+		}
+		$no_args = 0;
+
+		# for input and select nodes, the value of the argument is an
+		# argv[] element. for the other types of nodes, the value of the
+		# argument is the name of the node
+		if ($node{'input'} or $node{'type'} eq "select") {
+			$arg_value = "argv[" . $argc++ . "]";
+		} else {
+			$arg_value = '"' . $node{'name'} . '"';
+		}
+
+		if ($node{'input'} and $node{'input'} eq "line") {
+			# arguments of the type 'line' may have multiple spaces (i.e
+			# they don't fit into a single argv[] element).	to properly
+			# handle these arguments, we need to provide direct access
+			# to the argv[] array and the argc variable.
+			my $argc_str = "argc" . (($argc > 1) ? " - " . ($argc - 1) : "");
+			my $argv_str = "argv" . (($argc > 1) ? " + " . ($argc - 1) : "");
+			$arguments .= "      &(struct vty_arg) { "
+				. ".name = \"" . $node{'arg'} . "\", "
+				. ".argc = $argc_str, "
+				. ".argv = $argv_str },\n";
+		} else {
+			# common case - each argument has a name and a single value
+			$arguments .= "      &(struct vty_arg) { "
+				. ".name = \"" . $node{'arg'} . "\", "
+				. ".value = " . $arg_value . " },\n";
+		}
+	}
+	$arguments .= "      NULL\n";
+	$arguments .= "    };\n";
+
+	# handle special case
+	if ($no_args) {
+		return "  struct vty_arg *args[] = { NULL };\n";
+	}
+
+	return $arguments;
+}
+
+# generate C code
+sub generate_code {
+	my @nodes = @_;
+	my $funcname = '';
+	my $cmdstr = '';
+	my $cmdname = '';
+	my $helpstr = '';
+	my $function = '';
+
+	for (my $i = 0; $i < @nodes; $i++) {
+		my %node = %{$nodes[$i]};
+		if ($node{'input'}) {
+			$funcname .= $node{'input'} . " ";
+			$cmdstr .= $::input_strs{$node{'input'}} . " ";
+			$helpstr .= "\n       \"" . $node{'help'} . "\\n\"";
+		} elsif ($node{'type'} eq "select") {
+			my $options_name = $node{'options'};
+			$funcname .= $options_name . " ";
+			$cmdstr .= $::options{$options_name}{'cmdstr'} . " ";
+			$helpstr .= $::options{$options_name}{'help'};
+		} else {
+			$funcname .= $node{'name'} . " ";
+			$cmdstr .= $node{'name'} . " ";
+			$helpstr .= "\n       \"" . $node{'help'} . "\\n\"";
+		}
+
+		# update the command string
+		if ($node{'function'} ne "inherited") {
+			$function = $node{'function'};
+		}
+	}
+
+	# rtrim
+	$funcname =~ s/\s+$//;
+	$cmdstr =~ s/\s+$//;
+	# lowercase
+	$funcname = lc($funcname);
+	# replace " " by "_"
+	$funcname =~ tr/ /_/;
+	# replace "-" by "_"
+	$funcname =~ tr/-/_/;
+	# add prefix
+	$funcname = $::cmdprefix . '_' . $funcname;
+
+	# generate DEFUN
+	$cmdname = $funcname . "_cmd";
+
+	# don't generate same command more than once
+	if ($::commands{$cmdname}) {
+		return $cmdname;
+	}
+	$::commands{$cmdname} = "1";
+
+	print STDOUT "DEFUN (" . $funcname . ",\n"
+		   . "       " . $cmdname . ",\n"
+		   . "       \"" . $cmdstr . "\","
+		   . $helpstr . ")\n"
+		   . "{\n"
+		   . generate_arguments(@nodes)
+		   . "  return " . $function . " (vty, args);\n"
+		   . "}\n\n";
+
+	return $cmdname;
+}
+
+# parse tree node (recursive function)
+sub parse_tree {
+	# get args
+	my $xml_node = $_[0];
+	my @nodes = @{$_[1]};
+	my $tree_name = $_[2];
+
+	# hash containing all the node attributes
+	my %node;
+	$node{'type'} = $xml_node->getName();
+
+	# check for error/special conditions
+	if ($node{'type'} eq "tree") {
+		goto end;
+	}
+	if ($node{'type'} eq "include") {
+		die('error: can not include "'
+				. $xml_node->findvalue('./@subtree') . '"');
+	}
+	if (not $node{'type'} ~~ [qw(option select)]) {
+		die('error: invalid node type: "' . $node{'type'} . '"');
+	}
+	if ($node{'type'} eq "select") {
+		my $options_name = $xml_node->findvalue('./@options');
+		if (not $options_name) {
+			die('error: "select" node without "name" attribute');
+		}
+		if (not $::options{$options_name}) {
+			die('error: can not find options');
+		}
+		$node{'options'} = $options_name;
+	}
+
+	# get node attributes
+	$node{'name'} = $xml_node->findvalue('./@name');
+	$node{'input'} = $xml_node->findvalue('./@input');
+	$node{'arg'} = $xml_node->findvalue('./@arg');
+	$node{'help'} = $xml_node->findvalue('./@help');
+	$node{'function'} = $xml_node->findvalue('./@function');
+	$node{'ifdef'} = $xml_node->findvalue('./@ifdef');
+
+	# push node to stack
+	push (@nodes, \%node);
+
+	# generate C code
+	if ($node{'function'}) {
+		my $cmdname = generate_code(@nodes);
+		push (@{$::trees{$tree_name}}, [0, $cmdname, 0]);
+	}
+
+	if ($node{'ifdef'}) {
+		push (@{$::trees{$tree_name}}, [$node{'ifdef'}, 0, 0]);
+	}
+
+end:
+	# recursively process child nodes
+	my @children = $xml_node->getChildnodes();
+	foreach my $child(@children) {
+		# skip comments, random text, etc
+		if ($child->getType() != XML_ELEMENT_NODE) {
+			next;
+		}
+		parse_tree($child, \@nodes, $tree_name);
+	}
+
+	if ($node{'ifdef'}) {
+		push (@{$::trees{$tree_name}}, [0, 0, $node{'ifdef'}]);
+	}
+}
+
+sub parse_node {
+	# get args
+	my $xml_node = $_[0];
+
+	my $node_name = $xml_node->findvalue('./@name');
+	if (not $node_name) {
+		die('missing the "name" attribute');
+	}
+
+	my $install = $xml_node->findvalue('./@install');
+	my $config_write = $xml_node->findvalue('./@config_write');
+	if ($install and $install eq "1") {
+		print "  install_node (&" .lc( $node_name) . "_node, " . $config_write . ");\n";
+  		print "  install_default (" . $node_name . "_NODE);\n";
+	}
+
+	my @children = $xml_node->getChildnodes();
+	foreach my $child(@children) {
+		# skip comments, random text, etc
+		if ($child->getType() != XML_ELEMENT_NODE) {
+			next;
+		}
+
+		if ($child->getName() ne "include") {
+			die('error: invalid node type: "' . $child->getName() . '"');
+		}
+		my $tree_name = $child->findvalue('./@tree');
+		if (not $tree_name) {
+			die('missing the "tree" attribute');
+		}
+
+		foreach my $entry (@{$::trees{$tree_name}}) {
+			my ($ifdef, $cmdname, $endif) = @{$entry};
+
+			if ($ifdef) {
+				print ("#ifdef " . $ifdef . "\n");
+			}
+
+			if ($cmdname) {
+				print "  install_element (" . $node_name . "_NODE, &" . $cmdname . ");\n";
+			}
+
+			if ($endif) {
+				print ("#endif /* " . $endif . " */\n");
+			}
+		}
+	}
+}
+
+# parse command-line arguments
+if (not getopts('d')) {
+	die("Usage: xml2cli.pl [-d] FILE\n");
+}
+my $file = shift;
+
+# initialize the XML parser
+my $parser = new XML::LibXML;
+$parser->keep_blanks(0);
+
+# parse XML file
+$::xml = $parser->parse_file($file);
+my $xmlroot = $::xml->getDocumentElement();
+if ($xmlroot->getName() ne "file") {
+	die('XML root element name must be "file"');
+}
+
+# read file attributes
+my $init_function = $xmlroot->findvalue('./@init');
+if (not $init_function) {
+	die('missing the "init" attribute in the "file" node');
+}
+$::cmdprefix = $xmlroot->findvalue('./@cmdprefix');
+if (not $::cmdprefix) {
+	die('missing the "cmdprefix" attribute in the "file" node');
+}
+my $header = $xmlroot->findvalue('./@header');
+if (not $header) {
+	die('missing the "header" attribute in the "file" node');
+}
+
+# generate source header
+print STDOUT "/* Auto-generated from " . fileparse($file) . ". */\n"
+	   . "/* Do not edit! */\n\n"
+	   . "#include <zebra.h>\n\n"
+	   . "#include \"command.h\"\n"
+	   . "#include \"vty.h\"\n"
+	   . "#include \"$header\"\n\n";
+
+# Parse options
+foreach my $options($::xml->findnodes("/file/options")) {
+	parse_options($options);
+}
+
+# replace include nodes by the corresponding subtrees
+foreach my $subtree(reverse $::xml->findnodes("/file/subtree")) {
+	subtree_replace_includes($subtree);
+}
+
+# Parse trees
+foreach my $tree($::xml->findnodes("/file/tree")) {
+	my @nodes = ();
+	my $tree_name = $tree->findvalue('./@name');
+	parse_tree($tree, \@nodes, $tree_name);
+}
+
+# install function header
+print STDOUT "void\n"
+	   . $init_function . " (void)\n"
+	   . "{\n";
+
+# Parse nodes
+foreach my $node($::xml->findnodes("/file/node")) {
+	parse_node($node);
+}
+
+# closing braces for the install function
+print STDOUT "}";
+
+# print to stderr the expanded XML file if the debug flag (-d) is given
+if ($opt_d) {
+	print STDERR $::xml->toString(1);
+}
diff --git a/vtysh/Makefile.am b/vtysh/Makefile.am
index d347735..87488c1 100644
--- a/vtysh/Makefile.am
+++ b/vtysh/Makefile.am
@@ -22,6 +22,7 @@ EXTRA_DIST = extract.pl
 
 vtysh_cmd_FILES = $(top_srcdir)/bgpd/*.c $(top_srcdir)/isisd/*.c \
 		  $(top_srcdir)/ospfd/*.c $(top_srcdir)/ospf6d/*.c \
+		  $(top_srcdir)/ldpd/ldp_vty_cmds.c \
 		  $(top_srcdir)/ripd/*.c $(top_srcdir)/ripngd/*.c \
 		  $(top_srcdir)/pimd/pim_cmd.c \
 		  $(top_srcdir)/lib/keychain.c $(top_srcdir)/lib/routemap.c \
diff --git a/vtysh/extract.pl.in b/vtysh/extract.pl.in
index ca869b6..697f6bf 100755
--- a/vtysh/extract.pl.in
+++ b/vtysh/extract.pl.in
@@ -38,6 +38,9 @@ $ignore{'"router ripng"'} = "ignore";
 $ignore{'"router ospf"'} = "ignore";
 $ignore{'"router ospf <0-65535>"'} = "ignore";
 $ignore{'"router ospf6"'} = "ignore";
+$ignore{'"mpls ldp"'} = "ignore";
+$ignore{'"l2vpn WORD type vpls"'} = "ignore";
+$ignore{'"member pseudowire IFNAME"'} = "ignore";
 $ignore{'"router bgp " "<1-4294967295>"'} = "ignore";
 $ignore{'"router bgp " "<1-4294967295>" " view WORD"'} = "ignore";
 $ignore{'"router isis WORD"'} = "ignore";
diff --git a/vtysh/vtysh.c b/vtysh/vtysh.c
index 63b596a..4be8c47 100644
--- a/vtysh/vtysh.c
+++ b/vtysh/vtysh.c
@@ -57,6 +57,7 @@ struct vtysh_client
   { .fd = -1, .name = "ripngd", .flag = VTYSH_RIPNGD, .path = RIPNG_VTYSH_PATH},
   { .fd = -1, .name = "ospfd", .flag = VTYSH_OSPFD, .path = OSPF_VTYSH_PATH},
   { .fd = -1, .name = "ospf6d", .flag = VTYSH_OSPF6D, .path = OSPF6_VTYSH_PATH},
+  { .fd = -1, .name = "ldpd", .flag = VTYSH_LDPD, .path = LDP_VTYSH_PATH},
   { .fd = -1, .name = "bgpd", .flag = VTYSH_BGPD, .path = BGP_VTYSH_PATH},
   { .fd = -1, .name = "isisd", .flag = VTYSH_ISISD, .path = ISIS_VTYSH_PATH},
   { .fd = -1, .name = "pimd", .flag = VTYSH_PIMD, .path = PIM_VTYSH_PATH},
@@ -746,6 +747,48 @@ static struct cmd_node ospf6_node =
   "%s(config-ospf6)# "
 };
 
+static struct cmd_node ldp_node =
+{
+  LDP_NODE,
+  "%s(config-ldp)# "
+};
+
+static struct cmd_node ldp_ipv4_node =
+{
+  LDP_IPV4_NODE,
+  "%s(config-ldp-af)# "
+};
+
+static struct cmd_node ldp_ipv6_node =
+{
+  LDP_IPV6_NODE,
+  "%s(config-ldp-af)# "
+};
+
+static struct cmd_node ldp_ipv4_iface_node =
+{
+  LDP_IPV4_IFACE_NODE,
+  "%s(config-ldp-af-if)# "
+};
+
+static struct cmd_node ldp_ipv6_iface_node =
+{
+  LDP_IPV6_IFACE_NODE,
+  "%s(config-ldp-af-if)# "
+};
+
+static struct cmd_node ldp_l2vpn_node =
+{
+  LDP_L2VPN_NODE,
+  "%s(config-l2vpn)# "
+};
+
+static struct cmd_node ldp_pseudowire_node =
+{
+  LDP_PSEUDOWIRE_NODE,
+  "%s(config-l2vpn-pw)# "
+};
+
 static struct cmd_node babel_node =
 {
   BABEL_NODE,
@@ -1020,6 +1063,86 @@ DEFUNSH (VTYSH_OSPF6D,
   return CMD_SUCCESS;
 }
 
+DEFUNSH (VTYSH_LDPD,
+	 ldp_mpls_ldp,
+	 ldp_mpls_ldp_cmd,
+	 "mpls ldp",
+	 "Global MPLS configuration subcommands\n"
+	 "Label Distribution Protocol\n")
+{
+  vty->node = LDP_NODE;
+  return CMD_SUCCESS;
+}
+
+DEFUNSH (VTYSH_LDPD,
+	 ldp_address_family_ipv4,
+	 ldp_address_family_ipv4_cmd,
+	 "address-family ipv4",
+	 "Configure Address Family and its parameters\n"
+	 "IPv4\n")
+{
+  vty->node = LDP_IPV4_NODE;
+  return CMD_SUCCESS;
+}
+
+DEFUNSH (VTYSH_LDPD,
+	 ldp_address_family_ipv6,
+	 ldp_address_family_ipv6_cmd,
+	 "address-family ipv6",
+	 "Configure Address Family and its parameters\n"
+	 "IPv6\n")
+{
+  vty->node = LDP_IPV6_NODE;
+  return CMD_SUCCESS;
+}
+
+DEFUNSH (VTYSH_LDPD,
+	 ldp_interface_ifname,
+	 ldp_interface_ifname_cmd,
+	 "interface IFNAME",
+	 "Enable LDP on an interface and enter interface submode\n"
+	 "Interface's name\n")
+{
+  switch (vty->node)
+    {
+      case LDP_IPV4_NODE:
+	vty->node = LDP_IPV4_IFACE_NODE;
+	break;
+      case LDP_IPV6_NODE:
+	vty->node = LDP_IPV6_IFACE_NODE;
+	break;
+      default:
+	break;
+    }
+
+  return CMD_SUCCESS;
+}
+
+DEFUNSH (VTYSH_LDPD,
+	 ldp_l2vpn_word_type_vpls,
+	 ldp_l2vpn_word_type_vpls_cmd,
+	 "l2vpn WORD type vpls",
+	 "Configure l2vpn commands\n"
+	 "L2VPN name\n"
+	 "L2VPN type\n"
+	 "Virtual Private LAN Service\n")
+{
+  vty->node = LDP_L2VPN_NODE;
+  return CMD_SUCCESS;
+}
+
+DEFUNSH (VTYSH_LDPD,
+	 ldp_member_pseudowire_ifname,
+	 ldp_member_pseudowire_ifname_cmd,
+	 "member pseudowire IFNAME",
+	 "L2VPN member configuration\n"
+	 "Pseudowire interface\n"
+	 "Interface's name\n")
+{
+  vty->node = LDP_PSEUDOWIRE_NODE;
+  return CMD_SUCCESS;
+}
+
 DEFUNSH (VTYSH_ISISD,
 	 router_isis,
 	 router_isis_cmd,
@@ -1108,6 +1231,8 @@ vtysh_exit (struct vty *vty)
     case RIPNG_NODE:
     case OSPF_NODE:
     case OSPF6_NODE:
+    case LDP_NODE:
+    case LDP_L2VPN_NODE:
     case BABEL_NODE:
     case ISIS_NODE:
     case MASC_NODE:
@@ -1128,6 +1253,19 @@ vtysh_exit (struct vty *vty)
     case BGP_IPV6M_NODE:
       vty->node = BGP_NODE;
       break;
+    case LDP_IPV4_NODE:
+    case LDP_IPV6_NODE:
+      vty->node = LDP_NODE;
+      break;
+    case LDP_IPV4_IFACE_NODE:
+      vty->node = LDP_IPV4_NODE;
+      break;
+    case LDP_IPV6_IFACE_NODE:
+      vty->node = LDP_IPV6_NODE;
+      break;
+    case LDP_PSEUDOWIRE_NODE:
+      vty->node = LDP_L2VPN_NODE;
+      break;
     case KEYCHAIN_KEY_NODE:
       vty->node = KEYCHAIN_NODE;
       break;
@@ -1267,6 +1405,20 @@ ALIAS (vtysh_exit_ospf6d,
        "quit",
        "Exit current mode and down to previous mode\n")
 
+DEFUNSH (VTYSH_LDPD,
+	 vtysh_exit_ldpd,
+	 vtysh_exit_ldpd_cmd,
+	 "exit",
+	 "Exit current mode and down to previous mode\n")
+{
+  return vtysh_exit (vty);
+}
+
+ALIAS (vtysh_exit_ldpd,
+       vtysh_quit_ldpd_cmd,
+       "quit",
+       "Exit current mode and down to previous mode\n")
+
 DEFUNSH (VTYSH_ISISD,
 	 vtysh_exit_isisd,
 	 vtysh_exit_isisd_cmd,
@@ -1315,7 +1467,7 @@ ALIAS_SH (VTYSH_ZEBRA,
 	 VRF_CMD_HELP_STR)
 
 /* TODO Implement "no interface command in isisd. */
-DEFSH (VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D,
+DEFSH (VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_LDPD,
        vtysh_no_interface_cmd,
        "no interface IFNAME",
        NO_STR
@@ -1332,7 +1484,7 @@ DEFSH (VTYSH_ZEBRA,
 
 /* TODO Implement interface description commands in ripngd, ospf6d
  * and isisd. */
-DEFSH (VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_OSPFD,
+DEFSH (VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_OSPFD|VTYSH_LDPD,
        interface_desc_cmd,
        "description .LINE",
        "Interface specific description\n"
@@ -1819,7 +1971,7 @@ DEFUN (vtysh_write_terminal,
 
 DEFUN (vtysh_write_terminal_daemon,
        vtysh_write_terminal_daemon_cmd,
-       "write terminal (zebra|ripd|ripngd|ospfd|ospf6d|bgpd|isisd|babeld)",
+       "write terminal (zebra|ripd|ripngd|ospfd|ospf6d|ldpd|bgpd|isisd|babeld)",
        "Write running configuration to memory, network, or terminal\n"
        "Write to terminal\n"
        "For the zebra daemon\n"
@@ -1827,6 +1979,7 @@ DEFUN (vtysh_write_terminal_daemon,
        "For the ripng daemon\n"
        "For the ospf daemon\n"
        "For the ospfv6 daemon\n"
+       "For the ldp daemon\n"
        "For the bgp daemon\n"
        "For the isis daemon\n"
        "For the babel daemon\n")
@@ -1965,7 +2118,7 @@ ALIAS (vtysh_write_terminal,
 
 ALIAS (vtysh_write_terminal_daemon,
        vtysh_show_running_config_daemon_cmd,
-       "show running-config (zebra|ripd|ripngd|ospfd|ospf6d|bgpd|isisd|babeld)",
+       "show running-config (zebra|ripd|ripngd|ospfd|ospf6d|ldpd|bgpd|isisd|babeld)",
        SHOW_STR
        "Current operating configuration\n"
        "For the zebra daemon\n"
@@ -1973,6 +2126,7 @@ ALIAS (vtysh_write_terminal_daemon,
        "For the ripng daemon\n"
        "For the ospf daemon\n"
        "For the ospfv6 daemon\n"
+       "For the ldp daemon\n"
        "For the bgp daemon\n"
        "For the isis daemon\n"
        "For the babel daemon\n")
@@ -2371,6 +2525,13 @@ vtysh_init_vty (void)
   install_node (&ripng_node, NULL);
   install_node (&ospf6_node, NULL);
 /* #endif */
+  install_node (&ldp_node, NULL);
+  install_node (&ldp_ipv4_node, NULL);
+  install_node (&ldp_ipv6_node, NULL);
+  install_node (&ldp_ipv4_iface_node, NULL);
+  install_node (&ldp_ipv6_iface_node, NULL);
+  install_node (&ldp_l2vpn_node, NULL);
+  install_node (&ldp_pseudowire_node, NULL);
   install_node (&babel_node, NULL);
   install_node (&keychain_node, NULL);
   install_node (&keychain_key_node, NULL);
@@ -2396,6 +2557,13 @@ vtysh_init_vty (void)
   vtysh_install_default (OSPF_NODE);
   vtysh_install_default (RIPNG_NODE);
   vtysh_install_default (OSPF6_NODE);
+  vtysh_install_default (LDP_NODE);
+  vtysh_install_default (LDP_IPV4_NODE);
+  vtysh_install_default (LDP_IPV6_NODE);
+  vtysh_install_default (LDP_IPV4_IFACE_NODE);
+  vtysh_install_default (LDP_IPV6_IFACE_NODE);
+  vtysh_install_default (LDP_L2VPN_NODE);
+  vtysh_install_default (LDP_PSEUDOWIRE_NODE);
   vtysh_install_default (BABEL_NODE);
   vtysh_install_default (ISIS_NODE);
   vtysh_install_default (KEYCHAIN_NODE);
@@ -2421,6 +2589,20 @@ vtysh_init_vty (void)
   install_element (OSPF_NODE, &vtysh_quit_ospfd_cmd);
   install_element (OSPF6_NODE, &vtysh_exit_ospf6d_cmd);
   install_element (OSPF6_NODE, &vtysh_quit_ospf6d_cmd);
+  install_element (LDP_NODE, &vtysh_exit_ldpd_cmd);
+  install_element (LDP_NODE, &vtysh_quit_ldpd_cmd);
+  install_element (LDP_IPV4_NODE, &vtysh_exit_ldpd_cmd);
+  install_element (LDP_IPV4_NODE, &vtysh_quit_ldpd_cmd);
+  install_element (LDP_IPV6_NODE, &vtysh_exit_ldpd_cmd);
+  install_element (LDP_IPV6_NODE, &vtysh_quit_ldpd_cmd);
+  install_element (LDP_IPV4_IFACE_NODE, &vtysh_exit_ldpd_cmd);
+  install_element (LDP_IPV4_IFACE_NODE, &vtysh_quit_ldpd_cmd);
+  install_element (LDP_IPV6_IFACE_NODE, &vtysh_exit_ldpd_cmd);
+  install_element (LDP_IPV6_IFACE_NODE, &vtysh_quit_ldpd_cmd);
+  install_element (LDP_L2VPN_NODE, &vtysh_exit_ldpd_cmd);
+  install_element (LDP_L2VPN_NODE, &vtysh_quit_ldpd_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &vtysh_exit_ldpd_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &vtysh_quit_ldpd_cmd);
   install_element (BGP_NODE, &vtysh_exit_bgpd_cmd);
   install_element (BGP_NODE, &vtysh_quit_bgpd_cmd);
   install_element (BGP_VPNV4_NODE, &vtysh_exit_bgpd_cmd);
@@ -2457,6 +2639,13 @@ vtysh_init_vty (void)
   install_element (RIPNG_NODE, &vtysh_end_all_cmd);
   install_element (OSPF_NODE, &vtysh_end_all_cmd);
   install_element (OSPF6_NODE, &vtysh_end_all_cmd);
+  install_element (LDP_NODE, &vtysh_end_all_cmd);
+  install_element (LDP_IPV4_NODE, &vtysh_end_all_cmd);
+  install_element (LDP_IPV6_NODE, &vtysh_end_all_cmd);
+  install_element (LDP_IPV4_IFACE_NODE, &vtysh_end_all_cmd);
+  install_element (LDP_IPV6_IFACE_NODE, &vtysh_end_all_cmd);
+  install_element (LDP_L2VPN_NODE, &vtysh_end_all_cmd);
+  install_element (LDP_PSEUDOWIRE_NODE, &vtysh_end_all_cmd);
   install_element (BABEL_NODE, &vtysh_end_all_cmd);
   install_element (BGP_NODE, &vtysh_end_all_cmd);
   install_element (BGP_IPV4_NODE, &vtysh_end_all_cmd);
@@ -2486,6 +2675,13 @@ vtysh_init_vty (void)
 #ifdef HAVE_IPV6
   install_element (CONFIG_NODE, &router_ospf6_cmd);
 #endif
+  install_element (CONFIG_NODE, &ldp_mpls_ldp_cmd);
+  install_element (LDP_NODE, &ldp_address_family_ipv4_cmd);
+  install_element (LDP_NODE, &ldp_address_family_ipv6_cmd);
+  install_element (LDP_IPV4_NODE, &ldp_interface_ifname_cmd);
+  install_element (LDP_IPV6_NODE, &ldp_interface_ifname_cmd);
+  install_element (CONFIG_NODE, &ldp_l2vpn_word_type_vpls_cmd);
+  install_element (LDP_L2VPN_NODE, &ldp_member_pseudowire_ifname_cmd);
   install_element (CONFIG_NODE, &router_isis_cmd);
   install_element (CONFIG_NODE, &router_bgp_cmd);
   install_element (CONFIG_NODE, &router_bgp_view_cmd);
diff --git a/vtysh/vtysh.h b/vtysh/vtysh.h
index 1681a71..944d0b9 100644
--- a/vtysh/vtysh.h
+++ b/vtysh/vtysh.h
@@ -31,9 +31,10 @@
 #define VTYSH_ISISD  0x40
 #define VTYSH_BABELD  0x80
 #define VTYSH_PIMD   0x100
-#define VTYSH_ALL	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_BGPD|VTYSH_ISISD|VTYSH_BABELD|VTYSH_PIMD
+#define VTYSH_LDPD   0x200
+#define VTYSH_ALL	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_LDPD|VTYSH_BGPD|VTYSH_ISISD|VTYSH_BABELD|VTYSH_PIMD
 #define VTYSH_RMAP	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_BGPD|VTYSH_BABELD
-#define VTYSH_INTERFACE	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_ISISD|VTYSH_BABELD|VTYSH_PIMD
+#define VTYSH_INTERFACE	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_LDPD|VTYSH_ISISD|VTYSH_BABELD|VTYSH_PIMD
 
 /* vtysh local configuration file. */
 #define VTYSH_DEFAULT_CONFIG "vtysh.conf"
diff --git a/vtysh/vtysh_config.c b/vtysh/vtysh_config.c
index a069164..564ca5d 100644
--- a/vtysh/vtysh_config.c
+++ b/vtysh/vtysh_config.c
@@ -181,7 +181,8 @@ vtysh_config_parse_line (const char *line)
 	  else if (strncmp (line, " address-family ipv4 multicast",
 		   strlen (" address-family ipv4 multicast")) == 0)
 	    config = config_get (BGP_IPV4M_NODE, line);
-	  else if (strncmp (line, " address-family ipv6",
+	  else if (config->index != LDP_NODE &&
+		   strncmp (line, " address-family ipv6",
 		   strlen (" address-family ipv6")) == 0)
 	    config = config_get (BGP_IPV6_NODE, line);
 	  else if (config->index == RMAP_NODE ||
@@ -207,6 +208,10 @@ vtysh_config_parse_line (const char *line)
 	config = config_get (OSPF_NODE, line);
       else if (strncmp (line, "router ospf6", strlen ("router ospf6")) == 0)
 	config = config_get (OSPF6_NODE, line);
+      else if (strncmp (line, "mpls ldp", strlen ("mpls ldp")) == 0)
+	config = config_get (LDP_NODE, line);
+      else if (strncmp (line, "l2vpn", strlen ("l2vpn")) == 0)
+	config = config_get (LDP_L2VPN_NODE, line);
       else if (strncmp (line, "router bgp", strlen ("router bgp")) == 0)
 	config = config_get (BGP_NODE, line);
       else if (strncmp (line, "router isis", strlen ("router isis")) == 0)
@@ -255,6 +260,8 @@ vtysh_config_parse_line (const char *line)
 	config = config_get (AAA_NODE, line);
       else if (strncmp (line, "ip protocol", strlen ("ip protocol")) == 0)
 	config = config_get (PROTOCOL_NODE, line);
+      else if (strncmp (line, "mpls", strlen ("mpls")) == 0)
+	config = config_get (MPLS_NODE, line);
       else
 	{
 	  if (strncmp (line, "log", strlen ("log")) == 0
@@ -299,7 +306,7 @@ vtysh_config_parse (char *line)
    || (I) == AS_LIST_NODE || (I) == COMMUNITY_LIST_NODE || \
    (I) == ACCESS_IPV6_NODE || (I) == PREFIX_IPV6_NODE \
    || (I) == SERVICE_NODE || (I) == FORWARDING_NODE || (I) == DEBUG_NODE \
-   || (I) == AAA_NODE)
+   || (I) == AAA_NODE || (I) == MPLS_NODE)
 
 /* Display configuration to file pointer. */
 void
diff --git a/zebra/Makefile.am b/zebra/Makefile.am
index 90ce7b9..ba71000 100644
--- a/zebra/Makefile.am
+++ b/zebra/Makefile.am
@@ -12,9 +12,10 @@ rt_method = @RT_METHOD@
 rtread_method = @RTREAD_METHOD@
 kernel_method = @KERNEL_METHOD@
 ioctl_method = @IOCTL_METHOD@
+mpls_method = @MPLS_METHOD@
 
 otherobj = $(ioctl_method) $(ipforward) $(if_method) \
-	$(rt_method) $(rtread_method) $(kernel_method)
+	$(rt_method) $(rtread_method) $(kernel_method) $(mpls_method)
 
 if HAVE_NETLINK
 othersrc = zebra_fpm_netlink.c
@@ -30,11 +31,12 @@ zebra_SOURCES = \
 	zserv.c main.c interface.c connected.c zebra_rib.c zebra_routemap.c \
 	redistribute.c debug.c rtadv.c zebra_snmp.c zebra_vty.c \
 	irdp_main.c irdp_interface.c irdp_packet.c router-id.c zebra_fpm.c \
-	$(othersrc)
+	zebra_mpls.c $(othersrc)
 
 testzebra_SOURCES = test_main.c zebra_rib.c interface.c connected.c debug.c \
 	zebra_vty.c \
-	kernel_null.c  redistribute_null.c ioctl_null.c misc_null.c
+	kernel_null.c  redistribute_null.c ioctl_null.c misc_null.c \
+	zebra_mpls.c zebra_mpls_null.c
 
 noinst_HEADERS = \
 	connected.h ioctl.h rib.h rt.h zserv.h redistribute.h debug.h rtadv.h \
diff --git a/zebra/connected.c b/zebra/connected.c
index 84b0d1c..a356d75 100644
--- a/zebra/connected.c
+++ b/zebra/connected.c
@@ -35,6 +35,9 @@
 #include "zebra/redistribute.h"
 #include "zebra/interface.h"
 #include "zebra/connected.h"
+#include "zebra/zebra_mpls.h"
+#include "zebra/debug.h"
+
 extern struct zebra_t zebrad;
 
 /* communicate the withdrawal of a connected address */
@@ -198,6 +201,15 @@ connected_up_ipv4 (struct interface *ifp, struct connected *ifc)
        ifp->vrf_id, RT_TABLE_MAIN, ifp->metric, 0, 0, SAFI_MULTICAST);
 
   rib_update (ifp->vrf_id);
+
+  /* Schedule LSP forwarding entries for processing, if appropriate. */
+  if (ifp->vrf_id == VRF_DEFAULT)
+    {
+      if (IS_ZEBRA_DEBUG_MPLS)
+        zlog_debug ("%u: IF %s IPv4 address add/up, scheduling MPLS processing",
+                ifp->vrf_id, ifp->name);
+      mpls_mark_lsps_for_processing (vrf_info_lookup(ifp->vrf_id));
+    }
 }
 
 /* Add connected IPv4 route to the interface. */
@@ -311,6 +323,15 @@ connected_down_ipv4 (struct interface *ifp, struct connected *ifc)
                    SAFI_MULTICAST);
 
   rib_update (ifp->vrf_id);
+
+  /* Schedule LSP forwarding entries for processing, if appropriate. */
+  if (ifp->vrf_id == VRF_DEFAULT)
+    {
+      if (IS_ZEBRA_DEBUG_MPLS)
+        zlog_debug ("%u: IF %s IPv4 address add/up, scheduling MPLS processing",
+                ifp->vrf_id, ifp->name);
+      mpls_mark_lsps_for_processing (vrf_info_lookup(ifp->vrf_id));
+    }
 }
 
 /* Delete connected IPv4 route to the interface. */
@@ -333,6 +354,15 @@ connected_delete_ipv4 (struct interface *ifp, int flags, struct in_addr *addr,
   connected_withdraw (ifc);
 
   rib_update (ifp->vrf_id);
+
+  /* Schedule LSP forwarding entries for processing, if appropriate. */
+  if (ifp->vrf_id == VRF_DEFAULT)
+    {
+      if (IS_ZEBRA_DEBUG_MPLS)
+        zlog_debug ("%u: IF %s IPv4 address add/up, scheduling MPLS processing",
+                ifp->vrf_id, ifp->name);
+      mpls_mark_lsps_for_processing (vrf_info_lookup(ifp->vrf_id));
+    }
 }
 
 #ifdef HAVE_IPV6
@@ -355,10 +385,19 @@ connected_up_ipv6 (struct interface *ifp, struct connected *ifc)
     return;
 #endif
 
-  rib_add_ipv6 (ZEBRA_ROUTE_CONNECT, 0, &p, NULL, ifp->ifindex, ifp->vrf_id,
-                RT_TABLE_MAIN, ifp->metric, 0, 0, SAFI_UNICAST);
+  rib_add_ipv6 (ZEBRA_ROUTE_CONNECT, 0, &p, NULL, ifp->ifindex, MPLS_NO_LABEL,
+		ifp->vrf_id, RT_TABLE_MAIN, ifp->metric, 0, 0, SAFI_UNICAST);
 
   rib_update (ifp->vrf_id);
+
+  /* Schedule LSP forwarding entries for processing, if appropriate. */
+  if (ifp->vrf_id == VRF_DEFAULT)
+    {
+      if (IS_ZEBRA_DEBUG_MPLS)
+        zlog_debug ("%u: IF %s IPv4 address add/up, scheduling MPLS processing",
+                ifp->vrf_id, ifp->name);
+      mpls_mark_lsps_for_processing (vrf_info_lookup(ifp->vrf_id));
+    }
 }
 
 /* Add connected IPv6 route to the interface. */
@@ -442,6 +481,15 @@ connected_down_ipv6 (struct interface *ifp, struct connected *ifc)
                    SAFI_UNICAST);
 
   rib_update (ifp->vrf_id);
+
+  /* Schedule LSP forwarding entries for processing, if appropriate. */
+  if (ifp->vrf_id == VRF_DEFAULT)
+    {
+      if (IS_ZEBRA_DEBUG_MPLS)
+        zlog_debug ("%u: IF %s IPv4 address add/up, scheduling MPLS processing",
+                ifp->vrf_id, ifp->name);
+      mpls_mark_lsps_for_processing (vrf_info_lookup(ifp->vrf_id));
+    }
 }
 
 void
@@ -463,5 +511,14 @@ connected_delete_ipv6 (struct interface *ifp, struct in6_addr *address,
   connected_withdraw (ifc);
 
   rib_update (ifp->vrf_id);
+
+  /* Schedule LSP forwarding entries for processing, if appropriate. */
+  if (ifp->vrf_id == VRF_DEFAULT)
+    {
+      if (IS_ZEBRA_DEBUG_MPLS)
+        zlog_debug ("%u: IF %s IPv4 address add/up, scheduling MPLS processing",
+                ifp->vrf_id, ifp->name);
+      mpls_mark_lsps_for_processing (vrf_info_lookup(ifp->vrf_id));
+    }
 }
 #endif /* HAVE_IPV6 */
diff --git a/zebra/debug.c b/zebra/debug.c
index 537c476..afcc616 100644
--- a/zebra/debug.c
+++ b/zebra/debug.c
@@ -30,6 +30,7 @@ unsigned long zebra_debug_packet;
 unsigned long zebra_debug_kernel;
 unsigned long zebra_debug_rib;
 unsigned long zebra_debug_fpm;
+unsigned long zebra_debug_mpls;
 
 DEFUN (show_debugging_zebra,
        show_debugging_zebra_cmd,
@@ -74,6 +75,8 @@ DEFUN (show_debugging_zebra,
 
   if (IS_ZEBRA_DEBUG_FPM)
     vty_out (vty, "  Zebra FPM debugging is on%s", VTY_NEWLINE);
+  if (IS_ZEBRA_DEBUG_MPLS)
+    vty_out (vty, "  Zebra MPLS debugging is on%s", VTY_NEWLINE);
 
   return CMD_SUCCESS;
 }
@@ -89,6 +92,19 @@ DEFUN (debug_zebra_events,
   return CMD_WARNING;
 }
 
+#if 1
+DEFUN (debug_zebra_mpls,
+       debug_zebra_mpls_cmd,
+       "debug zebra mpls",
+       DEBUG_STR
+       "Zebra configuration\n"
+       "Debug option set for zebra MPLS LSPs\n")
+{
+  zebra_debug_mpls = ZEBRA_DEBUG_MPLS;
+  return CMD_WARNING;
+}
+#endif
+
 DEFUN (debug_zebra_packet,
        debug_zebra_packet_cmd,
        "debug zebra packet",
@@ -197,6 +213,20 @@ DEFUN (no_debug_zebra_events,
   return CMD_SUCCESS;
 }
 
+#if 1
+DEFUN (no_debug_zebra_mpls,
+       no_debug_zebra_mpls_cmd,
+       "no debug zebra mpls",
+       NO_STR
+       DEBUG_STR
+       "Zebra configuration\n"
+       "Debug option set for zebra MPLS LSPs\n")
+{
+  zebra_debug_mpls = 0;
+  return CMD_SUCCESS;
+}
+#endif
+
 DEFUN (no_debug_zebra_packet,
        no_debug_zebra_packet_cmd,
        "no debug zebra packet",
@@ -335,6 +365,11 @@ config_write_debug (struct vty *vty)
       vty_out (vty, "debug zebra fpm%s", VTY_NEWLINE);
       write++;
     }
+  if (IS_ZEBRA_DEBUG_MPLS)
+    {
+      vty_out (vty, "debug zebra mpls%s", VTY_NEWLINE);
+      write++;
+    }
   return write;
 }
 
@@ -346,6 +381,7 @@ zebra_debug_init (void)
   zebra_debug_kernel = 0;
   zebra_debug_rib = 0;
   zebra_debug_fpm = 0;
+  zebra_debug_mpls = 0;
 
   install_node (&debug_node, config_write_debug);
 
@@ -353,6 +389,9 @@ zebra_debug_init (void)
 
   install_element (ENABLE_NODE, &show_debugging_zebra_cmd);
   install_element (ENABLE_NODE, &debug_zebra_events_cmd);
+#if 1
+  install_element (ENABLE_NODE, &debug_zebra_mpls_cmd);
+#endif
   install_element (ENABLE_NODE, &debug_zebra_packet_cmd);
   install_element (ENABLE_NODE, &debug_zebra_packet_direct_cmd);
   install_element (ENABLE_NODE, &debug_zebra_packet_detail_cmd);
@@ -361,6 +400,9 @@ zebra_debug_init (void)
   install_element (ENABLE_NODE, &debug_zebra_rib_q_cmd);
   install_element (ENABLE_NODE, &debug_zebra_fpm_cmd);
   install_element (ENABLE_NODE, &no_debug_zebra_events_cmd);
+#if 1
+  install_element (ENABLE_NODE, &no_debug_zebra_mpls_cmd);
+#endif
   install_element (ENABLE_NODE, &no_debug_zebra_packet_cmd);
   install_element (ENABLE_NODE, &no_debug_zebra_kernel_cmd);
   install_element (ENABLE_NODE, &no_debug_zebra_rib_cmd);
@@ -368,6 +410,9 @@ zebra_debug_init (void)
   install_element (ENABLE_NODE, &no_debug_zebra_fpm_cmd);
 
   install_element (CONFIG_NODE, &debug_zebra_events_cmd);
+#if 1
+  install_element (CONFIG_NODE, &debug_zebra_mpls_cmd);
+#endif
   install_element (CONFIG_NODE, &debug_zebra_packet_cmd);
   install_element (CONFIG_NODE, &debug_zebra_packet_direct_cmd);
   install_element (CONFIG_NODE, &debug_zebra_packet_detail_cmd);
@@ -376,6 +421,9 @@ zebra_debug_init (void)
   install_element (CONFIG_NODE, &debug_zebra_rib_q_cmd);
   install_element (CONFIG_NODE, &debug_zebra_fpm_cmd);
   install_element (CONFIG_NODE, &no_debug_zebra_events_cmd);
+#if 1
+  install_element (CONFIG_NODE, &no_debug_zebra_mpls_cmd);
+#endif
   install_element (CONFIG_NODE, &no_debug_zebra_packet_cmd);
   install_element (CONFIG_NODE, &no_debug_zebra_kernel_cmd);
   install_element (CONFIG_NODE, &no_debug_zebra_rib_cmd);
diff --git a/zebra/debug.h b/zebra/debug.h
index d9231a2..77503cc 100644
--- a/zebra/debug.h
+++ b/zebra/debug.h
@@ -38,6 +38,8 @@
 
 #define ZEBRA_DEBUG_FPM     0x01
 
+#define ZEBRA_DEBUG_MPLS    0x01
+
 /* Debug related macro. */
 #define IS_ZEBRA_DEBUG_EVENT  (zebra_debug_event & ZEBRA_DEBUG_EVENT)
 
@@ -53,11 +55,14 @@
 
 #define IS_ZEBRA_DEBUG_FPM (zebra_debug_fpm & ZEBRA_DEBUG_FPM)
 
+#define IS_ZEBRA_DEBUG_MPLS  (zebra_debug_mpls & ZEBRA_DEBUG_MPLS)
+
 extern unsigned long zebra_debug_event;
 extern unsigned long zebra_debug_packet;
 extern unsigned long zebra_debug_kernel;
 extern unsigned long zebra_debug_rib;
 extern unsigned long zebra_debug_fpm;
+extern unsigned long zebra_debug_mpls;
 
 extern void zebra_debug_init (void);
 
diff --git a/zebra/kernel_socket.c b/zebra/kernel_socket.c
index 5e68c56..3b4f40f 100644
--- a/zebra/kernel_socket.c
+++ b/zebra/kernel_socket.c
@@ -242,7 +242,9 @@ static const struct message rtm_flag_str[] =
 #ifdef RTF_CLONING
   {RTF_CLONING,   "CLONING"},
 #endif /* RTF_CLONING */
+#ifdef RTF_XRESOLVE
   {RTF_XRESOLVE,  "XRESOLVE"},
+#endif /* RTF_XRESOLVE */
 #ifdef RTF_LLINFO
   {RTF_LLINFO,    "LLINFO"},
 #endif /* RTF_LLINFO */
@@ -1048,7 +1050,8 @@ rtm_read (struct rt_msghdr *rtm)
           || rtm->rtm_type == RTM_ADD
           || rtm->rtm_type == RTM_CHANGE)
         rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, zebra_flags, &p, &gate.sin6.sin6_addr,
-                      ifindex, VRF_DEFAULT, RT_TABLE_MAIN, 0, 0, 0, SAFI_UNICAST);
+                      ifindex, MPLS_NO_LABEL, VRF_DEFAULT, RT_TABLE_MAIN, 0, 0,
+		      0, SAFI_UNICAST);
       else
         rib_delete_ipv6 (ZEBRA_ROUTE_KERNEL, zebra_flags, &p,
                          &gate.sin6.sin6_addr, ifindex,
diff --git a/zebra/main.c b/zebra/main.c
index f3c08f1..e01d23f 100644
--- a/zebra/main.c
+++ b/zebra/main.c
@@ -41,6 +41,7 @@
 #include "zebra/irdp.h"
 #include "zebra/rtadv.h"
 #include "zebra/zebra_fpm.h"
+#include "zebra/zebra_mpls.h"
 
 /* Zebra instance */
 struct zebra_t zebrad =
@@ -411,6 +412,7 @@ main (int argc, char **argv)
 #ifdef HAVE_IRDP
   irdp_init();
 #endif
+  zebra_mpls_init ();
 
   /* For debug purpose. */
   /* SET_FLAG (zebra_debug_event, ZEBRA_DEBUG_EVENT); */
diff --git a/zebra/rib.h b/zebra/rib.h
index 1dacc7f..5390de5 100644
--- a/zebra/rib.h
+++ b/zebra/rib.h
@@ -27,6 +27,7 @@
 #include "prefix.h"
 #include "table.h"
 #include "queue.h"
+#include "mpls.h"
 
 #define DISTANCE_INFINITY  255
 
@@ -173,6 +174,15 @@ typedef struct rib_dest_t_
 #define RNODE_FOREACH_RIB_SAFE(rn, rib, next)				\
   RIB_DEST_FOREACH_ROUTE_SAFE (rib_dest_from_rnode (rn), rib, next)
 
+
+/* Static route label information */
+struct static_nh_label
+{
+  u_int8_t num_labels;
+  u_int8_t reserved[3];
+  mpls_label_t label[2];
+};
+
 /* Static route information. */
 struct static_route
 {
@@ -205,6 +215,9 @@ struct static_route
  see ZEBRA_FLAG_REJECT
      ZEBRA_FLAG_BLACKHOLE
  */
+
+  /* Label information */
+  struct static_nh_label snh_label;
 };
 
 enum nexthop_types_t
@@ -220,6 +233,14 @@ enum nexthop_types_t
   NEXTHOP_TYPE_BLACKHOLE,        /* Null0 nexthop.  */
 };
 
+/* Nexthop label structure. */
+struct nexthop_label
+{
+  u_int8_t num_labels;
+  u_int8_t reserved[3];
+  mpls_label_t label[0]; /* 1 or more labels. */
+};
+
 /* Nexthop structure. */
 struct nexthop
 {
@@ -249,6 +270,9 @@ struct nexthop
    * obtained by recursive resolution will be added to `resolved'.
    * Only one level of recursive resolution is currently supported. */
   struct nexthop *resolved;
+
+  /* Label(s) associated with this nexthop. */
+  struct nexthop_label *nh_label;
 };
 
 /* The following for loop allows to iterate over the nexthop
@@ -370,6 +394,16 @@ struct zebra_vrf
 #if defined (HAVE_RTADV)
   struct rtadv rtadv;
 #endif /* HAVE_RTADV */
+
+  /* MPLS static LSP config table */
+  struct hash *slsp_table;
+
+  /* MPLS label forwarding table */
+  struct hash *lsp_table;
+
+  /* MPLS processing flags */
+  u_int16_t mpls_flags;
+#define MPLS_FLAG_SCHEDULE_LSPS    (1 << 0)
 };
 
 /*
@@ -425,6 +459,7 @@ extern void multicast_mode_ipv4_set (enum multicast_mode mode);
 extern enum multicast_mode multicast_mode_ipv4_get (void);
 
 extern const char *nexthop_type_to_str (enum nexthop_types_t nh_type);
+extern void nexthop_free (struct nexthop *);
 extern struct nexthop *nexthop_ifindex_add (struct rib *, ifindex_t);
 extern struct nexthop *nexthop_ifname_add (struct rib *, char *);
 extern struct nexthop *nexthop_blackhole_add (struct rib *);
@@ -434,6 +469,8 @@ extern struct nexthop *nexthop_ipv4_ifindex_add (struct rib *,
                                                  struct in_addr *,
                                                  struct in_addr *,
                                                  ifindex_t);
+extern void nexthop_add_labels (struct nexthop *, u_int8_t, mpls_label_t *);
+extern void nexthop_del_labels (struct nexthop *);
 extern int nexthop_has_fib_child(struct nexthop *);
 extern void rib_lookup_and_dump (struct prefix_ipv4 *);
 extern void rib_lookup_and_pushup (struct prefix_ipv4 *);
@@ -488,15 +525,16 @@ extern unsigned long rib_score_proto (u_char proto);
 extern int
 static_add_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
 		      const char *ifname, u_char flags, u_char distance,
-		      vrf_id_t vrf_id);
+		      vrf_id_t vrf_id, struct static_nh_label *snh_label);
 extern int
 static_delete_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
-			 const char *ifname, u_char distance, vrf_id_t vrf_id);
+			 const char *ifname, u_char distance, vrf_id_t vrf_id,
+			 struct static_nh_label *snh_label);
 
 extern int
 rib_add_ipv6 (int type, int flags, struct prefix_ipv6 *p,
-	      struct in6_addr *gate, ifindex_t ifindex, vrf_id_t vrf_id,
-	      int table_id, u_int32_t metric, u_int32_t mtu,
+	      struct in6_addr *gate, ifindex_t ifindex, mpls_label_t label,
+	      vrf_id_t vrf_id, int table_id, u_int32_t metric, u_int32_t mtu,
 	      u_char distance, safi_t safi);
 
 extern int
@@ -512,15 +550,18 @@ extern struct route_table *rib_table_ipv6;
 extern int
 static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
 		 const char *ifname, u_char flags, u_char distance,
-		 vrf_id_t vrf_id);
+		 vrf_id_t vrf_id, struct static_nh_label *snh_label);
 
 extern int
 static_delete_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
-		    const char *ifname, u_char distance, vrf_id_t vrf_id);
+		    const char *ifname, u_char distance, vrf_id_t vrf_id,
+		    struct static_nh_label *snh_label);
 
 extern int rib_gc_dest (struct route_node *rn);
 extern struct route_table *rib_tables_iter_next (rib_tables_iter_t *iter);
 
+extern u_char route_distance(int type);
+
 /*
  * Inline functions.
  */
diff --git a/zebra/rt.h b/zebra/rt.h
index 8c1c476..bcedd4c 100644
--- a/zebra/rt.h
+++ b/zebra/rt.h
@@ -26,10 +26,14 @@
 #include "prefix.h"
 #include "if.h"
 #include "zebra/rib.h"
+#include "zebra/zebra_mpls.h"
 
 extern int kernel_route_rib (struct prefix *, struct rib *, struct rib *);
 extern int kernel_add_route (struct prefix_ipv4 *, struct in_addr *, int, int);
 extern int kernel_address_add_ipv4 (struct interface *, struct connected *);
 extern int kernel_address_delete_ipv4 (struct interface *, struct connected *);
+extern int kernel_add_lsp (zebra_lsp_t *);
+extern int kernel_upd_lsp (zebra_lsp_t *);
+extern int kernel_del_lsp (zebra_lsp_t *);
 
 #endif /* _ZEBRA_RT_H */
diff --git a/zebra/rt_netlink.c b/zebra/rt_netlink.c
index e4505de..3b7e008 100644
--- a/zebra/rt_netlink.c
+++ b/zebra/rt_netlink.c
@@ -38,12 +38,14 @@
 #include "thread.h"
 #include "privs.h"
 #include "vrf.h"
+#include "mpls.h"
 
 #include "zebra/zserv.h"
 #include "zebra/rt.h"
 #include "zebra/redistribute.h"
 #include "zebra/interface.h"
 #include "zebra/debug.h"
+#include "zebra/zebra_mpls.h"
 
 #include "rt_netlink.h"
 
@@ -60,6 +62,42 @@ static const struct message nlmsg_str[] = {
   {0, NULL}
 };
 
+
+/* TODO - Temporary definitions, need to refine. */
+#ifndef RTA_VIA
+#define RTA_VIA     RTA_MARK+2
+#define RTA_NEWDST  RTA_VIA+1
+#define RTA_PREF    RTA_NEWDST+1
+#define RTA_ENCAP_TYPE RTA_PREF+1
+#define RTA_ENCAP   RTA_ENCAP_TYPE+1
+
+#ifndef LWTUNNEL_ENCAP_MPLS
+#define LWTUNNEL_ENCAP_MPLS  1
+#endif
+
+#ifndef MPLS_IPTUNNEL_DST
+#define MPLS_IPTUNNEL_DST  1
+#endif
+/* End of temporary definitions */
+#endif
+
+#ifndef NLMSG_TAIL
+#define NLMSG_TAIL(nmsg) \
+        ((struct rtattr *) (((u_char *) (nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))
+#endif
+
+#ifndef RTA_TAIL
+#define RTA_TAIL(rta) \
+        ((struct rtattr *) (((u_char *) (rta)) + RTA_ALIGN((rta)->rta_len)))
+#endif
+
+struct gw_family_t
+{
+  u_int16_t     filler;
+  u_int16_t     family;
+  union g_addr  gate;
+};
+
 extern struct zebra_t zebrad;
 
 extern struct zebra_privs_t zserv_privs;
@@ -766,7 +804,12 @@ netlink_routing_table (struct sockaddr_nl *snl, struct nlmsghdr *h,
   if (rtm->rtm_src_len != 0)
     return 0;
 
-  /* Route which inserted by Zebra. */
+  /* We don't care about change notifications for the MPLS table. */
+  /* TODO: Revisit this. */
+  if (rtm->rtm_family == AF_MPLS)
+    return 0;
+
+   /* Route which inserted by Zebra. */
   if (rtm->rtm_protocol == RTPROT_ZEBRA)
     flags |= ZEBRA_FLAG_SELFROUTE;
 
@@ -876,8 +919,8 @@ netlink_routing_table (struct sockaddr_nl *snl, struct nlmsghdr *h,
       memcpy (&p.prefix, dest, 16);
       p.prefixlen = rtm->rtm_dst_len;
 
-      rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, flags, &p, gate, index, vrf_id,
-                    table, 0, mtu, 0, SAFI_UNICAST);
+      rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, flags, &p, gate, index, MPLS_NO_LABEL,
+		    vrf_id, table, 0, mtu, 0, SAFI_UNICAST);
     }
 #endif /* HAVE_IPV6 */
 
@@ -948,6 +991,11 @@ netlink_route_change (struct sockaddr_nl *snl, struct nlmsghdr *h,
       return 0;
     }
 
+  /* We don't care about change notifications for the MPLS table. */
+  /* TODO: Revisit this. */
+  if (rtm->rtm_family == AF_MPLS)
+    return 0;
+
   len = h->nlmsg_len - NLMSG_LENGTH (sizeof (struct rtmsg));
   if (len < 0)
     return -1;
@@ -1105,8 +1153,8 @@ netlink_route_change (struct sockaddr_nl *snl, struct nlmsghdr *h,
         }
 
       if (h->nlmsg_type == RTM_NEWROUTE)
-        rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, 0, &p, gate, index, vrf_id, table,
-                      0, mtu, 0, SAFI_UNICAST);
+        rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, 0, &p, gate, index, MPLS_NO_LABEL,
+		      vrf_id, table, 0, mtu, 0, SAFI_UNICAST);
       else
         rib_delete_ipv6 (ZEBRA_ROUTE_KERNEL, 0, &p, gate, index, vrf_id,
                          SAFI_UNICAST);
@@ -1335,14 +1383,14 @@ addattr_l (struct nlmsghdr *n, size_t maxlen, int type, void *data, int alen)
 
   len = RTA_LENGTH (alen);
 
-  if (NLMSG_ALIGN (n->nlmsg_len) + len > maxlen)
+  if (NLMSG_ALIGN (n->nlmsg_len) + RTA_ALIGN (len) > maxlen)
     return -1;
 
   rta = (struct rtattr *) (((char *) n) + NLMSG_ALIGN (n->nlmsg_len));
   rta->rta_type = type;
   rta->rta_len = len;
   memcpy (RTA_DATA (rta), data, alen);
-  n->nlmsg_len = NLMSG_ALIGN (n->nlmsg_len) + len;
+  n->nlmsg_len = NLMSG_ALIGN (n->nlmsg_len) + RTA_ALIGN (len);
 
   return 0;
 }
@@ -1355,14 +1403,14 @@ rta_addattr_l (struct rtattr *rta, int maxlen, int type, void *data, int alen)
 
   len = RTA_LENGTH (alen);
 
-  if (RTA_ALIGN (rta->rta_len) + len > maxlen)
+  if (RTA_ALIGN (rta->rta_len) + RTA_ALIGN (len) > maxlen)
     return -1;
 
   subrta = (struct rtattr *) (((char *) rta) + RTA_ALIGN (rta->rta_len));
   subrta->rta_type = type;
   subrta->rta_len = len;
   memcpy (RTA_DATA (subrta), data, alen);
-  rta->rta_len = NLMSG_ALIGN (rta->rta_len) + len;
+  rta->rta_len = NLMSG_ALIGN (rta->rta_len) + RTA_ALIGN (len);
 
   return 0;
 }
@@ -1372,21 +1420,40 @@ rta_addattr_l (struct rtattr *rta, int maxlen, int type, void *data, int alen)
 int
 addattr32 (struct nlmsghdr *n, size_t maxlen, int type, int data)
 {
-  size_t len;
-  struct rtattr *rta;
+  return addattr_l(n, maxlen, type, &data, sizeof(u_int32_t));
+}
 
-  len = RTA_LENGTH (4);
+/* Some more utility functions from iproute2 */
+static struct rtattr *
+addattr_nest(struct nlmsghdr *n, int maxlen, int type)
+{
+  struct rtattr *nest = NLMSG_TAIL(n);
 
-  if (NLMSG_ALIGN (n->nlmsg_len) + len > maxlen)
-    return -1;
+  addattr_l(n, maxlen, type, NULL, 0);
+  return nest;
+}
 
-  rta = (struct rtattr *) (((char *) n) + NLMSG_ALIGN (n->nlmsg_len));
-  rta->rta_type = type;
-  rta->rta_len = len;
-  memcpy (RTA_DATA (rta), &data, 4);
-  n->nlmsg_len = NLMSG_ALIGN (n->nlmsg_len) + len;
+static int
+addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest)
+{
+  nest->rta_len = (u_char *)NLMSG_TAIL(n) - (u_char *)nest;
+  return n->nlmsg_len;
+}
 
-  return 0;
+static struct rtattr *
+rta_nest(struct rtattr *rta, int maxlen, int type)
+{
+  struct rtattr *nest = RTA_TAIL(rta);
+
+  rta_addattr_l(rta, maxlen, type, NULL, 0);
+  return nest;
+}
+
+static int
+rta_nest_end(struct rtattr *rta, struct rtattr *nest)
+{
+  nest->rta_len = (u_char *)RTA_TAIL(rta) - (u_char *)nest;
+  return rta->rta_len;
 }
 
 static int
@@ -1452,6 +1519,56 @@ netlink_talk (struct nlmsghdr *n, struct nlsock *nl, struct zebra_vrf *zvrf)
   return netlink_parse_info (netlink_talk_filter, nl, zvrf);
 }
 
+static void
+_netlink_route_nl_add_gateway_info (u_char route_family, u_char gw_family,
+                                    struct nlmsghdr *nlmsg,
+                                    size_t req_size, int bytelen,
+                                    struct nexthop *nexthop)
+{
+  if (route_family == AF_MPLS)
+    {
+      struct gw_family_t gw_fam;
+
+      gw_fam.family = gw_family;
+      if (gw_family == AF_INET)
+        memcpy (&gw_fam.gate.ipv4, &nexthop->gate.ipv4, bytelen);
+      else
+        memcpy (&gw_fam.gate.ipv6, &nexthop->gate.ipv6, bytelen);
+      addattr_l (nlmsg, req_size, RTA_VIA, &gw_fam.family, bytelen+2);
+      return;
+    }
+  if (gw_family == AF_INET)
+    addattr_l (nlmsg, req_size, RTA_GATEWAY, &nexthop->gate.ipv4, bytelen);
+  else
+    addattr_l (nlmsg, req_size, RTA_GATEWAY, &nexthop->gate.ipv6, bytelen);
+}
+
+static void
+_netlink_route_rta_add_gateway_info (u_char route_family, u_char gw_family,
+                                     struct rtattr *rta, struct rtnexthop *rtnh,
+                                     size_t req_size, int bytelen,
+                                     struct nexthop *nexthop)
+{
+  if (route_family == AF_MPLS)
+    {
+      struct gw_family_t gw_fam;
+
+      gw_fam.family = gw_family;
+      if (gw_family == AF_INET)
+        memcpy (&gw_fam.gate.ipv4, &nexthop->gate.ipv4, bytelen);
+      else
+        memcpy (&gw_fam.gate.ipv6, &nexthop->gate.ipv6, bytelen);
+      rta_addattr_l (rta, req_size, RTA_VIA, &gw_fam.family, bytelen+2);
+      rtnh->rtnh_len += RTA_LENGTH (bytelen + 2);
+      return;
+    }
+  if (gw_family == AF_INET)
+    rta_addattr_l (rta, req_size, RTA_GATEWAY, &nexthop->gate.ipv4, bytelen);
+  else
+    rta_addattr_l (rta, req_size, RTA_GATEWAY, &nexthop->gate.ipv6, bytelen);
+  rtnh->rtnh_len += sizeof (struct rtattr) + bytelen;
+}
+
 /* This function takes a nexthop as argument and adds
  * the appropriate netlink attributes to an existing
  * netlink message.
@@ -1472,38 +1589,95 @@ _netlink_route_build_singlepath(
         struct rtmsg *rtmsg,
         size_t req_size)
 {
+  struct nexthop_label *nh_label;
+  mpls_lse_t out_lse[MPLS_MAX_LABELS];
+  char label_buf[100];
+
+  label_buf[0] = '\0';
+  /* outgoing label - either as NEWDST (in the case of LSR) or as ENCAP
+   * (in the case of LER)
+   */
+  nh_label = nexthop->nh_label;
+  if (rtmsg->rtm_family == AF_MPLS)
+    {
+      assert (nh_label);
+      assert (nh_label->num_labels == 1);
+    }
+
+  if (nh_label && nh_label->num_labels)
+    {
+      int i, num_labels = 0;
+      u_int32_t bos;
+      char label_buf1[20];
+ 
+      for (i = 0; i < nh_label->num_labels; i++)
+        {
+          if (nh_label->label[i] != MPLS_IMP_NULL_LABEL)
+            {
+              bos = ((i == (nh_label->num_labels - 1)) ? 1 : 0);
+              out_lse[i] = mpls_lse_encode (nh_label->label[i], 0, 0, bos);
+              if (!num_labels)
+                sprintf (label_buf, "label %d", nh_label->label[i]);
+              else
+                {
+                  sprintf (label_buf1, "/%d", nh_label->label[i]);
+                  strcat (label_buf, label_buf1);
+                }
+              num_labels++;
+            }
+        }
+      if (num_labels)
+        {
+          if (rtmsg->rtm_family == AF_MPLS)
+            addattr_l (nlmsg, req_size, RTA_NEWDST,
+                       &out_lse, num_labels * sizeof(mpls_lse_t));
+          else
+            {
+              struct rtattr *nest;
+              u_int16_t encap = LWTUNNEL_ENCAP_MPLS;
+
+              addattr_l(nlmsg, req_size, RTA_ENCAP_TYPE,
+                        &encap, sizeof (u_int16_t));
+              nest = addattr_nest(nlmsg, req_size, RTA_ENCAP);
+              addattr_l (nlmsg, req_size, MPLS_IPTUNNEL_DST,
+                         &out_lse, num_labels * sizeof(mpls_lse_t));
+              addattr_nest_end(nlmsg, nest);
+            }
+        }
+    }
+
   if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ONLINK))
     rtmsg->rtm_flags |= RTNH_F_ONLINK;
   if (nexthop->type == NEXTHOP_TYPE_IPV4
       || nexthop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
     {
-      addattr_l (nlmsg, req_size, RTA_GATEWAY,
-                 &nexthop->gate.ipv4, bytelen);
+      _netlink_route_nl_add_gateway_info (rtmsg->rtm_family, AF_INET, nlmsg,
+                                          req_size, bytelen, nexthop);
       if (nexthop->src.ipv4.s_addr)
         addattr_l (nlmsg, req_size, RTA_PREFSRC,
                    &nexthop->src.ipv4, bytelen);
 
       if (IS_ZEBRA_DEBUG_KERNEL)
         zlog_debug("netlink_route_multipath() (%s): "
-                   "nexthop via %s if %u",
+                   "nexthop via %s %s if %u",
                    routedesc,
                    inet_ntoa (nexthop->gate.ipv4),
-                   nexthop->ifindex);
+                   label_buf, nexthop->ifindex);
     }
 #ifdef HAVE_IPV6
   if (nexthop->type == NEXTHOP_TYPE_IPV6
       || nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
       || nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX)
     {
-      addattr_l (nlmsg, req_size, RTA_GATEWAY,
-                 &nexthop->gate.ipv6, bytelen);
+      _netlink_route_nl_add_gateway_info (rtmsg->rtm_family, AF_INET6, nlmsg,
+                                          req_size, bytelen, nexthop);
 
       if (IS_ZEBRA_DEBUG_KERNEL)
         zlog_debug("netlink_route_multipath() (%s): "
-                   "nexthop via %s if %u",
+                   "nexthop via %s %s if %u",
                    routedesc,
                    inet6_ntoa (nexthop->gate.ipv6),
-                   nexthop->ifindex);
+                   label_buf, nexthop->ifindex);
     }
 #endif /* HAVE_IPV6 */
   if (nexthop->type == NEXTHOP_TYPE_IFINDEX
@@ -1555,49 +1729,109 @@ _netlink_route_build_multipath(
         struct nexthop *nexthop,
         struct rtattr *rta,
         struct rtnexthop *rtnh,
-        union g_addr **src
-        )
+        struct rtmsg *rtmsg,
+        union g_addr **src)
 {
+  struct nexthop_label *nh_label;
+  mpls_lse_t out_lse[MPLS_MAX_LABELS];
+  char label_buf[100];
+
   rtnh->rtnh_len = sizeof (*rtnh);
   rtnh->rtnh_flags = 0;
   rtnh->rtnh_hops = 0;
   rta->rta_len += rtnh->rtnh_len;
 
+  label_buf[0] = '\0';
+  /* outgoing label - either as NEWDST (in the case of LSR) or as ENCAP
+   * (in the case of LER)
+   */
+  nh_label = nexthop->nh_label;
+  if (rtmsg->rtm_family == AF_MPLS)
+    {
+      assert (nh_label);
+      assert (nh_label->num_labels == 1);
+    }
+
+  if (nh_label && nh_label->num_labels)
+    {
+      int i, num_labels = 0;
+      u_int32_t bos;
+      char label_buf1[20];
+
+      for (i = 0; i < nh_label->num_labels; i++)
+        {
+          if (nh_label->label[i] != MPLS_IMP_NULL_LABEL)
+            {
+              bos = ((i == (nh_label->num_labels - 1)) ? 1 : 0);
+              out_lse[i] = mpls_lse_encode (nh_label->label[i], 0, 0, bos);
+              if (!num_labels)
+                sprintf (label_buf, "label %d", nh_label->label[i]);
+              else
+                {
+                  sprintf (label_buf1, "/%d", nh_label->label[i]);
+                  strcat (label_buf, label_buf1);
+                }
+              num_labels++;
+            }
+        }
+      if (num_labels)
+        {
+          if (rtmsg->rtm_family == AF_MPLS)
+            {
+              rta_addattr_l (rta, NL_PKT_BUF_SIZE, RTA_NEWDST,
+                             &out_lse, num_labels * sizeof(mpls_lse_t));
+              rtnh->rtnh_len += RTA_LENGTH (num_labels * sizeof(mpls_lse_t));
+            }
+          else
+            {
+              struct rtattr *nest;
+              u_int16_t encap = LWTUNNEL_ENCAP_MPLS;
+              int len = rta->rta_len;
+
+              rta_addattr_l(rta, NL_PKT_BUF_SIZE, RTA_ENCAP_TYPE,
+                            &encap, sizeof (u_int16_t));
+              nest = rta_nest(rta, NL_PKT_BUF_SIZE, RTA_ENCAP);
+              rta_addattr_l (rta, NL_PKT_BUF_SIZE, MPLS_IPTUNNEL_DST,
+                             &out_lse, num_labels * sizeof(mpls_lse_t));
+              rta_nest_end(rta, nest);
+              rtnh->rtnh_len += rta->rta_len - len;
+            }
+        }
+    }
+
   if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ONLINK))
     rtnh->rtnh_flags |= RTNH_F_ONLINK;
 
   if (nexthop->type == NEXTHOP_TYPE_IPV4
       || nexthop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
     {
-      rta_addattr_l (rta, NL_PKT_BUF_SIZE, RTA_GATEWAY,
-                     &nexthop->gate.ipv4, bytelen);
-      rtnh->rtnh_len += sizeof (struct rtattr) + bytelen;
-
+      _netlink_route_rta_add_gateway_info (rtmsg->rtm_family, AF_INET, rta,
+                                     rtnh, NL_PKT_BUF_SIZE, bytelen, nexthop);
       if (nexthop->src.ipv4.s_addr)
         *src = &nexthop->src;
 
       if (IS_ZEBRA_DEBUG_KERNEL)
         zlog_debug("netlink_route_multipath() (%s): "
-                   "nexthop via %s if %u",
+                   "nexthop via %s %s if %u",
                    routedesc,
                    inet_ntoa (nexthop->gate.ipv4),
-                   nexthop->ifindex);
+                   label_buf, nexthop->ifindex);
     }
+
 #ifdef HAVE_IPV6
   if (nexthop->type == NEXTHOP_TYPE_IPV6
       || nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
       || nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX)
     {
-      rta_addattr_l (rta, NL_PKT_BUF_SIZE, RTA_GATEWAY,
-                     &nexthop->gate.ipv6, bytelen);
-      rtnh->rtnh_len += sizeof (struct rtattr) + bytelen;
+      _netlink_route_rta_add_gateway_info (rtmsg->rtm_family, AF_INET6, rta,
+                                       rtnh, NL_PKT_BUF_SIZE, bytelen, nexthop);
 
       if (IS_ZEBRA_DEBUG_KERNEL)
         zlog_debug("netlink_route_multipath() (%s): "
-                   "nexthop via %s if %u",
+                   "nexthop via %s %s if %u",
                    routedesc,
                    inet6_ntoa (nexthop->gate.ipv6),
-                   nexthop->ifindex);
+                   label_buf, nexthop->ifindex);
     }
 #endif /* HAVE_IPV6 */
   /* ifindex */
@@ -1627,6 +1861,43 @@ _netlink_route_build_multipath(
     }
 }
 
+static inline void
+_netlink_mpls_build_singlepath(
+        const char *routedesc,
+        zebra_nhlfe_t *nhlfe,
+        struct nlmsghdr *nlmsg,
+        struct rtmsg *rtmsg,
+        size_t req_size,
+	int cmd)
+{
+  int bytelen;
+  u_char family;
+
+  family = NHLFE_FAMILY (nhlfe);
+  bytelen = (family == AF_INET ? 4 : 16);
+  _netlink_route_build_singlepath(routedesc, bytelen, nhlfe->nexthop,
+                                  nlmsg, rtmsg, req_size);
+}
+
+
+static inline void
+_netlink_mpls_build_multipath(
+        const char *routedesc,
+        zebra_nhlfe_t *nhlfe,
+        struct rtattr *rta,
+        struct rtnexthop *rtnh,
+        struct rtmsg *rtmsg,
+        union g_addr **src)
+{
+  int bytelen;
+  u_char family;
+
+  family = NHLFE_FAMILY (nhlfe);
+  bytelen = (family == AF_INET ? 4 : 16);
+  _netlink_route_build_multipath(routedesc, bytelen, nhlfe->nexthop,
+                                 rta, rtnh, rtmsg, src);
+}
+
 /* Log debug information for netlink_route_multipath
  * if debug logging is enabled.
  *
@@ -1658,6 +1929,17 @@ _netlink_route_debug(
     }
 }
 
+static void
+_netlink_mpls_debug(
+        int cmd,
+        u_int32_t label,
+        const char *routedesc)
+{
+  if (IS_ZEBRA_DEBUG_KERNEL)
+    zlog_debug ("netlink_mpls_multipath() (%s): %s %u/20",
+                routedesc, lookup (nlmsg_str, cmd), label);
+}
+
 /* Routing table change via netlink interface. */
 static int
 netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib)
@@ -1826,7 +2108,7 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib)
               _netlink_route_debug(cmd, p, nexthop,
                                    routedesc, family, zvrf);
               _netlink_route_build_multipath(routedesc, bytelen,
-                                             nexthop, rta, rtnh, &src);
+                                             nexthop, rta, rtnh, &req.r, &src);
               rtnh = RTNH_NEXT (rtnh);
 
               if (cmd == RTM_NEWROUTE)
@@ -1937,6 +2219,182 @@ kernel_address_delete_ipv4 (struct interface *ifp, struct connected *ifc)
   return netlink_address (RTM_DELADDR, AF_INET, ifp, ifc);
 }
 
+/*
+ * MPLS label forwarding table change via netlink interface.
+ */
+int
+netlink_mpls_multipath (int cmd, zebra_lsp_t *lsp)
+{
+  mpls_lse_t lse;
+  struct sockaddr_nl snl;
+  zebra_nhlfe_t *nhlfe;
+  struct nexthop *nexthop = NULL;
+  int nexthop_num;
+  const char *routedesc;
+  struct zebra_vrf *zvrf = vrf_info_lookup (VRF_DEFAULT);
+
+  struct
+  {
+    struct nlmsghdr n;
+    struct rtmsg r;
+    char buf[NL_PKT_BUF_SIZE];
+  } req;
+
+  memset (&req, 0, sizeof req - NL_PKT_BUF_SIZE);
+
+
+  /*
+   * Count # nexthops so we can decide whether to use singlepath
+   * or multipath case.
+   */
+  nexthop_num = 0;
+  for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe->next)
+    {
+      nexthop = nhlfe->nexthop;
+      if (!nexthop)
+        continue;
+      if (cmd == RTM_NEWROUTE)
+        {
+          /* Count all selected NHLFEs */
+          if (CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_SELECTED) &&
+              CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE))
+            nexthop_num++;
+        }
+      else /* DEL */
+        {
+          /* Count all installed NHLFEs */
+          if (CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_INSTALLED) &&
+              CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
+            nexthop_num++;
+        }
+    }
+
+  if (nexthop_num == 0) // unexpected
+    return 0;
+
+  req.n.nlmsg_len = NLMSG_LENGTH (sizeof (struct rtmsg));
+  req.n.nlmsg_flags = NLM_F_CREATE | NLM_F_REQUEST;
+  req.n.nlmsg_type = cmd;
+  req.r.rtm_family = AF_MPLS;
+  req.r.rtm_table = RT_TABLE_MAIN;
+  req.r.rtm_dst_len = MPLS_LABEL_LEN_BITS;
+  req.r.rtm_protocol = RTPROT_ZEBRA;
+  req.r.rtm_scope = RT_SCOPE_UNIVERSE;
+  req.r.rtm_type = RTN_UNICAST;
+
+  if (cmd == RTM_NEWROUTE)
+    /* We do a replace to handle update. */
+    req.n.nlmsg_flags |= NLM_F_REPLACE;
+
+  /* Fill destination */
+  lse = mpls_lse_encode (lsp->ile.in_label, 0, 0, 1);
+  addattr_l (&req.n, sizeof req, RTA_DST, &lse, sizeof(mpls_lse_t));
+
+  /* Fill nexthops (paths) based on single-path or multipath. The paths
+   * chosen depend on the operation.
+   */
+  if (nexthop_num == 1 || MULTIPATH_NUM == 1)
+    {
+      routedesc = "single hop";
+      _netlink_mpls_debug(cmd, lsp->ile.in_label, routedesc);
+
+      nexthop_num = 0;
+      for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe->next)
+        {
+          nexthop = nhlfe->nexthop;
+          if (!nexthop)
+            continue;
+
+          if ((cmd == RTM_NEWROUTE &&
+               (CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_SELECTED) &&
+                CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE))) ||
+              (cmd == RTM_DELROUTE &&
+               (CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_INSTALLED) &&
+                CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))))
+            {
+              /* Add the gateway */
+              _netlink_mpls_build_singlepath(routedesc, nhlfe,
+                                             &req.n, &req.r, sizeof req, cmd);
+              if (cmd == RTM_NEWROUTE)
+                {
+                  SET_FLAG (nhlfe->flags, NHLFE_FLAG_INSTALLED);
+                  SET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
+                }
+              else
+                {
+                  UNSET_FLAG (nhlfe->flags, NHLFE_FLAG_INSTALLED);
+                  UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
+                }
+              nexthop_num++;
+              break;
+            }
+        }
+    }
+  else /* Multipath case */
+    {
+      char buf[NL_PKT_BUF_SIZE];
+      struct rtattr *rta = (void *) buf;
+      struct rtnexthop *rtnh;
+      union g_addr *src1 = NULL;
+
+      rta->rta_type = RTA_MULTIPATH;
+      rta->rta_len = RTA_LENGTH (0);
+      rtnh = RTA_DATA (rta);
+
+      routedesc = "multihop";
+      _netlink_mpls_debug(cmd, lsp->ile.in_label, routedesc);
+
+      nexthop_num = 0;
+      for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe->next)
+        {
+          nexthop = nhlfe->nexthop;
+          if (!nexthop)
+            continue;
+
+          if (MULTIPATH_NUM != 0 && nexthop_num >= MULTIPATH_NUM)
+            break;
+
+          if ((cmd == RTM_NEWROUTE &&
+               (CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_SELECTED) &&
+                CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE))) ||
+              (cmd == RTM_DELROUTE &&
+               (CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_INSTALLED) &&
+                CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))))
+            {
+              nexthop_num++;
+
+              /* Build the multipath */
+              _netlink_mpls_build_multipath(routedesc, nhlfe, rta,
+                                            rtnh, &req.r, &src1);
+              rtnh = RTNH_NEXT (rtnh);
+
+              if (cmd == RTM_NEWROUTE)
+                {
+                  SET_FLAG (nhlfe->flags, NHLFE_FLAG_INSTALLED);
+                  SET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
+                }
+              else
+                {
+                  UNSET_FLAG (nhlfe->flags, NHLFE_FLAG_INSTALLED);
+                  UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
+                }
+
+            }
+        }
+
+      /* Add the multipath */
+      if (rta->rta_len > RTA_LENGTH (0))
+        addattr_l (&req.n, NL_PKT_BUF_SIZE, RTA_MULTIPATH, RTA_DATA (rta),
+                   RTA_PAYLOAD (rta));
+    }
+
+  /* Destination netlink address. */
+  memset (&snl, 0, sizeof snl);
+  snl.nl_family = AF_NETLINK;
+
+  /* Talk to netlink socket. */
+  return netlink_talk (&req.n, &zvrf->netlink_cmd, zvrf);
+}
 
 extern struct thread_master *master;
 
diff --git a/zebra/rt_netlink.h b/zebra/rt_netlink.h
index 63fbbe7..a5d7d20 100644
--- a/zebra/rt_netlink.h
+++ b/zebra/rt_netlink.h
@@ -22,6 +22,8 @@
 #ifndef _ZEBRA_RT_NETLINK_H
 #define _ZEBRA_RT_NETLINK_H
 
+#include "zebra/zebra_mpls.h"
+
 #ifdef HAVE_NETLINK
 
 #define NL_PKT_BUF_SIZE 8192
@@ -44,6 +46,7 @@ nl_rtproto_to_str (u_char rtproto);
 
 extern int interface_lookup_netlink (struct zebra_vrf *zvrf);
 extern int netlink_route_read (struct zebra_vrf *zvrf);
+extern int netlink_mpls_multipath (int cmd, zebra_lsp_t *lsp);
 
 #endif /* HAVE_NETLINK */
 
diff --git a/zebra/zebra_mpls.c b/zebra/zebra_mpls.c
new file mode 100644
index 0000000..5c4b4cf
--- /dev/null
+++ b/zebra/zebra_mpls.c
@@ -0,0 +1,1698 @@
+/* Zebra MPLS code
+ * Copyright (C) 2013 Cumulus Networks, Inc.
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+
+#include <zebra.h>
+
+#include "prefix.h"
+#include "table.h"
+#include "memory.h"
+#include "str.h"
+#include "command.h"
+#include "if.h"
+#include "log.h"
+#include "sockunion.h"
+#include "linklist.h"
+#include "thread.h"
+#include "workqueue.h"
+#include "prefix.h"
+#include "routemap.h"
+#include "stream.h"
+
+#include "zebra/rib.h"
+#include "zebra/rt.h"
+#include "zebra/zserv.h"
+#include "zebra/redistribute.h"
+#include "zebra/debug.h"
+#include "zebra/zebra_mpls.h"
+
+/* Default rtm_table for all clients */
+extern struct zebra_t zebrad;
+
+/* static function declarations */
+static unsigned int
+label_hash (void *p);
+static int
+label_cmp (const void *p1, const void *p2);
+static int
+nhlfe_nexthop_active_ipv4 (zebra_nhlfe_t *nhlfe, struct nexthop *nexthop);
+static int
+nhlfe_nexthop_active_ipv6 (zebra_nhlfe_t *nhlfe, struct nexthop *nexthop);
+static int
+nhlfe_nexthop_active (zebra_nhlfe_t *nhlfe);
+static void
+lsp_select_best_nhlfe (zebra_lsp_t *lsp);
+static void
+lsp_uninstall_from_kernel (struct hash_backet *backet, void *ctxt);
+static void
+lsp_schedule (struct hash_backet *backet, void *ctxt);
+static wq_item_status
+lsp_process (struct work_queue *wq, void *data);
+static void
+lsp_processq_del (struct work_queue *wq, void *data);
+static void
+lsp_processq_complete (struct work_queue *wq);
+static int
+lsp_processq_add (zebra_lsp_t *lsp);
+static void *
+lsp_alloc (void *p);
+static char *
+nhlfe2str (zebra_nhlfe_t *nhlfe, char *buf, int size);
+static int
+nhlfe_nhop_match (zebra_nhlfe_t *nhlfe, enum nexthop_types_t gtype,
+                  union g_addr *gate, char *ifname, ifindex_t ifindex);
+static zebra_nhlfe_t *
+nhlfe_find (zebra_lsp_t *lsp, enum lsp_types_t lsp_type,
+            enum nexthop_types_t gtype, union g_addr *gate,
+            char *ifname, ifindex_t ifindex);
+static zebra_nhlfe_t *
+nhlfe_add (zebra_lsp_t *lsp, enum lsp_types_t lsp_type,
+           enum nexthop_types_t gtype, union g_addr *gate,
+           char *ifname, ifindex_t ifindex, mpls_label_t out_label);
+static int
+nhlfe_del (zebra_nhlfe_t *snhlfe);
+static int
+mpls_lsp_uninstall_all (struct hash *lsp_table, zebra_lsp_t *lsp,
+			enum lsp_types_t type);
+static int
+mpls_static_lsp_uninstall_all (struct zebra_vrf *zvrf, mpls_label_t in_label);
+static void
+nhlfe_print (zebra_nhlfe_t *nhlfe, struct vty *vty);
+static void
+lsp_print (zebra_lsp_t *lsp, void *ctxt);
+static void *
+slsp_alloc (void *p);
+static int
+snhlfe_match (zebra_snhlfe_t *snhlfe, enum nexthop_types_t gtype,
+              union g_addr *gate, char *ifname, ifindex_t ifindex);
+static zebra_snhlfe_t *
+snhlfe_find (zebra_slsp_t *slsp, enum nexthop_types_t gtype,
+             union g_addr *gate, char *ifname, ifindex_t ifindex);
+static zebra_snhlfe_t *
+snhlfe_add (zebra_slsp_t *slsp, enum nexthop_types_t gtype,
+            union g_addr *gate, char *ifname, ifindex_t ifindex,
+            mpls_label_t out_label);
+static int
+snhlfe_del (zebra_snhlfe_t *snhlfe);
+static int
+snhlfe_del_all (zebra_slsp_t *slsp);
+static char *
+snhlfe2str (zebra_snhlfe_t *snhlfe, char *buf, int size);
+static void
+mpls_processq_init (struct zebra_t *zebra);
+
+
+
+
+/* Static functions */
+
+/*
+ * Hash function for label.
+ */
+static unsigned int
+label_hash (void *p)
+{
+  const zebra_ile_t *ile = p;
+
+  return (jhash_1word(ile->in_label, 0));
+}
+
+/*
+ * Compare 2 LSP hash entries based on in-label.
+ */
+static int
+label_cmp (const void *p1, const void *p2)
+{
+  const zebra_ile_t *ile1 = p1;
+  const zebra_ile_t *ile2 = p2;
+
+  return (ile1->in_label == ile2->in_label);
+}
+
+/*
+ * Check if an IPv4 nexthop for a NHLFE is active. Update nexthop based on
+ * the passed flag.
+ * NOTE: Looking only for connected routes right now.
+ */
+static int
+nhlfe_nexthop_active_ipv4 (zebra_nhlfe_t *nhlfe, struct nexthop *nexthop)
+{
+  struct route_table *table;
+  struct prefix_ipv4 p;
+  struct route_node *rn;
+  struct rib *match;
+
+  table = zebra_vrf_table (AFI_IP, SAFI_UNICAST, VRF_DEFAULT);
+  if (!table)
+    return 0;
+
+  /* Lookup nexthop in IPv4 routing table. */
+  memset (&p, 0, sizeof (struct prefix_ipv4));
+  p.family = AF_INET;
+  p.prefixlen = IPV4_MAX_PREFIXLEN;
+  p.prefix = nexthop->gate.ipv4;
+
+  rn = route_node_match (table, (struct prefix *) &p);
+  if (!rn)
+    return 0;
+
+  route_unlock_node (rn);
+
+  /* Locate a valid connected route. */
+  RNODE_FOREACH_RIB (rn, match)
+    {
+      if ((match->type == ZEBRA_ROUTE_CONNECT) &&
+          !CHECK_FLAG (match->status, RIB_ENTRY_REMOVED) &&
+          CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
+        break;
+    }
+
+  if (!match || !match->nexthop)
+    return 0;
+
+  nexthop->ifindex = match->nexthop->ifindex;
+  return 1;
+}
+
+
+/*
+ * Check if an IPv6 nexthop for a NHLFE is active. Update nexthop based on
+ * the passed flag.
+ * NOTE: Looking only for connected routes right now.
+ */
+static int
+nhlfe_nexthop_active_ipv6 (zebra_nhlfe_t *nhlfe, struct nexthop *nexthop)
+{
+  struct route_table *table;
+  struct prefix_ipv6 p;
+  struct route_node *rn;
+  struct rib *match;
+
+  table = zebra_vrf_table (AFI_IP6, SAFI_UNICAST, VRF_DEFAULT);
+  if (!table)
+    return 0;
+
+  /* Lookup nexthop in IPv6 routing table. */
+  memset (&p, 0, sizeof (struct prefix_ipv6));
+  p.family = AF_INET6;
+  p.prefixlen = IPV6_MAX_PREFIXLEN;
+  p.prefix = nexthop->gate.ipv6;
+
+  rn = route_node_match (table, (struct prefix *) &p);
+  if (!rn)
+    return 0;
+
+  route_unlock_node (rn);
+
+  /* Locate a valid connected route. */
+  RNODE_FOREACH_RIB (rn, match)
+    {
+      if ((match->type == ZEBRA_ROUTE_CONNECT) &&
+          !CHECK_FLAG (match->status, RIB_ENTRY_REMOVED) &&
+          CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
+        break;
+    }
+
+  if (!match || !match->nexthop)
+    return 0;
+
+  nexthop->ifindex = match->nexthop->ifindex;
+  return 1;
+}
+
+
+/*
+ * Check the nexthop reachability for a NHLFE and return if valid (reachable)
+ * or not.
+ * NOTE: Each NHLFE points to only 1 nexthop.
+ */
+static int
+nhlfe_nexthop_active (zebra_nhlfe_t *nhlfe)
+{
+  struct nexthop *nexthop;
+  struct interface *ifp;
+
+  nexthop = nhlfe->nexthop;
+  if (!nexthop) // unexpected
+    return 0;
+
+  /* Check on nexthop based on type. */
+  switch (nexthop->type)
+    {
+      case NEXTHOP_TYPE_IPV4:
+        if (nhlfe_nexthop_active_ipv4 (nhlfe, nexthop))
+          SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+        else
+          UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+        break;
+
+      case NEXTHOP_TYPE_IPV6:
+        if (nhlfe_nexthop_active_ipv6 (nhlfe, nexthop))
+          SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+        else
+          UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+        break;
+
+      case NEXTHOP_TYPE_IPV6_IFINDEX:
+        if (IN6_IS_ADDR_LINKLOCAL (&nexthop->gate.ipv6))
+          {
+            ifp = if_lookup_by_index (nexthop->ifindex);
+            if (ifp && if_is_operative(ifp))
+              SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+            else
+              UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+          }
+        else
+          {
+            if (nhlfe_nexthop_active_ipv6 (nhlfe, nexthop))
+              SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+            else
+              UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+          }
+        break;
+
+    default:
+      break;
+    }
+
+  return CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+}
+
+/*
+ * Walk through NHLFEs for a LSP forwarding entry, verify nexthop
+ * reachability and select the best. Multipath entries are also
+ * marked. This is invoked when an LSP scheduled for processing (due
+ * to some change) is examined.
+ */
+static void
+lsp_select_best_nhlfe (zebra_lsp_t *lsp)
+{
+  zebra_nhlfe_t *nhlfe;
+  zebra_nhlfe_t *best;
+  struct nexthop *nexthop;
+  int changed = 0;
+
+  if (!lsp)
+    return;
+
+  best = NULL;
+  lsp->num_ecmp = 0;
+  UNSET_FLAG (lsp->flags, LSP_FLAG_CHANGED);
+
+  /*
+   * First compute the best path, after checking nexthop status. We are only
+   * concerned with non-deleted NHLFEs.
+   */
+  for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe->next)
+    {
+      /* Clear selection flags. */
+      UNSET_FLAG (nhlfe->flags,
+                  (NHLFE_FLAG_SELECTED | NHLFE_FLAG_MULTIPATH));
+
+      if (!CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_DELETED) &&
+          nhlfe_nexthop_active (nhlfe))
+        {
+          if (!best || (nhlfe->distance < best->distance))
+            best = nhlfe;
+        }
+    }
+
+  lsp->best_nhlfe = best;
+  if (!lsp->best_nhlfe)
+    return;
+
+  /* Mark best NHLFE as selected. */
+  SET_FLAG (lsp->best_nhlfe->flags, NHLFE_FLAG_SELECTED);
+
+  /*
+   * If best path exists, see if there is ECMP. While doing this, note if a
+   * new (uninstalled) NHLFE has been selected, an installed entry that is
+   * still selected has a change or an installed entry is to be removed.
+   */
+  for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe->next)
+    {
+      int nh_chg, nh_sel, nh_inst;
+
+      nexthop = nhlfe->nexthop;
+      if (!nexthop) // unexpected
+        continue;
+
+      if (!CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_DELETED) &&
+          CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE) &&
+          (nhlfe->distance == lsp->best_nhlfe->distance))
+        {
+          SET_FLAG (nhlfe->flags, NHLFE_FLAG_SELECTED);
+          SET_FLAG (nhlfe->flags, NHLFE_FLAG_MULTIPATH);
+          lsp->num_ecmp++;
+        }
+
+      if (CHECK_FLAG (lsp->flags, LSP_FLAG_INSTALLED) &&
+          !changed)
+        {
+          nh_chg = CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_CHANGED);
+          nh_sel = CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_SELECTED);
+          nh_inst = CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_INSTALLED);
+
+          if ((nh_sel && !nh_inst) ||
+              (nh_sel && nh_inst && nh_chg) ||
+              (nh_inst && !nh_sel))
+            changed = 1;
+        }
+
+      /* We have finished examining, clear changed flag. */
+      UNSET_FLAG (nhlfe->flags, NHLFE_FLAG_CHANGED);
+    }
+
+  if (changed)
+    SET_FLAG (lsp->flags, LSP_FLAG_CHANGED);
+}
+
+/*
+ * Delete LSP forwarding entry from kernel, if installed. Called upon
+ * process exit.
+ */
+static void
+lsp_uninstall_from_kernel (struct hash_backet *backet, void *ctxt)
+{
+  zebra_lsp_t *lsp;
+
+  lsp = (zebra_lsp_t *) backet->data;
+  if (CHECK_FLAG(lsp->flags, LSP_FLAG_INSTALLED))
+    kernel_del_lsp (lsp);
+}
+
+/*
+ * Schedule LSP forwarding entry for processing. Called upon changes
+ * that may impact LSPs such as nexthop / connected route changes.
+ */
+static void
+lsp_schedule (struct hash_backet *backet, void *ctxt)
+{
+  zebra_lsp_t *lsp;
+
+  lsp = (zebra_lsp_t *) backet->data;
+  lsp_processq_add (lsp);
+}
+
+/*
+ * Process a LSP entry that is in the queue. Recalculate best NHLFE and
+ * any multipaths and update or delete from the kernel, as needed.
+ */
+static wq_item_status
+lsp_process (struct work_queue *wq, void *data)
+{
+  zebra_lsp_t *lsp;
+  zebra_nhlfe_t *oldbest, *newbest;
+  char buf[BUFSIZ], buf2[BUFSIZ];
+
+  lsp = (zebra_lsp_t *)data;
+  if (!lsp) // unexpected
+    return WQ_SUCCESS;
+
+  oldbest = lsp->best_nhlfe;
+
+  /* Select best NHLFE(s) */
+  lsp_select_best_nhlfe (lsp);
+
+  newbest = lsp->best_nhlfe;
+
+  if (IS_ZEBRA_DEBUG_MPLS)
+    {
+      if (oldbest)
+        nhlfe2str (oldbest, buf, BUFSIZ);
+      if (newbest)
+        nhlfe2str (newbest, buf2, BUFSIZ);
+      zlog_debug ("Process LSP in-label %u oldbest %s newbest %s "
+                  "flags 0x%x ecmp# %d",
+                  lsp->ile.in_label, oldbest ? buf : "NULL",
+                  newbest ? buf2 : "NULL", lsp->flags, lsp->num_ecmp);
+    }
+
+  if (!CHECK_FLAG (lsp->flags, LSP_FLAG_INSTALLED))
+    {
+      /* Not already installed */
+      if (newbest)
+        kernel_add_lsp (lsp);
+    }
+  else
+    {
+      /* Installed, may need an update and/or delete. */
+      if (!newbest)
+        kernel_del_lsp (lsp);
+      else if (CHECK_FLAG (lsp->flags, LSP_FLAG_CHANGED))
+        kernel_upd_lsp (lsp);
+    }
+
+  return WQ_SUCCESS;
+}
+
+
+/*
+ * Callback upon processing completion of a LSP forwarding entry.
+ */
+static void
+lsp_processq_del (struct work_queue *wq, void *data)
+{
+  struct zebra_vrf *zvrf;
+  zebra_lsp_t *lsp;
+  struct hash *lsp_table;
+  zebra_nhlfe_t *nhlfe, *nhlfe_next;
+
+  zvrf = vrf_info_lookup(VRF_DEFAULT);
+  assert (zvrf);
+
+  lsp_table = zvrf->lsp_table;
+  if (!lsp_table) // unexpected
+    return;
+
+  lsp = (zebra_lsp_t *)data;
+  if (!lsp) // unexpected
+    return;
+
+  /* Clear flag, remove any NHLFEs marked for deletion. If no NHLFEs exist,
+   * delete LSP entry also.
+   */
+  UNSET_FLAG (lsp->flags, LSP_FLAG_SCHEDULED);
+
+  for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe_next)
+    {
+      nhlfe_next = nhlfe->next;
+      if (CHECK_FLAG(nhlfe->flags, NHLFE_FLAG_DELETED))
+        nhlfe_del (nhlfe);
+    }
+
+  if (!lsp->nhlfe_list)
+    {
+      if (IS_ZEBRA_DEBUG_MPLS)
+        zlog_debug ("Free LSP in-label %u flags 0x%x",
+                    lsp->ile.in_label, lsp->flags);
+
+      lsp = hash_release(lsp_table, &lsp->ile);
+      if (lsp)
+        XFREE(MTYPE_LSP, lsp);
+    }
+}
+
+/*
+ * Callback upon finishing the processing of all scheduled
+ * LSP forwarding entries.
+ */
+static void
+lsp_processq_complete (struct work_queue *wq)
+{
+  /* Nothing to do for now. */
+}
+
+/*
+ * Add LSP forwarding entry to queue for subsequent processing.
+ */
+static int
+lsp_processq_add (zebra_lsp_t *lsp)
+{
+  /* If already scheduled, exit. */
+  if (CHECK_FLAG (lsp->flags, LSP_FLAG_SCHEDULED))
+    return 0;
+
+  work_queue_add (zebrad.lsp_process_q, lsp);
+  SET_FLAG (lsp->flags, LSP_FLAG_SCHEDULED);
+  return 0;
+}
+
+/*
+ * Callback to allocate LSP forwarding table entry.
+ */
+static void *
+lsp_alloc (void *p)
+{
+  const zebra_ile_t *ile = p;
+  zebra_lsp_t *lsp;
+
+  lsp = XCALLOC (MTYPE_LSP, sizeof(zebra_lsp_t));
+  lsp->ile = *ile;
+
+  if (IS_ZEBRA_DEBUG_MPLS)
+    zlog_debug ("Alloc LSP in-label %u", lsp->ile.in_label);
+
+  return ((void *)lsp);
+}
+
+/*
+ * Create printable string for NHLFE entry.
+ */
+static char *
+nhlfe2str (zebra_nhlfe_t *nhlfe, char *buf, int size)
+{
+  struct nexthop *nexthop;
+
+  buf[0] = '\0';
+  nexthop = nhlfe->nexthop;
+  switch (nexthop->type)
+    {
+      case NEXTHOP_TYPE_IPV4:
+        inet_ntop (AF_INET, &nexthop->gate.ipv4, buf, size);
+        break;
+      case NEXTHOP_TYPE_IPV6:
+        inet_ntop (AF_INET6, &nexthop->gate.ipv6, buf, size);
+        break;
+      default:
+        break;
+    }
+
+  return buf;
+}
+
+/*
+ * Check if NHLFE matches with search info passed.
+ */
+static int
+nhlfe_nhop_match (zebra_nhlfe_t *nhlfe, enum nexthop_types_t gtype,
+                  union g_addr *gate, char *ifname, ifindex_t ifindex)
+{
+  struct nexthop *nhop;
+  int cmp = 1;
+
+  nhop = nhlfe->nexthop;
+  if (!nhop)
+    return 1;
+
+  if (nhop->type != gtype)
+    return 1;
+
+  switch (nhop->type)
+    {
+    case NEXTHOP_TYPE_IPV4:
+      cmp = memcmp(&(nhop->gate.ipv4), &(gate->ipv4),
+                   sizeof(struct in_addr));
+      break;
+    case NEXTHOP_TYPE_IPV6:
+    case NEXTHOP_TYPE_IPV6_IFINDEX:
+      cmp = memcmp(&(nhop->gate.ipv6), &(gate->ipv6),
+		   sizeof(struct in6_addr));
+      if (!cmp && nhop->type == NEXTHOP_TYPE_IPV6_IFINDEX)
+        cmp = !(nhop->ifindex == ifindex);
+      break;
+    default:
+      break;
+    }
+
+  return cmp;
+}
+
+
+/*
+ * Locate NHLFE that matches with passed info.
+ */
+static zebra_nhlfe_t *
+nhlfe_find (zebra_lsp_t *lsp, enum lsp_types_t lsp_type,
+            enum nexthop_types_t gtype, union g_addr *gate,
+            char *ifname, ifindex_t ifindex)
+{
+  zebra_nhlfe_t *nhlfe;
+
+  if (!lsp)
+    return NULL;
+
+  for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe->next)
+    {
+      if (nhlfe->type != lsp_type)
+        continue;
+      if (!nhlfe_nhop_match (nhlfe, gtype, gate, ifname, ifindex))
+        break;
+    }
+
+  return nhlfe;
+}
+
+/*
+ * Add NHLFE. Base entry must have been created and duplicate
+ * check done.
+ */
+static zebra_nhlfe_t *
+nhlfe_add (zebra_lsp_t *lsp, enum lsp_types_t lsp_type,
+           enum nexthop_types_t gtype, union g_addr *gate,
+           char *ifname, ifindex_t ifindex, mpls_label_t out_label)
+{
+  zebra_nhlfe_t *nhlfe;
+  struct nexthop *nexthop;
+
+  if (!lsp)
+    return NULL;
+
+  nhlfe = XCALLOC(MTYPE_NHLFE, sizeof(zebra_nhlfe_t));
+  if (!nhlfe)
+    return NULL;
+
+  nhlfe->lsp = lsp;
+  nhlfe->type = lsp_type;
+  nhlfe->distance = lsp_distance (lsp_type);
+
+  nexthop = XCALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
+  if (!nexthop)
+    {
+      XFREE (MTYPE_NHLFE, nhlfe);
+      return NULL;
+    }
+  nexthop_add_labels (nexthop, 1, &out_label);
+
+  nexthop->type = gtype;
+  switch (nexthop->type)
+    {
+    case NEXTHOP_TYPE_IPV4:
+      nexthop->gate.ipv4 = gate->ipv4;
+      break;
+    case NEXTHOP_TYPE_IPV6:
+    case NEXTHOP_TYPE_IPV6_IFINDEX:
+      nexthop->gate.ipv6 = gate->ipv6;
+      if (ifindex)
+        nexthop->ifindex = ifindex;
+      break;
+    default:
+      nexthop_free(nexthop);
+      XFREE (MTYPE_NHLFE, nhlfe);
+      return NULL;
+      break;
+    }
+
+  nhlfe->nexthop = nexthop;
+  if (lsp->nhlfe_list)
+    lsp->nhlfe_list->prev = nhlfe;
+  nhlfe->next = lsp->nhlfe_list;
+  lsp->nhlfe_list = nhlfe;
+
+  return nhlfe;
+}
+
+/*
+ * Delete NHLFE. Entry must be present on list.
+ */
+static int
+nhlfe_del (zebra_nhlfe_t *nhlfe)
+{
+  zebra_lsp_t *lsp;
+
+  if (!nhlfe)
+    return -1;
+
+  lsp = nhlfe->lsp;
+  if (!lsp)
+    return -1;
+
+  /* Free nexthop. */
+  if (nhlfe->nexthop)
+    nexthop_free(nhlfe->nexthop);
+
+  /* Unlink from LSP */
+  if (nhlfe->next)
+    nhlfe->next->prev = nhlfe->prev;
+  if (nhlfe->prev)
+    nhlfe->prev->next = nhlfe->next;
+  else
+    lsp->nhlfe_list = nhlfe->next;
+
+  XFREE (MTYPE_NHLFE, nhlfe);
+
+  return 0;
+}
+
+static int
+mpls_lsp_uninstall_all (struct hash *lsp_table, zebra_lsp_t *lsp,
+			enum lsp_types_t type)
+{
+  zebra_nhlfe_t *nhlfe, *nhlfe_next;
+  int schedule_lsp = 0;
+  char buf[BUFSIZ];
+
+  /* Mark NHLFEs for delete or directly delete, as appropriate. */
+  for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe_next)
+    {
+      nhlfe_next = nhlfe->next;
+
+      /* Skip non-static NHLFEs */
+      if (nhlfe->type != type)
+        continue;
+
+      if (IS_ZEBRA_DEBUG_MPLS)
+        {
+          nhlfe2str (nhlfe, buf, BUFSIZ);
+          zlog_debug ("Del LSP in-label %u type %d nexthop %s flags 0x%x",
+                      lsp->ile.in_label, type, buf, nhlfe->flags);
+        }
+
+      if (CHECK_FLAG(nhlfe->flags, NHLFE_FLAG_INSTALLED))
+        {
+          UNSET_FLAG (nhlfe->flags, NHLFE_FLAG_CHANGED);
+          SET_FLAG (nhlfe->flags, NHLFE_FLAG_DELETED);
+          schedule_lsp = 1;
+        }
+      else
+        {
+          nhlfe_del (nhlfe);
+        }
+    }
+
+  /* Queue LSP for processing, if needed, else delete. */
+  if (schedule_lsp)
+    {
+      if (lsp_processq_add (lsp))
+        return -1;
+    }
+  else if (!lsp->nhlfe_list &&
+           !CHECK_FLAG (lsp->flags, LSP_FLAG_SCHEDULED))
+    {
+      if (IS_ZEBRA_DEBUG_MPLS)
+        zlog_debug ("Free LSP in-label %u flags 0x%x",
+                    lsp->ile.in_label, lsp->flags);
+
+      lsp = hash_release(lsp_table, &lsp->ile);
+      if (lsp)
+        XFREE(MTYPE_LSP, lsp);
+    }
+
+  return 0;
+}
+
+/*
+ * Uninstall all static NHLFEs for a particular LSP forwarding entry.
+ * If no other NHLFEs exist, the entry would be deleted.
+ */
+static int
+mpls_static_lsp_uninstall_all (struct zebra_vrf *zvrf, mpls_label_t in_label)
+{
+  struct hash *lsp_table;
+  zebra_ile_t tmp_ile;
+  zebra_lsp_t *lsp;
+
+  /* Lookup table. */
+  lsp_table = zvrf->lsp_table;
+  if (!lsp_table)
+    return -1;
+
+  /* If entry is not present, exit. */
+  tmp_ile.in_label = in_label;
+  lsp = hash_lookup (lsp_table, &tmp_ile);
+  if (!lsp || !lsp->nhlfe_list)
+    return 0;
+
+  return mpls_lsp_uninstall_all (lsp_table, lsp, ZEBRA_LSP_STATIC);
+}
+
+/*
+ * Print the NHLFE for a LSP forwarding entry.
+ */
+static void
+nhlfe_print (zebra_nhlfe_t *nhlfe, struct vty *vty)
+{
+  struct nexthop *nexthop;
+  char buf[BUFSIZ];
+
+  nexthop = nhlfe->nexthop;
+  if (!nexthop || !nexthop->nh_label) // unexpected
+    return;
+
+  vty_out(vty, " type: %s remote label: %s distance: %d%s",
+          nhlfe_type2str(nhlfe->type),
+          label2str(nexthop->nh_label->label[0], buf, BUFSIZ),
+          nhlfe->distance, VTY_NEWLINE);
+  switch (nexthop->type)
+    {
+    case NEXTHOP_TYPE_IPV4:
+      vty_out (vty, "  via %s", inet_ntoa (nexthop->gate.ipv4));
+      break;
+    case NEXTHOP_TYPE_IPV6:
+    case NEXTHOP_TYPE_IPV6_IFINDEX:
+      vty_out (vty, "  via %s",
+               inet_ntop (AF_INET6, &nexthop->gate.ipv6, buf, BUFSIZ));
+      if (nexthop->ifindex)
+        vty_out (vty, " dev %s", ifindex2ifname (nexthop->ifindex));
+      break;
+    default:
+      break;
+    }
+  vty_out(vty, "%s", CHECK_FLAG (nhlfe->flags, NHLFE_FLAG_INSTALLED) ?
+          " (installed)" : "");
+  vty_out(vty, "%s", VTY_NEWLINE);
+}
+
+/*
+ * Print an LSP forwarding entry.
+ */
+static void
+lsp_print (zebra_lsp_t *lsp, void *ctxt)
+{
+  zebra_nhlfe_t *nhlfe;
+  struct vty *vty;
+
+  vty = (struct vty *) ctxt;
+
+  vty_out(vty, "Local label: %u%s%s",
+          lsp->ile.in_label,
+          CHECK_FLAG (lsp->flags, LSP_FLAG_INSTALLED) ? " (installed)" : "",
+          VTY_NEWLINE);
+
+  for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe->next)
+    nhlfe_print (nhlfe, vty);
+}
+
+/* Return a sorted linked list of the hash contents */
+static struct list *
+hash_get_sorted_list (struct hash *hash, void *cmp)
+{
+  unsigned int i;
+  struct hash_backet *hb;
+  struct list *sorted_list = list_new();
+
+  sorted_list->cmp = (int (*)(void *, void *)) cmp;
+
+  for (i = 0; i < hash->size; i++)
+    for (hb = hash->index[i]; hb; hb = hb->next)
+        listnode_add_sort(sorted_list, hb->data);
+
+  return sorted_list;
+}
+
+/*
+ * Compare two LSPs based on their label values.
+ */
+static int
+lsp_cmp (zebra_lsp_t *lsp1, zebra_lsp_t *lsp2)
+{
+  if (lsp1->ile.in_label < lsp2->ile.in_label)
+    return -1;
+
+  if (lsp1->ile.in_label > lsp2->ile.in_label)
+    return 1;
+
+  return 0;
+}
+
+/*
+ * Callback to allocate static LSP.
+ */
+static void *
+slsp_alloc (void *p)
+{
+  const zebra_ile_t *ile = p;
+  zebra_slsp_t *slsp;
+
+  slsp = XCALLOC (MTYPE_SLSP, sizeof(zebra_slsp_t));
+  slsp->ile = *ile;
+  return ((void *)slsp);
+}
+
+/*
+ * Compare two static LSPs based on their label values.
+ */
+static int
+slsp_cmp (zebra_slsp_t *slsp1, zebra_slsp_t *slsp2)
+{
+  if (slsp1->ile.in_label < slsp2->ile.in_label)
+    return -1;
+
+  if (slsp1->ile.in_label > slsp2->ile.in_label)
+    return 1;
+
+  return 0;
+}
+
+/*
+ * Check if static NHLFE matches with search info passed.
+ */
+static int
+snhlfe_match (zebra_snhlfe_t *snhlfe, enum nexthop_types_t gtype,
+              union g_addr *gate, char *ifname, ifindex_t ifindex)
+{
+  int cmp = 1;
+
+  if (snhlfe->gtype != gtype)
+    return 1;
+
+  switch (snhlfe->gtype)
+    {
+    case NEXTHOP_TYPE_IPV4:
+      cmp = memcmp(&(snhlfe->gate.ipv4), &(gate->ipv4),
+		   sizeof(struct in_addr));
+      break;
+    case NEXTHOP_TYPE_IPV6:
+    case NEXTHOP_TYPE_IPV6_IFINDEX:
+      cmp = memcmp(&(snhlfe->gate.ipv6), &(gate->ipv6),
+		   sizeof(struct in6_addr));
+      if (!cmp && snhlfe->gtype == NEXTHOP_TYPE_IPV6_IFINDEX)
+        cmp = !(snhlfe->ifindex == ifindex);
+      break;
+    default:
+      break;
+    }
+
+  return cmp;
+}
+
+/*
+ * Locate static NHLFE that matches with passed info.
+ */
+static zebra_snhlfe_t *
+snhlfe_find (zebra_slsp_t *slsp, enum nexthop_types_t gtype,
+             union g_addr *gate, char *ifname, ifindex_t ifindex)
+{
+  zebra_snhlfe_t *snhlfe;
+
+  if (!slsp)
+    return NULL;
+
+  for (snhlfe = slsp->snhlfe_list; snhlfe; snhlfe = snhlfe->next)
+    {
+      if (!snhlfe_match (snhlfe, gtype, gate, ifname, ifindex))
+        break;
+    }
+
+  return snhlfe;
+}
+
+
+/*
+ * Add static NHLFE. Base LSP config entry must have been created
+ * and duplicate check done.
+ */
+static zebra_snhlfe_t *
+snhlfe_add (zebra_slsp_t *slsp, enum nexthop_types_t gtype,
+            union g_addr *gate, char *ifname, ifindex_t ifindex,
+            mpls_label_t out_label)
+{
+  zebra_snhlfe_t *snhlfe;
+
+  if (!slsp)
+    return NULL;
+
+  snhlfe = XCALLOC(MTYPE_SNHLFE, sizeof(zebra_snhlfe_t));
+  snhlfe->slsp = slsp;
+  snhlfe->out_label = out_label;
+  snhlfe->gtype = gtype;
+  switch (gtype)
+    {
+    case NEXTHOP_TYPE_IPV4:
+      snhlfe->gate.ipv4 = gate->ipv4;
+      break;
+    case NEXTHOP_TYPE_IPV6:
+    case NEXTHOP_TYPE_IPV6_IFINDEX:
+      snhlfe->gate.ipv6 = gate->ipv6;
+      if (ifindex)
+        snhlfe->ifindex = ifindex;
+      break;
+    default:
+      XFREE (MTYPE_SNHLFE, snhlfe);
+      return NULL;
+    }
+
+  if (slsp->snhlfe_list)
+    slsp->snhlfe_list->prev = snhlfe;
+  snhlfe->next = slsp->snhlfe_list;
+  slsp->snhlfe_list = snhlfe;
+
+  return snhlfe;
+}
+
+/*
+ * Delete static NHLFE. Entry must be present on list.
+ */
+static int
+snhlfe_del (zebra_snhlfe_t *snhlfe)
+{
+  zebra_slsp_t *slsp;
+
+  if (!snhlfe)
+    return -1;
+
+  slsp = snhlfe->slsp;
+  if (!slsp)
+    return -1;
+
+  if (snhlfe->next)
+    snhlfe->next->prev = snhlfe->prev;
+  if (snhlfe->prev)
+    snhlfe->prev->next = snhlfe->next;
+  else
+    slsp->snhlfe_list = snhlfe->next;
+
+  snhlfe->prev = snhlfe->next = NULL;
+  if (snhlfe->ifname)
+    XFREE (0, snhlfe->ifname);
+  XFREE (MTYPE_SNHLFE, snhlfe);
+
+  return 0;
+}
+
+/*
+ * Delete all static NHLFE entries for this LSP (in label).
+ */
+static int
+snhlfe_del_all (zebra_slsp_t *slsp)
+{
+  zebra_snhlfe_t *snhlfe, *snhlfe_next;
+
+  if (!slsp)
+    return -1;
+
+  for (snhlfe = slsp->snhlfe_list; snhlfe; snhlfe = snhlfe_next)
+    {
+      snhlfe_next = snhlfe->next;
+      snhlfe_del (snhlfe);
+    }
+
+  return 0;
+}
+
+/*
+ * Create printable string for NHLFE configuration.
+ */
+static char *
+snhlfe2str (zebra_snhlfe_t *snhlfe, char *buf, int size)
+{
+  buf[0] = '\0';
+  switch (snhlfe->gtype)
+    {
+      case NEXTHOP_TYPE_IPV4:
+        inet_ntop (AF_INET, &snhlfe->gate.ipv4, buf, size);
+        break;
+      case NEXTHOP_TYPE_IPV6:
+      case NEXTHOP_TYPE_IPV6_IFINDEX:
+        inet_ntop (AF_INET6, &snhlfe->gate.ipv6, buf, size);
+        if (snhlfe->ifindex)
+          strcat (buf, ifindex2ifname (snhlfe->ifindex));
+        break;
+      default:
+        break;
+    }
+
+  return buf;
+}
+
+/*
+ * Initialize work queue for processing changed LSPs.
+ */
+static void
+mpls_processq_init (struct zebra_t *zebra)
+{
+  zebra->lsp_process_q = work_queue_new (zebra->master, "LSP processing");
+  if (!zebra->lsp_process_q)
+    {
+      zlog_err ("%s: could not initialise work queue!", __func__);
+      return;
+    }
+
+  zebra->lsp_process_q->spec.workfunc = &lsp_process;
+  zebra->lsp_process_q->spec.del_item_data = &lsp_processq_del;
+  zebra->lsp_process_q->spec.errorfunc = NULL;
+  zebra->lsp_process_q->spec.completion_func = &lsp_processq_complete;
+  zebra->lsp_process_q->spec.max_retries = 0;
+  zebra->lsp_process_q->spec.hold = 10;
+}
+
+
+
+/* Public functions */
+
+/*
+ * String to label conversion, labels separated by '/'.
+ */
+int
+mpls_str2label (const char *label_str, u_int8_t *num_labels,
+                mpls_label_t *labels)
+{
+  char *endp;
+  int i;
+
+  *num_labels = 0;
+  for (i = 0; i < MPLS_MAX_LABELS; i++)
+    {
+      u_int32_t label;
+
+      label = strtoul(label_str, &endp, 0);
+
+      /* validity checks */
+      if (endp == label_str)
+        return -1;
+
+      if (!IS_MPLS_UNRESERVED_LABEL(label))
+        return -1;
+
+      labels[i] = label;
+      if (*endp == '\0')
+        {
+          *num_labels = i + 1;
+          return 0;
+        }
+
+      /* Check separator. */
+      if (*endp != '/')
+        return -1;
+
+      label_str = endp + 1;
+    }
+
+  /* Too many labels. */
+  return -1;
+}
+
+/*
+ * Label to string conversion, labels in string separated by '/'.
+ */
+char *
+mpls_label2str (u_int8_t num_labels, mpls_label_t *labels,
+                char *buf, int len)
+{
+  buf[0] = '\0';
+  if (num_labels == 1)
+    snprintf (buf, len, "%u", labels[0]);
+  else if (num_labels == 2)
+    snprintf (buf, len, "%u/%u", labels[0], labels[1]);
+  return buf;
+}
+
+/*
+ * Install/update a NHLFE for an LSP in the forwarding table. This may be
+ * a new LSP entry or a new NHLFE for an existing in-label or an update of
+ * the out-label for an existing NHLFE (update case).
+ */
+int
+mpls_lsp_install (struct zebra_vrf *zvrf, enum lsp_types_t type,
+		  mpls_label_t in_label, mpls_label_t out_label,
+		  enum nexthop_types_t gtype, union g_addr *gate,
+		  char *ifname, ifindex_t ifindex)
+{
+  struct hash *lsp_table;
+  zebra_ile_t tmp_ile;
+  zebra_lsp_t *lsp;
+  zebra_nhlfe_t *nhlfe;
+  char buf[BUFSIZ];
+
+  /* Lookup table. */
+  lsp_table = zvrf->lsp_table;
+  if (!lsp_table)
+    return -1;
+
+  /* If entry is present, exit. */
+  tmp_ile.in_label = in_label;
+  lsp = hash_get (lsp_table, &tmp_ile, lsp_alloc);
+  if (!lsp)
+    return -1;
+  nhlfe = nhlfe_find (lsp, type, gtype, gate, ifname, ifindex);
+  if (nhlfe)
+    {
+      struct nexthop *nh = nhlfe->nexthop;
+
+      assert (nh);
+      assert (nh->nh_label);
+
+      /* Clear deleted flag (in case it was set) */
+      UNSET_FLAG (nhlfe->flags, NHLFE_FLAG_DELETED);
+      if (nh->nh_label->label[0] == out_label)
+        /* No change */
+        return 0;
+
+      if (IS_ZEBRA_DEBUG_MPLS)
+        {
+          nhlfe2str (nhlfe, buf, BUFSIZ);
+          zlog_debug ("LSP in-label %u type %d nexthop %s "
+                      "out-label changed to %u (old %u)",
+                      in_label, type, buf,
+                      out_label, nh->nh_label->label[0]);
+        }
+
+      /* Update out label, trigger processing. */
+      nh->nh_label->label[0] = out_label;
+    }
+  else
+    {
+      /* Add LSP entry to this nexthop */
+      nhlfe = nhlfe_add (lsp, type, gtype, gate,
+                         ifname, ifindex, out_label);
+      if (!nhlfe)
+        return -1;
+
+      if (IS_ZEBRA_DEBUG_MPLS)
+        {
+          nhlfe2str (nhlfe, buf, BUFSIZ);
+          zlog_debug ("Add LSP in-label %u type %d nexthop %s "
+                      "out-label %u", in_label, type, buf, out_label);
+        }
+
+      lsp->addr_family = NHLFE_FAMILY (nhlfe);
+    }
+
+  /* Mark NHLFE, queue LSP for processing. */
+  SET_FLAG(nhlfe->flags, NHLFE_FLAG_CHANGED);
+  if (lsp_processq_add (lsp))
+    return -1;
+
+  return 0;
+}
+
+/*
+ * Uninstall a particular NHLFE in the forwarding table. If this is
+ * the only NHLFE, the entire LSP forwarding entry has to be deleted.
+ */
+int
+mpls_lsp_uninstall (struct zebra_vrf *zvrf, enum lsp_types_t type,
+		    mpls_label_t in_label, enum nexthop_types_t gtype,
+		    union g_addr *gate, char *ifname, ifindex_t ifindex)
+{
+  struct hash *lsp_table;
+  zebra_ile_t tmp_ile;
+  zebra_lsp_t *lsp;
+  zebra_nhlfe_t *nhlfe;
+  char buf[BUFSIZ];
+
+  /* Lookup table. */
+  lsp_table = zvrf->lsp_table;
+  if (!lsp_table)
+    return -1;
+
+  /* If entry is not present, exit. */
+  tmp_ile.in_label = in_label;
+  lsp = hash_lookup (lsp_table, &tmp_ile);
+  if (!lsp)
+    return 0;
+  nhlfe = nhlfe_find (lsp, type, gtype, gate, ifname, ifindex);
+  if (!nhlfe)
+    return 0;
+
+  if (IS_ZEBRA_DEBUG_MPLS)
+    {
+      nhlfe2str (nhlfe, buf, BUFSIZ);
+      zlog_debug ("Del LSP in-label %u type %d nexthop %s flags 0x%x",
+                  in_label, type, buf, nhlfe->flags);
+    }
+
+  /* Mark NHLFE for delete or directly delete, as appropriate. */
+  if (CHECK_FLAG(nhlfe->flags, NHLFE_FLAG_INSTALLED))
+    {
+      UNSET_FLAG (nhlfe->flags, NHLFE_FLAG_CHANGED);
+      SET_FLAG (nhlfe->flags, NHLFE_FLAG_DELETED);
+      if (lsp_processq_add (lsp))
+        return -1;
+    }
+  else
+    {
+      nhlfe_del (nhlfe);
+
+      /* Free LSP entry if no other NHLFEs and not scheduled. */
+      if (!lsp->nhlfe_list &&
+          !CHECK_FLAG (lsp->flags, LSP_FLAG_SCHEDULED))
+        {
+          if (IS_ZEBRA_DEBUG_MPLS)
+            zlog_debug ("Free LSP in-label %u flags 0x%x",
+                        lsp->ile.in_label, lsp->flags);
+
+          lsp = hash_release(lsp_table, &lsp->ile);
+          if (lsp)
+            XFREE(MTYPE_LSP, lsp);
+        }
+    }
+  return 0;
+}
+
+/*
+ * Uninstall all LDP NHLFEs for a particular LSP forwarding entry.
+ * If no other NHLFEs exist, the entry would be deleted.
+ */
+void
+mpls_ldp_lsp_uninstall_all (struct hash_backet *backet, void *ctxt)
+{
+  zebra_lsp_t *lsp;
+  struct zebra_vrf *zvrf;
+  struct hash *lsp_table;
+
+  lsp = (zebra_lsp_t *) backet->data;
+  if (!lsp || !lsp->nhlfe_list)
+    return;
+
+  zvrf = ctxt;
+  lsp_table = zvrf->lsp_table;
+  if (!lsp_table)
+    return;
+
+  mpls_lsp_uninstall_all (lsp_table, lsp, ZEBRA_LSP_LDP);
+}
+
+/*
+ * Check that the label values used in LSP creation are consistent. The
+ * main criteria is that if there is ECMP, the label operation must still
+ * be consistent - i.e., all paths either do a swap or do PHP. This is due
+ * to current HW restrictions.
+ */
+int
+zebra_mpls_lsp_label_consistent (struct zebra_vrf *zvrf, mpls_label_t in_label,
+                     mpls_label_t out_label, enum nexthop_types_t gtype,
+                     union g_addr *gate, char *ifname, ifindex_t ifindex)
+{
+  struct hash *slsp_table;
+  zebra_ile_t tmp_ile;
+  zebra_slsp_t *slsp;
+  zebra_snhlfe_t *snhlfe;
+
+  /* Lookup table. */
+  slsp_table = zvrf->slsp_table;
+  if (!slsp_table)
+    return 0;
+
+  /* If entry is not present, exit. */
+  tmp_ile.in_label = in_label;
+  slsp = hash_lookup (slsp_table, &tmp_ile);
+  if (!slsp)
+    return 1;
+
+  snhlfe = snhlfe_find (slsp, gtype, gate, ifname, ifindex);
+  if (snhlfe)
+    {
+      if (snhlfe->out_label == out_label)
+        return 1;
+
+      /* If not only NHLFE, cannot allow label change. */
+      if (snhlfe != slsp->snhlfe_list ||
+          snhlfe->next)
+        return 0;
+    }
+  else
+    {
+      /* If other NHLFEs exist, label operation must match. */
+      if (slsp->snhlfe_list)
+        {
+          int cur_op, new_op;
+
+          cur_op = (slsp->snhlfe_list->out_label == MPLS_IMP_NULL_LABEL);
+          new_op = (out_label == MPLS_IMP_NULL_LABEL);
+          if (cur_op != new_op)
+            return 0;
+        }
+    }
+
+  /* Label values are good. */
+  return 1;
+}
+
+
+/*
+ * Add static LSP entry. This may be the first entry for this incoming label
+ * or an additional nexthop; an existing entry may also have outgoing label
+ * changed.
+ * Note: The label operation (swap or PHP) is common for the LSP entry (all
+ * NHLFEs).
+ */
+int
+zebra_mpls_static_lsp_add (struct zebra_vrf *zvrf, mpls_label_t in_label,
+                     mpls_label_t out_label, enum nexthop_types_t gtype,
+                     union g_addr *gate, char *ifname, ifindex_t ifindex)
+{
+  struct hash *slsp_table;
+  zebra_ile_t tmp_ile;
+  zebra_slsp_t *slsp;
+  zebra_snhlfe_t *snhlfe;
+  char buf[BUFSIZ];
+
+  /* Lookup table. */
+  slsp_table = zvrf->slsp_table;
+  if (!slsp_table)
+    return -1;
+
+  /* If entry is present, exit. */
+  tmp_ile.in_label = in_label;
+  slsp = hash_get (slsp_table, &tmp_ile, slsp_alloc);
+  if (!slsp)
+    return -1;
+  snhlfe = snhlfe_find (slsp, gtype, gate, ifname, ifindex);
+  if (snhlfe)
+    {
+      if (snhlfe->out_label == out_label)
+        /* No change */
+        return 0;
+
+      if (IS_ZEBRA_DEBUG_MPLS)
+        {
+          snhlfe2str (snhlfe, buf, BUFSIZ);
+          zlog_debug ("Upd static LSP in-label %u nexthop %s "
+                      "out-label %u (old %u)",
+                      in_label, buf, out_label, snhlfe->out_label);
+        }
+      snhlfe->out_label = out_label;
+    }
+  else
+    {
+      /* Add static LSP entry to this nexthop */
+      snhlfe = snhlfe_add (slsp, gtype, gate, ifname, ifindex, out_label);
+      if (!snhlfe)
+        return -1;
+
+      if (IS_ZEBRA_DEBUG_MPLS)
+        {
+          snhlfe2str (snhlfe, buf, BUFSIZ);
+          zlog_debug ("Add static LSP in-label %u nexthop %s out-label %u",
+                      in_label, buf, out_label);
+        }
+    }
+
+  /* (Re)Install LSP in the main table. */
+  if (mpls_lsp_install (zvrf, ZEBRA_LSP_STATIC, in_label, out_label, gtype,
+      gate, ifname, ifindex))
+    return -1;
+
+  return 0;
+}
+
+/*
+ * Delete static LSP entry. This may be the delete of one particular
+ * NHLFE for this incoming label or the delete of the entire entry (i.e.,
+ * all NHLFEs).
+ * NOTE: Delete of the only NHLFE will also end up deleting the entire
+ * LSP configuration.
+ */
+int
+zebra_mpls_static_lsp_del (struct zebra_vrf *zvrf, mpls_label_t in_label,
+                           enum nexthop_types_t gtype, union g_addr *gate,
+                           char *ifname, ifindex_t ifindex)
+{
+  struct hash *slsp_table;
+  zebra_ile_t tmp_ile;
+  zebra_slsp_t *slsp;
+  zebra_snhlfe_t *snhlfe;
+
+  /* Lookup table. */
+  slsp_table = zvrf->slsp_table;
+  if (!slsp_table)
+    return -1;
+
+  /* If entry is not present, exit. */
+  tmp_ile.in_label = in_label;
+  slsp = hash_lookup (slsp_table, &tmp_ile);
+  if (!slsp)
+    return 0;
+
+  /* Is it delete of entire LSP or a specific NHLFE? */
+  if (gtype == NEXTHOP_TYPE_BLACKHOLE)
+    {
+      if (IS_ZEBRA_DEBUG_MPLS)
+        zlog_debug ("Del static LSP in-label %u", in_label);
+
+      /* Uninstall entire LSP from the main table. */
+      mpls_static_lsp_uninstall_all (zvrf, in_label);
+
+      /* Delete all static NHLFEs */
+      snhlfe_del_all (slsp);
+    }
+  else
+    {
+      /* Find specific NHLFE, exit if not found. */
+      snhlfe = snhlfe_find (slsp, gtype, gate, ifname, ifindex);
+      if (!snhlfe)
+        return 0;
+
+      if (IS_ZEBRA_DEBUG_MPLS)
+        {
+          char buf[BUFSIZ];
+          snhlfe2str (snhlfe, buf, BUFSIZ);
+          zlog_debug ("Del static LSP in-label %u nexthop %s",
+                      in_label, buf);
+        }
+
+      /* Uninstall LSP from the main table. */
+      mpls_lsp_uninstall (zvrf, ZEBRA_LSP_STATIC, in_label, gtype, gate,
+			  ifname, ifindex);
+
+      /* Delete static LSP NHLFE */
+      snhlfe_del (snhlfe);
+    }
+
+  /* Remove entire static LSP entry if no NHLFE - valid in either case above. */
+  if (!slsp->snhlfe_list)
+    {
+      slsp = hash_release(slsp_table, &tmp_ile);
+      if (slsp)
+        XFREE(MTYPE_SLSP, slsp);
+    }
+
+  return 0;
+}
+
+/*
+ * Schedule all MPLS label forwarding entries for processing.
+ * Called upon changes that may affect one or more of them such as
+ * interface or nexthop state changes.
+ */
+void
+zebra_mpls_lsp_schedule (struct zebra_vrf *zvrf)
+{
+  if (!zvrf)
+    return;
+  hash_iterate(zvrf->lsp_table, lsp_schedule, NULL);
+}
+
+/*
+ * Display MPLS label forwarding table for a specific LSP
+ * (VTY command handler).
+ */
+void
+zebra_mpls_print_lsp (struct vty *vty, struct zebra_vrf *zvrf, mpls_label_t label)
+{
+  struct hash *lsp_table;
+  zebra_lsp_t *lsp;
+  zebra_ile_t tmp_ile;
+
+  /* Lookup table. */
+  lsp_table = zvrf->lsp_table;
+  if (!lsp_table)
+    return;
+
+  /* If entry is not present, exit. */
+  tmp_ile.in_label = label;
+  lsp = hash_lookup (lsp_table, &tmp_ile);
+  if (!lsp)
+    return;
+
+  lsp_print (lsp, (void *)vty);
+}
+
+/*
+ * Display MPLS label forwarding table (VTY command handler).
+ */
+void
+zebra_mpls_print_lsp_table (struct vty *vty, struct zebra_vrf *zvrf)
+{
+  char buf[BUFSIZ];
+  zebra_lsp_t *lsp = NULL;
+  zebra_nhlfe_t *nhlfe = NULL;
+  struct nexthop *nexthop = NULL;
+  struct listnode *node = NULL;
+  struct list *lsp_list = hash_get_sorted_list(zvrf->lsp_table, lsp_cmp);
+
+  vty_out (vty, " Inbound                            Outbound%s", VTY_NEWLINE);
+  vty_out (vty, "   Label     Type          Nexthop     Label%s", VTY_NEWLINE);
+  vty_out (vty, "--------  -------  ---------------  --------%s", VTY_NEWLINE);
+
+  for (ALL_LIST_ELEMENTS_RO(lsp_list, node, lsp))
+    {
+      for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe->next)
+        {
+          vty_out (vty, "%8d  %7s  ", lsp->ile.in_label, nhlfe_type2str(nhlfe->type));
+          nexthop = nhlfe->nexthop;
+
+          switch (nexthop->type)
+            {
+              case NEXTHOP_TYPE_IPV4:
+                vty_out (vty, "%15s", inet_ntoa (nexthop->gate.ipv4));
+                break;
+              case NEXTHOP_TYPE_IPV6:
+              case NEXTHOP_TYPE_IPV6_IFINDEX:
+                vty_out (vty, "%15s", inet_ntop (AF_INET6, &nexthop->gate.ipv6, buf, BUFSIZ));
+                break;
+              default:
+                break;
+            }
+
+          vty_out (vty, "  %8d%s", nexthop->nh_label->label[0], VTY_NEWLINE);
+        }
+    }
+
+  vty_out (vty, "%s", VTY_NEWLINE);
+
+  list_delete_all_node(lsp_list);
+}
+
+/*
+ * Display MPLS LSP configuration of all static LSPs (VTY command handler).
+ */
+int
+zebra_mpls_write_lsp_config (struct vty *vty, struct zebra_vrf *zvrf)
+{
+  zebra_slsp_t *slsp;
+  zebra_snhlfe_t *snhlfe;
+  struct listnode *node;
+  char buf[INET6_ADDRSTRLEN];
+  struct list *slsp_list = hash_get_sorted_list(zvrf->slsp_table, slsp_cmp);
+
+  for (ALL_LIST_ELEMENTS_RO(slsp_list, node, slsp))
+      {
+        for (snhlfe = slsp->snhlfe_list; snhlfe; snhlfe = snhlfe->next)
+          {
+            char lstr[30];
+            snhlfe2str (snhlfe, buf, BUFSIZ);
+            vty_out (vty, "mpls lsp %u %s %s%s",
+                     slsp->ile.in_label, buf,
+                     label2str(snhlfe->out_label, lstr, 30), VTY_NEWLINE);
+          }
+      }
+
+  list_delete_all_node(slsp_list);
+  return (zvrf->slsp_table->count ? 1 : 0);
+}
+
+/*
+ * Called upon process exiting, need to delete LSP forwarding
+ * entries from the kernel.
+ * NOTE: Currently supported only for default VRF.
+ */
+void
+zebra_mpls_close_tables (struct zebra_vrf *zvrf)
+{
+  if (!zvrf)
+    return;
+  hash_iterate(zvrf->lsp_table, lsp_uninstall_from_kernel, NULL);
+}
+
+/*
+ * Allocate MPLS tables for this VRF and do other initialization.
+ * NOTE: Currently supported only for default VRF.
+ */
+void
+zebra_mpls_init_tables (struct zebra_vrf *zvrf)
+{
+  if (!zvrf)
+    return;
+  zvrf->slsp_table = hash_create(label_hash, label_cmp);
+  zvrf->lsp_table = hash_create(label_hash, label_cmp);
+  zvrf->mpls_flags = 0;
+}
+
+/*
+ * Global MPLS initialization.
+ */
+void
+zebra_mpls_init (void)
+{
+  mpls_processq_init (&zebrad);
+}
diff --git a/zebra/zebra_mpls.h b/zebra/zebra_mpls.h
new file mode 100644
index 0000000..ccdc31f
--- /dev/null
+++ b/zebra/zebra_mpls.h
@@ -0,0 +1,348 @@
+/*
+ * Zebra MPLS Data structures and definitions
+ * Copyright (C) 2015 Cumulus Networks, Inc.
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#ifndef _ZEBRA_MPLS_H
+#define _ZEBRA_MPLS_H
+
+#include "prefix.h"
+#include "table.h"
+#include "queue.h"
+#include "hash.h"
+#include "jhash.h"
+#include "vty.h"
+#include "memory.h"
+#include "mpls.h"
+#include "zebra/zserv.h"
+
+
+/* Definitions and macros. */
+
+#define MPLS_MAX_LABELS 2  /* Maximum # labels that can be pushed. */
+
+#define NHLFE_FAMILY(nhlfe)                        \
+  (((nhlfe)->nexthop->type == NEXTHOP_TYPE_IPV6 || \
+    (nhlfe)->nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX) ? AF_INET6 : AF_INET)
+
+
+/* Typedefs */
+
+typedef struct zebra_ile_t_ zebra_ile_t;
+typedef struct zebra_snhlfe_t_ zebra_snhlfe_t;
+typedef struct zebra_slsp_t_ zebra_slsp_t;
+typedef struct zebra_nhlfe_t_ zebra_nhlfe_t;
+typedef struct zebra_lsp_t_ zebra_lsp_t;
+
+/*
+ * (Outgoing) nexthop label forwarding entry configuration
+ */
+struct zebra_snhlfe_t_
+{
+  /* Nexthop information */
+  enum nexthop_types_t gtype;
+  union g_addr gate;
+  char *ifname;
+  ifindex_t ifindex;
+
+  /* Out label. */
+  mpls_label_t out_label;
+
+  /* Backpointer to base entry. */
+  zebra_slsp_t *slsp;
+
+  /* Pointers to more outgoing information for same in-label */
+  zebra_snhlfe_t *next;
+  zebra_snhlfe_t *prev;
+};
+
+/*
+ * (Outgoing) nexthop label forwarding entry
+ */
+struct zebra_nhlfe_t_
+{
+  /* Type of entry - static etc. */
+  enum lsp_types_t type;
+
+  /* Nexthop information (with outgoing label) */
+  struct nexthop *nexthop;
+
+  /* Backpointer to base entry. */
+  zebra_lsp_t *lsp;
+
+  /* Runtime info - flags, pointers etc. */
+  u_int32_t flags;
+#define NHLFE_FLAG_CHANGED     (1 << 0)
+#define NHLFE_FLAG_SELECTED    (1 << 1)
+#define NHLFE_FLAG_MULTIPATH   (1 << 2)
+#define NHLFE_FLAG_DELETED     (1 << 3)
+#define NHLFE_FLAG_INSTALLED   (1 << 4)
+
+  zebra_nhlfe_t *next;
+  zebra_nhlfe_t *prev;
+  u_char distance;
+};
+
+/*
+ * Incoming label entry
+ */
+struct zebra_ile_t_
+{
+  mpls_label_t in_label;
+};
+
+/*
+ * Label swap entry static configuration.
+ */
+struct zebra_slsp_t_
+{
+  /* Incoming label */
+  zebra_ile_t ile;
+
+  /* List of outgoing nexthop static configuration */
+  zebra_snhlfe_t *snhlfe_list;
+
+};
+
+/*
+ * Label swap entry (ile -> list of nhlfes)
+ */
+struct zebra_lsp_t_
+{
+  /* Incoming label */
+  zebra_ile_t ile;
+
+  /* List of NHLFE, pointer to best and num equal-cost. */
+  zebra_nhlfe_t *nhlfe_list;
+  zebra_nhlfe_t *best_nhlfe;
+  u_int32_t num_ecmp;
+
+  /* Flags */
+  u_int32_t flags;
+#define LSP_FLAG_SCHEDULED        (1 << 0)
+#define LSP_FLAG_INSTALLED        (1 << 1)
+#define LSP_FLAG_CHANGED          (1 << 2)
+
+  /* Address-family of NHLFE - saved here for delete. All NHLFEs */
+  /* have to be of the same AF */
+  u_char addr_family;
+};
+
+
+/* Function declarations. */
+
+/*
+ * String to label conversion, labels separated by '/'.
+ */
+int
+mpls_str2label (const char *label_str, u_int8_t *num_labels,
+                mpls_label_t *labels);
+
+/*
+ * Label to string conversion, labels in string separated by '/'.
+ */
+char *
+mpls_label2str (u_int8_t num_labels, mpls_label_t *labels,
+                char *buf, int len);
+
+
+/*
+ * Install/update a static NHLFE for an LSP in the forwarding table. This may
+ * be a new LSP entry or a new NHLFE for an existing in-label or an update of
+ * the out-label for an existing NHLFE (update case).
+ */
+int
+mpls_lsp_install (struct zebra_vrf *zvrf, enum lsp_types_t type,
+		  mpls_label_t in_label, mpls_label_t out_label,
+		  enum nexthop_types_t gtype, union g_addr *gate,
+		  char *ifname, ifindex_t ifindex);
+
+/*
+ * Uninstall a particular static NHLFE in the forwarding table. If this is
+ * the only NHLFE, the entire LSP forwarding entry has to be deleted.
+ */
+int
+mpls_lsp_uninstall (struct zebra_vrf *zvrf, enum lsp_types_t type,
+		    mpls_label_t in_label, enum nexthop_types_t gtype,
+		    union g_addr *gate, char *ifname, ifindex_t ifindex);
+
+/*
+ * Uninstall all LDP NHLFEs for a particular LSP forwarding entry.
+ * If no other NHLFEs exist, the entry would be deleted.
+ */
+void
+mpls_ldp_lsp_uninstall_all (struct hash_backet *backet, void *ctxt);
+
+/*
+ * Check that the label values used in LSP creation are consistent. The
+ * main criteria is that if there is ECMP, the label operation must still
+ * be consistent - i.e., all paths either do a swap or do PHP. This is due
+ * to current HW restrictions.
+ */
+int
+zebra_mpls_lsp_label_consistent (struct zebra_vrf *zvrf, mpls_label_t in_label,
+                     mpls_label_t out_label, enum nexthop_types_t gtype,
+                     union g_addr *gate, char *ifname, ifindex_t ifindex);
+
+/*
+ * Add static LSP entry. This may be the first entry for this incoming label
+ * or an additional nexthop; an existing entry may also have outgoing label
+ * changed.
+ * Note: The label operation (swap or PHP) is common for the LSP entry (all
+ * NHLFEs).
+ */
+int
+zebra_mpls_static_lsp_add (struct zebra_vrf *zvrf, mpls_label_t in_label,
+                     mpls_label_t out_label, enum nexthop_types_t gtype,
+                     union g_addr *gate, char *ifname, ifindex_t ifindex);
+
+/*
+ * Delete static LSP entry. This may be the delete of one particular
+ * NHLFE for this incoming label or the delete of the entire entry (i.e.,
+ * all NHLFEs).
+ * NOTE: Delete of the only NHLFE will also end up deleting the entire
+ * LSP configuration.
+ */
+int
+zebra_mpls_static_lsp_del (struct zebra_vrf *zvrf, mpls_label_t in_label,
+                           enum nexthop_types_t gtype, union g_addr *gate,
+                           char *ifname, ifindex_t ifindex);
+
+/*
+ * Schedule all MPLS label forwarding entries for processing.
+ * Called upon changes that may affect one or more of them such as
+ * interface or nexthop state changes.
+ */
+void
+zebra_mpls_lsp_schedule (struct zebra_vrf *zvrf);
+
+/*
+ * Display MPLS label forwarding table for a specific LSP
+ * (VTY command handler).
+ */
+void
+zebra_mpls_print_lsp (struct vty *vty, struct zebra_vrf *zvrf, mpls_label_t label);
+
+/*
+ * Display MPLS label forwarding table (VTY command handler).
+ */
+void
+zebra_mpls_print_lsp_table (struct vty *vty, struct zebra_vrf *zvrf);
+
+/*
+ * Display MPLS LSP configuration of all static LSPs (VTY command handler).
+ */
+int
+zebra_mpls_write_lsp_config (struct vty *vty, struct zebra_vrf *zvrf);
+
+/*
+ * Called upon process exiting, need to delete LSP forwarding
+ * entries from the kernel.
+ * NOTE: Currently supported only for default VRF.
+ */
+void
+zebra_mpls_close_tables (struct zebra_vrf *zvrf);
+
+/*
+ * Allocate MPLS tables for this VRF.
+ * NOTE: Currently supported only for default VRF.
+ */
+void
+zebra_mpls_init_tables (struct zebra_vrf *zvrf);
+
+/*
+ * Global MPLS initialization.
+ */
+void
+zebra_mpls_init (void);
+
+/* Inline functions. */
+
+/*
+ * Distance (priority) definition for LSP NHLFE.
+ */
+static inline u_char
+lsp_distance (enum lsp_types_t type)
+{
+  if (type == ZEBRA_LSP_STATIC)
+    return (route_distance (ZEBRA_ROUTE_STATIC));
+
+  return 150;
+}
+
+/*
+ * Map RIB type to LSP type. Used when labeled-routes from BGP
+ * are converted into LSPs.
+ */
+static inline enum lsp_types_t
+lsp_type_from_rib_type (int rib_type)
+{
+  switch (rib_type)
+    {
+      case ZEBRA_ROUTE_STATIC:
+        return ZEBRA_LSP_STATIC;
+      default:
+        return ZEBRA_LSP_INVALID;
+    }
+}
+
+/* NHLFE type as printable string. */
+static inline const char *
+nhlfe_type2str(enum lsp_types_t lsp_type)
+{
+  switch (lsp_type)
+    {
+      case ZEBRA_LSP_STATIC:
+        return "Static";
+      case ZEBRA_LSP_LDP:
+        return "LDP";
+      default:
+        return "Unknown";
+    }
+}
+
+static inline void
+mpls_mark_lsps_for_processing(struct zebra_vrf *zvrf)
+{
+  if (!zvrf)
+    return;
+
+  zvrf->mpls_flags |= MPLS_FLAG_SCHEDULE_LSPS;
+}
+
+static inline void
+mpls_unmark_lsps_for_processing(struct zebra_vrf *zvrf)
+{
+  if (!zvrf)
+    return;
+
+  zvrf->mpls_flags &= ~MPLS_FLAG_SCHEDULE_LSPS;
+}
+
+static inline int
+mpls_should_lsps_be_processed(struct zebra_vrf *zvrf)
+{
+  if (!zvrf)
+    return 0;
+
+  return ((zvrf->mpls_flags & MPLS_FLAG_SCHEDULE_LSPS) ? 1 : 0);
+}
+
+#endif /*_ZEBRA_MPLS_H */
diff --git a/zebra/zebra_mpls_netlink.c b/zebra/zebra_mpls_netlink.c
new file mode 100644
index 0000000..bcdfda9
--- /dev/null
+++ b/zebra/zebra_mpls_netlink.c
@@ -0,0 +1,103 @@
+#include <zebra.h>
+#include "zebra/rt.h"
+#include "zebra/rt_netlink.h"
+#include "zebra/zebra_mpls.h"
+
+/*
+ * Handle failure in LSP install, clear flags for NHLFE.
+ */
+static inline void
+clear_nhlfe_installed (zebra_lsp_t *lsp)
+{
+  zebra_nhlfe_t *nhlfe;
+  struct nexthop *nexthop;
+
+  for (nhlfe = lsp->nhlfe_list; nhlfe; nhlfe = nhlfe->next)
+    {
+      nexthop = nhlfe->nexthop;
+      if (!nexthop)
+        continue;
+
+      UNSET_FLAG (nhlfe->flags, NHLFE_FLAG_INSTALLED);
+      UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
+    }
+}
+
+/*
+ * Install Label Forwarding entry into the kernel.
+ */
+int
+kernel_add_lsp (zebra_lsp_t *lsp)
+{
+  int ret;
+
+  if (!lsp || !lsp->best_nhlfe) // unexpected
+    return -1;
+
+  UNSET_FLAG (lsp->flags, LSP_FLAG_CHANGED);
+  ret = netlink_mpls_multipath (RTM_NEWROUTE, lsp);
+zlog_debug ("kernel_add_lsp:  netlink_mpls_multipath=%d",ret);
+
+
+  if (!ret)
+    SET_FLAG (lsp->flags, LSP_FLAG_INSTALLED);
+  else
+    clear_nhlfe_installed (lsp);
+
+  return ret;
+}
+
+/*
+ * Update Label Forwarding entry in the kernel. This means that the Label
+ * forwarding entry is already installed and needs an update - either a new
+ * path is to be added, an installed path has changed (e.g., outgoing label)
+ * or an installed path (but not all paths) has to be removed.
+ * TODO: Performs a DEL followed by ADD now, need to change to REPLACE. Note
+ * that REPLACE was originally implemented for IPv4 nexthops but removed as
+ * it was not functioning when moving from swap to PHP as that was signaled
+ * through the metric field (before kernel-MPLS). This shouldn't be an issue
+ * any longer, so REPLACE can be reintroduced.
+ */
+int
+kernel_upd_lsp (zebra_lsp_t *lsp)
+{
+  int ret, ret2;
+
+  if (!lsp || !lsp->best_nhlfe) // unexpected
+    return -1;
+
+  UNSET_FLAG (lsp->flags, LSP_FLAG_CHANGED);
+
+  /* First issue a DEL and clear the installed flag. */
+  ret2=netlink_mpls_multipath (RTM_DELROUTE, lsp);
+	zlog_debug ("kernel_upd_lsp (del):  netlink_mpls_multipath=%d",ret2);
+  UNSET_FLAG (lsp->flags, LSP_FLAG_INSTALLED);
+
+  /* Then issue an ADD. */
+  ret = netlink_mpls_multipath (RTM_NEWROUTE, lsp);
+zlog_debug ("kernel_upd_lsp (add):  netlink_mpls_multipath=%d",ret);
+  if (!ret)
+    SET_FLAG (lsp->flags, LSP_FLAG_INSTALLED);
+  else
+    clear_nhlfe_installed (lsp);
+
+  return ret;
+}
+
+/*
+ * Delete Label Forwarding entry from the kernel.
+ */
+int
+kernel_del_lsp (zebra_lsp_t *lsp)
+{
+  if (!lsp) // unexpected
+    return -1;
+
+  if (CHECK_FLAG (lsp->flags, LSP_FLAG_INSTALLED))
+    {
+      netlink_mpls_multipath (RTM_DELROUTE, lsp);
+      UNSET_FLAG (lsp->flags, LSP_FLAG_INSTALLED);
+    }
+
+  return 0;
+}
diff --git a/zebra/zebra_mpls_null.c b/zebra/zebra_mpls_null.c
new file mode 100644
index 0000000..9022fe3
--- /dev/null
+++ b/zebra/zebra_mpls_null.c
@@ -0,0 +1,7 @@
+#include <zebra.h>
+#include "zebra/rt.h"
+#include "zebra/zebra_mpls.h"
+
+int kernel_add_lsp (zebra_lsp_t *lsp) { return 0; }
+int kernel_upd_lsp (zebra_lsp_t *lsp) { return 0; }
+int kernel_del_lsp (zebra_lsp_t *lsp) { return 0; }
diff --git a/zebra/zebra_rib.c b/zebra/zebra_rib.c
index 1650dab..e2c8264 100644
--- a/zebra/zebra_rib.c
+++ b/zebra/zebra_rib.c
@@ -35,6 +35,7 @@
 #include "prefix.h"
 #include "routemap.h"
 #include "vrf.h"
+#include "mpls.h"
 
 #include "zebra/rib.h"
 #include "zebra/rt.h"
@@ -42,6 +43,7 @@
 #include "zebra/redistribute.h"
 #include "zebra/debug.h"
 #include "zebra/zebra_fpm.h"
+#include "zebra/zebra_mpls.h"
 
 /* Default rtm_table for all clients */
 extern struct zebra_t zebrad;
@@ -68,11 +70,25 @@ static const struct
   [ZEBRA_ROUTE_OSPF]    = {ZEBRA_ROUTE_OSPF,    110},
   [ZEBRA_ROUTE_OSPF6]   = {ZEBRA_ROUTE_OSPF6,   110},
   [ZEBRA_ROUTE_ISIS]    = {ZEBRA_ROUTE_ISIS,    115},
+  [ZEBRA_ROUTE_LDP]     = {ZEBRA_ROUTE_LDP,       5},
   [ZEBRA_ROUTE_BGP]     = {ZEBRA_ROUTE_BGP,      20  /* IBGP is 200. */},
   [ZEBRA_ROUTE_BABEL]   = {ZEBRA_ROUTE_BABEL,    95},
   /* no entry/default: 150 */
 };
 
+u_char
+route_distance (int type)
+{
+  u_char distance;
+
+  if ((unsigned)type >= array_size(route_info))
+    distance = 150;
+  else
+    distance = route_info[type].distance;
+
+  return distance;
+}
+
 /* RPF lookup behaviour */
 static enum multicast_mode ipv4_multicast_mode = MCAST_NO_CONFIG;
 
@@ -174,9 +190,10 @@ nexthop_delete (struct rib *rib, struct nexthop *nexthop)
 static void nexthops_free(struct nexthop *nexthop);
 
 /* Free nexthop. */
-static void
+void
 nexthop_free (struct nexthop *nexthop)
 {
+  nexthop_del_labels (nexthop);
   if (nexthop->ifname)
     XFREE (0, nexthop->ifname);
   if (nexthop->resolved)
@@ -319,6 +336,29 @@ nexthop_blackhole_add (struct rib *rib)
   return nexthop;
 }
 
+/* Update nexthop with label information. */
+void
+nexthop_add_labels (struct nexthop *nexthop, u_int8_t num_labels,
+                    mpls_label_t *label)
+{
+  struct nexthop_label *nh_label;
+  int i;
+
+  nh_label = XCALLOC (MTYPE_NH_LABEL, sizeof (struct nexthop_label));
+  nh_label->num_labels = num_labels;
+  for (i = 0; i < num_labels; i++)
+    nh_label->label[i] = *(label + i);
+  nexthop->nh_label = nh_label;
+}
+
+/* Free label information of nexthop, if present. */
+void
+nexthop_del_labels (struct nexthop *nexthop)
+{
+  if (nexthop->nh_label)
+    XFREE (MTYPE_NH_LABEL, nexthop->nh_label);
+}
+
 /* This method checks whether a recursive nexthop has at
  * least one resolved nexthop in the fib.
  */
@@ -2222,6 +2262,7 @@ static_install_route (afi_t afi, safi_t safi, struct prefix *p, struct static_ro
   struct rib *rib;
   struct route_node *rn;
   struct route_table *table;
+  struct nexthop *nexthop = NULL;
 
   /* Lookup table.  */
   table = zebra_vrf_table (afi, safi, si->vrf_id);
@@ -2247,24 +2288,29 @@ static_install_route (afi_t afi, safi_t safi, struct prefix *p, struct static_ro
       switch (si->type)
         {
 	case STATIC_IPV4_GATEWAY:
-	  nexthop_ipv4_add (rib, &si->addr.ipv4, NULL);
+	  nexthop = nexthop_ipv4_add (rib, &si->addr.ipv4, NULL);
 	  break;
 	case STATIC_IPV4_IFNAME:
-	  nexthop_ifname_add (rib, si->ifname);
+	  nexthop = nexthop_ifname_add (rib, si->ifname);
 	  break;
 	case STATIC_IPV4_BLACKHOLE:
-	  nexthop_blackhole_add (rib);
+	  nexthop = nexthop_blackhole_add (rib);
 	  break;
 	case STATIC_IPV6_GATEWAY:
-	  nexthop_ipv6_add (rib, &si->addr.ipv6);
+	  nexthop = nexthop_ipv6_add (rib, &si->addr.ipv6);
 	  break;
 	case STATIC_IPV6_IFNAME:
-	  nexthop_ifname_add (rib, si->ifname);
+	  nexthop = nexthop_ifname_add (rib, si->ifname);
 	  break;
 	case STATIC_IPV6_GATEWAY_IFNAME:
-	  nexthop_ipv6_ifname_add (rib, &si->addr.ipv6, si->ifname);
+	  nexthop = nexthop_ipv6_ifname_add (rib, &si->addr.ipv6, si->ifname);
 	  break;
         }
+      /* Update label(s), if present. */
+      if (si->snh_label.num_labels)
+        nexthop_add_labels (nexthop, si->snh_label.num_labels,
+                            &si->snh_label.label[0]);
+
       rib_queue_add (&zebrad, rn);
     }
   else
@@ -2282,24 +2328,28 @@ static_install_route (afi_t afi, safi_t safi, struct prefix *p, struct static_ro
       switch (si->type)
         {
 	case STATIC_IPV4_GATEWAY:
-	  nexthop_ipv4_add (rib, &si->addr.ipv4, NULL);
+	  nexthop = nexthop_ipv4_add (rib, &si->addr.ipv4, NULL);
 	  break;
 	case STATIC_IPV4_IFNAME:
-	  nexthop_ifname_add (rib, si->ifname);
+	  nexthop = nexthop_ifname_add (rib, si->ifname);
 	  break;
 	case STATIC_IPV4_BLACKHOLE:
-	  nexthop_blackhole_add (rib);
+	  nexthop = nexthop_blackhole_add (rib);
 	  break;
 	case STATIC_IPV6_GATEWAY:
-	  nexthop_ipv6_add (rib, &si->addr.ipv6);
+	  nexthop = nexthop_ipv6_add (rib, &si->addr.ipv6);
 	  break;
 	case STATIC_IPV6_IFNAME:
-	  nexthop_ifname_add (rib, si->ifname);
+	  nexthop = nexthop_ifname_add (rib, si->ifname);
 	  break;
 	case STATIC_IPV6_GATEWAY_IFNAME:
-	  nexthop_ipv6_ifname_add (rib, &si->addr.ipv6, si->ifname);
+	  nexthop = nexthop_ipv6_ifname_add (rib, &si->addr.ipv6, si->ifname);
 	  break;
         }
+      /* Update label(s), if present. */
+      if (si->snh_label.num_labels)
+        nexthop_add_labels (nexthop, si->snh_label.num_labels,
+                            &si->snh_label.label[0]);
 
       /* Save the flags of this static routes (reject, blackhole) */
       rib->flags = si->flags;
@@ -2310,33 +2360,65 @@ static_install_route (afi_t afi, safi_t safi, struct prefix *p, struct static_ro
 }
 
 static int
+static_nexthop_label_same (struct nexthop *nexthop,
+                           struct static_nh_label *snh_label)
+{
+  int i;
+
+  if ((snh_label->num_labels == 0 && nexthop->nh_label) ||
+      (snh_label->num_labels != 0 && !nexthop->nh_label))
+    return 0;
+
+  if (snh_label->num_labels != 0)
+    if (snh_label->num_labels != nexthop->nh_label->num_labels)
+    return 0;
+
+  for (i = 0; i < snh_label->num_labels; i++)
+    if (snh_label->label[i] != nexthop->nh_label->label[i])
+      return 0;
+
+  return 1;
+}
+
+static int
 static_nexthop_same (struct nexthop *nexthop, struct static_route *si)
 {
+  int gw_match = 0;
+
+  if (nexthop->type == NEXTHOP_TYPE_BLACKHOLE
+      && si->type == STATIC_IPV4_BLACKHOLE)
+    return 1;
+
   if (nexthop->type == NEXTHOP_TYPE_IPV4
       && si->type == STATIC_IPV4_GATEWAY
       && IPV4_ADDR_SAME (&nexthop->gate.ipv4, &si->addr.ipv4))
-    return 1;
-  if (nexthop->type == NEXTHOP_TYPE_IFNAME
+    gw_match = 1;
+  else if (nexthop->type == NEXTHOP_TYPE_IFNAME
       && si->type == STATIC_IPV4_IFNAME
       && strcmp (nexthop->ifname, si->ifname) == 0)
-    return 1;
-  if (nexthop->type == NEXTHOP_TYPE_BLACKHOLE
+    gw_match = 1;
+  else if (nexthop->type == NEXTHOP_TYPE_BLACKHOLE
       && si->type == STATIC_IPV4_BLACKHOLE)
-    return 1;
-  if (nexthop->type == NEXTHOP_TYPE_IPV6
+    gw_match = 1;
+  else if (nexthop->type == NEXTHOP_TYPE_IPV6
       && si->type == STATIC_IPV6_GATEWAY
       && IPV6_ADDR_SAME (&nexthop->gate.ipv6, &si->addr.ipv6))
-    return 1;
-  if (nexthop->type == NEXTHOP_TYPE_IFNAME
+    gw_match = 1;
+  else if (nexthop->type == NEXTHOP_TYPE_IFNAME
       && si->type == STATIC_IPV6_IFNAME
       && strcmp (nexthop->ifname, si->ifname) == 0)
-    return 1;
-  if (nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
+    gw_match = 1;
+  else if (nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
       && si->type == STATIC_IPV6_GATEWAY_IFNAME
       && IPV6_ADDR_SAME (&nexthop->gate.ipv6, &si->addr.ipv6)
       && strcmp (nexthop->ifname, si->ifname) == 0)
-    return 1;
-  return 0;
+    gw_match = 1;
+
+  if (!gw_match)
+    return 0;
+
+  /* Check match on label(s), if any */
+  return static_nexthop_label_same (nexthop, &si->snh_label);
 }
 
 /* Uninstall static route from RIB. */
@@ -2403,7 +2485,7 @@ static_uninstall_route (afi_t afi, safi_t safi, struct prefix *p, struct static_
 int
 static_add_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
 		      const char *ifname, u_char flags, u_char distance,
-		      vrf_id_t vrf_id)
+		      vrf_id_t vrf_id, struct static_nh_label *snh_label)
 {
   u_char type = 0;
   struct route_node *rn;
@@ -2435,7 +2517,8 @@ static_add_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
 	  && (! gate || IPV4_ADDR_SAME (gate, &si->addr.ipv4))
 	  && (! ifname || strcmp (ifname, si->ifname) == 0))
 	{
-	  if (distance == si->distance)
+	  if (distance == si->distance
+              && !memcmp (&si->snh_label, snh_label, sizeof (struct static_nh_label)))
 	    {
 	      route_unlock_node (rn);
 	      return 0;
@@ -2445,9 +2528,10 @@ static_add_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
 	}
     }
 
-  /* Distance changed.  */
+  /* Distance or label changed, delete existing first.  */
   if (update)
-    static_delete_ipv4_safi (safi, p, gate, ifname, update->distance, vrf_id);
+    static_delete_ipv4_safi (safi, p, gate, ifname, update->distance, vrf_id,
+			     &update->snh_label);
 
   /* Make new static route structure. */
   si = XCALLOC (MTYPE_STATIC_ROUTE, sizeof (struct static_route));
@@ -2462,6 +2546,9 @@ static_add_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
   if (ifname)
     si->ifname = XSTRDUP (0, ifname);
 
+  /* Save labels, if any. */
+  memcpy (&si->snh_label, snh_label, sizeof (struct static_nh_label));
+
   /* Add new static route information to the tree with sort by
      distance value and gateway address. */
   for (pp = NULL, cp = rn->info; cp; pp = cp, cp = cp->next)
@@ -2497,7 +2584,8 @@ static_add_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
 
 int
 static_delete_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
-			 const char *ifname, u_char distance, vrf_id_t vrf_id)
+			 const char *ifname, u_char distance, vrf_id_t vrf_id,
+			 struct static_nh_label *snh_label)
 {
   u_char type = 0;
   struct route_node *rn;
@@ -2526,7 +2614,9 @@ static_delete_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
   for (si = rn->info; si; si = si->next)
     if (type == si->type
 	&& (! gate || IPV4_ADDR_SAME (gate, &si->addr.ipv4))
-	&& (! ifname || strcmp (ifname, si->ifname) == 0))
+	&& (! ifname || strcmp (ifname, si->ifname) == 0)
+        && (! snh_label->num_labels ||
+            !memcmp (&si->snh_label, snh_label, sizeof (struct static_nh_label))))
       break;
 
   /* Can't find static route. */
@@ -2560,7 +2650,7 @@ static_delete_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,
 
 int
 rib_add_ipv6 (int type, int flags, struct prefix_ipv6 *p,
-	      struct in6_addr *gate, ifindex_t ifindex,
+	      struct in6_addr *gate, ifindex_t ifindex, mpls_label_t label,
 	      vrf_id_t vrf_id, int table_id,
 	      u_int32_t metric, u_int32_t mtu, u_char distance, safi_t safi)
 {
@@ -2630,7 +2720,11 @@ rib_add_ipv6 (int type, int flags, struct prefix_ipv6 *p,
       if (ifindex)
 	nexthop_ipv6_ifindex_add (rib, gate, ifindex);
       else
-	nexthop_ipv6_add (rib, gate);
+	{
+	  nexthop = nexthop_ipv6_add (rib, gate);
+	  if (label != MPLS_NO_LABEL)
+	    nexthop_add_labels (nexthop, 1, &label);
+	}
     }
   else
     nexthop_ifindex_add (rib, ifindex);
@@ -2799,7 +2893,7 @@ rib_delete_ipv6 (int type, int flags, struct prefix_ipv6 *p,
 int
 static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
 		 const char *ifname, u_char flags, u_char distance,
-		 vrf_id_t vrf_id)
+		 vrf_id_t vrf_id, struct static_nh_label *snh_label)
 {
   struct route_node *rn;
   struct static_route *si;
@@ -2830,7 +2924,8 @@ static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
 	  && (! gate || IPV6_ADDR_SAME (gate, &si->addr.ipv6))
 	  && (! ifname || strcmp (ifname, si->ifname) == 0))
 	{
-	  if (distance == si->distance)
+	  if (distance == si->distance
+              && !memcmp (&si->snh_label, snh_label, sizeof (struct static_nh_label)))
 	    {
 	      route_unlock_node (rn);
 	      return 0;
@@ -2841,7 +2936,8 @@ static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
     }
 
   if (update)
-    static_delete_ipv6(p, type, gate, ifname, si->distance, vrf_id);
+    static_delete_ipv6(p, type, gate, ifname, si->distance, vrf_id,
+		       &update->snh_label);
 
   /* Make new static route structure. */
   si = XCALLOC (MTYPE_STATIC_ROUTE, sizeof (struct static_route));
@@ -2851,6 +2947,9 @@ static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
   si->flags = flags;
   si->vrf_id = vrf_id;
 
+  /* Save labels, if any. */
+  memcpy (&si->snh_label, snh_label, sizeof (struct static_nh_label));
+
   switch (type)
     {
     case STATIC_IPV6_GATEWAY:
@@ -2894,7 +2993,8 @@ static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
 /* Delete static route from static route configuration. */
 int
 static_delete_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
-		    const char *ifname, u_char distance, vrf_id_t vrf_id)
+		    const char *ifname, u_char distance, vrf_id_t vrf_id,
+		    struct static_nh_label *snh_label)
 {
   struct route_node *rn;
   struct static_route *si;
@@ -2915,7 +3015,10 @@ static_delete_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
     if (distance == si->distance 
 	&& type == si->type
 	&& (! gate || IPV6_ADDR_SAME (gate, &si->addr.ipv6))
-	&& (! ifname || strcmp (ifname, si->ifname) == 0))
+	&& (! ifname || strcmp (ifname, si->ifname) == 0)
+        && (! snh_label->num_labels ||
+            !memcmp (&si->snh_label, snh_label,
+                     sizeof (struct static_nh_label))))
       break;
 
   /* Can't find static route. */
@@ -3121,6 +3224,9 @@ rib_close (void)
         rib_close_table (zvrf->table[AFI_IP][SAFI_UNICAST]);
         rib_close_table (zvrf->table[AFI_IP6][SAFI_UNICAST]);
       }
+
+  zvrf = vrf_info_lookup (VRF_DEFAULT);
+  zebra_mpls_close_tables(zvrf);
 }
 
 /* Routing information base initialize. */
@@ -3293,6 +3399,8 @@ zebra_vrf_alloc (vrf_id_t vrf_id)
   zvrf->netlink_cmd.name = XSTRDUP (MTYPE_NETLINK_NAME, nl_name);
 #endif
 
+  zebra_mpls_init_tables (zvrf);
+
   return zvrf;
 }
 
diff --git a/zebra/zebra_vty.c b/zebra/zebra_vty.c
index 21b92ea..756f969 100644
--- a/zebra/zebra_vty.c
+++ b/zebra/zebra_vty.c
@@ -28,8 +28,10 @@
 #include "table.h"
 #include "rib.h"
 #include "vrf.h"
+#include "mpls.h"
 
 #include "zebra/zserv.h"
+#include "zebra/zebra_mpls.h"
 
 static int do_show_ip_route(struct vty *vty, safi_t safi, vrf_id_t vrf_id);
 static void vty_show_ip_route_detail (struct vty *vty, struct route_node *rn,
@@ -42,7 +44,8 @@ static int
 zebra_static_ipv4_safi (struct vty *vty, safi_t safi, int add_cmd,
 			const char *dest_str, const char *mask_str,
 			const char *gate_str, const char *flag_str,
-			const char *distance_str, const char *vrf_id_str)
+			const char *distance_str, const char *vrf_id_str,
+			const char *label_str)
 {
   int ret;
   u_char distance;
@@ -52,7 +55,9 @@ zebra_static_ipv4_safi (struct vty *vty, safi_t safi, int add_cmd,
   const char *ifname;
   u_char flag = 0;
   vrf_id_t vrf_id = VRF_DEFAULT;
+  struct static_nh_label snh_label;
   
+  memset (&snh_label, 0, sizeof (struct static_nh_label));
   ret = str2prefix (dest_str, &p);
   if (ret <= 0)
     {
@@ -85,6 +90,17 @@ zebra_static_ipv4_safi (struct vty *vty, safi_t safi, int add_cmd,
   if (vrf_id_str)
     VTY_GET_INTEGER ("VRF ID", vrf_id, vrf_id_str);
 
+  /* Labels */
+  if (label_str)
+    {
+      if (mpls_str2label (label_str, &snh_label.num_labels,
+                          snh_label.label))
+        {
+          vty_out (vty, "%% Malformed label(s)%s", VTY_NEWLINE);
+          return CMD_WARNING;
+        }
+    }
+
   /* Null0 static route.  */
   if ((gate_str != NULL) && (strncasecmp (gate_str, "Null0", strlen (gate_str)) == 0))
     {
@@ -94,9 +110,11 @@ zebra_static_ipv4_safi (struct vty *vty, safi_t safi, int add_cmd,
           return CMD_WARNING;
         }
       if (add_cmd)
-        static_add_ipv4_safi (safi, &p, NULL, NULL, ZEBRA_FLAG_BLACKHOLE, distance, vrf_id);
+        static_add_ipv4_safi (safi, &p, NULL, NULL, ZEBRA_FLAG_BLACKHOLE, distance, vrf_id,
+			      &snh_label);
       else
-        static_delete_ipv4_safi (safi, &p, NULL, NULL, distance, vrf_id);
+        static_delete_ipv4_safi (safi, &p, NULL, NULL, distance, vrf_id,
+				 &snh_label);
       return CMD_SUCCESS;
     }
 
@@ -120,9 +138,11 @@ zebra_static_ipv4_safi (struct vty *vty, safi_t safi, int add_cmd,
   if (gate_str == NULL)
   {
     if (add_cmd)
-      static_add_ipv4_safi (safi, &p, NULL, NULL, flag, distance, vrf_id);
+      static_add_ipv4_safi (safi, &p, NULL, NULL, flag, distance, vrf_id,
+			    &snh_label);
     else
-      static_delete_ipv4_safi (safi, &p, NULL, NULL, distance, vrf_id);
+      static_delete_ipv4_safi (safi, &p, NULL, NULL, distance, vrf_id,
+			       &snh_label);
 
     return CMD_SUCCESS;
   }
@@ -136,9 +156,11 @@ zebra_static_ipv4_safi (struct vty *vty, safi_t safi, int add_cmd,
     ifname = gate_str;
 
   if (add_cmd)
-    static_add_ipv4_safi (safi, &p, ifname ? NULL : &gate, ifname, flag, distance, vrf_id);
+    static_add_ipv4_safi (safi, &p, ifname ? NULL : &gate, ifname, flag, distance, vrf_id,
+			  &snh_label);
   else
-    static_delete_ipv4_safi (safi, &p, ifname ? NULL : &gate, ifname, distance, vrf_id);
+    static_delete_ipv4_safi (safi, &p, ifname ? NULL : &gate, ifname, distance, vrf_id,
+			     &snh_label);
 
   return CMD_SUCCESS;
 }
@@ -147,10 +169,11 @@ static int
 zebra_static_ipv4 (struct vty *vty, int add_cmd, const char *dest_str,
 		   const char *mask_str, const char *gate_str,
 		   const char *flag_str, const char *distance_str,
-		   const char *vrf_id_str)
+		   const char *vrf_id_str, const char *label_str)
 {
   return zebra_static_ipv4_safi (vty, SAFI_UNICAST, add_cmd, dest_str, mask_str,
-                                 gate_str, flag_str, distance_str, vrf_id_str);
+                                 gate_str, flag_str, distance_str, vrf_id_str,
+                                 label_str);
 }
 
 /* Static unicast routes for multicast RPF lookup. */
@@ -166,7 +189,7 @@ DEFUN (ip_mroute_dist,
 {
   VTY_WARN_EXPERIMENTAL();
   return zebra_static_ipv4_safi(vty, SAFI_MULTICAST, 1, argv[0], NULL, argv[1],
-                                NULL, argc > 2 ? argv[2] : NULL, NULL);
+                                NULL, argc > 2 ? argv[2] : NULL, NULL, NULL);
 }
 
 ALIAS (ip_mroute_dist,
@@ -192,7 +215,7 @@ DEFUN (ip_mroute_dist_vrf,
   VTY_WARN_EXPERIMENTAL();
   return zebra_static_ipv4_safi(vty, SAFI_MULTICAST, 1, argv[0], NULL, argv[1],
                                 NULL, argc > 3 ? argv[2] : NULL,
-                                argc > 3 ? argv[3] : argv[2]);
+                                argc > 3 ? argv[3] : argv[2], NULL);
 }
 
 ALIAS (ip_mroute_dist_vrf,
@@ -217,7 +240,7 @@ DEFUN (no_ip_mroute_dist,
 {
   VTY_WARN_EXPERIMENTAL();
   return zebra_static_ipv4_safi(vty, SAFI_MULTICAST, 0, argv[0], NULL, argv[1],
-                                NULL, argc > 2 ? argv[2] : NULL, NULL);
+                                NULL, argc > 2 ? argv[2] : NULL, NULL, NULL);
 }
 
 ALIAS (no_ip_mroute_dist,
@@ -244,7 +267,7 @@ DEFUN (no_ip_mroute_dist_vrf,
   VTY_WARN_EXPERIMENTAL();
   return zebra_static_ipv4_safi(vty, SAFI_MULTICAST, 0, argv[0], NULL, argv[1],
                                 NULL, argc > 3 ? argv[2] : NULL,
-                                argc > 3 ? argv[3] : argv[2]);
+                                argc > 3 ? argv[3] : argv[2], NULL);
 }
 
 ALIAS (no_ip_mroute_dist_vrf,
@@ -459,31 +482,35 @@ DEFUN (show_ip_rpf_addr_vrf_all,
 /* Static route configuration.  */
 DEFUN (ip_route, 
        ip_route_cmd,
-       "ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0)",
+       "ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0) {label WORD}",
        IP_STR
        "Establish static routes\n"
        "IP destination prefix (e.g. 10.0.0.0/8)\n"
        "IP gateway address\n"
        "IP gateway interface name\n"
-       "Null interface\n")
+       "Null interface\n"
+       "Specify label(s) for this route\n"
+       "One or more labels separated by '/'\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], NULL, NULL,
-                            NULL);
+                            NULL, argv[2]);
 }
 
 DEFUN (ip_route_flags,
        ip_route_flags_cmd,
-       "ip route A.B.C.D/M (A.B.C.D|INTERFACE) (reject|blackhole)",
+       "ip route A.B.C.D/M (A.B.C.D|INTERFACE) (reject|blackhole) {label WORD}",
        IP_STR
        "Establish static routes\n"
        "IP destination prefix (e.g. 10.0.0.0/8)\n"
        "IP gateway address\n"
        "IP gateway interface name\n"
        "Emit an ICMP unreachable when matched\n"
-       "Silently discard pkts when matched\n")
+       "Silently discard pkts when matched\n"
+       "Specify label(s) for this route\n"
+       "One or more labels separated by '/'\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], argv[2], NULL,
-                            NULL);
+                            NULL, argv[3]);
 }
 
 DEFUN (ip_route_flags2,
@@ -496,23 +523,25 @@ DEFUN (ip_route_flags2,
        "Silently discard pkts when matched\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, NULL, argv[1], NULL,
-                            NULL);
+                            NULL, NULL);
 }
 
 /* Mask as A.B.C.D format.  */
 DEFUN (ip_route_mask,
        ip_route_mask_cmd,
-       "ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0)",
+       "ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0) {label WORD}",
        IP_STR
        "Establish static routes\n"
        "IP destination prefix\n"
        "IP destination prefix mask\n"
        "IP gateway address\n"
        "IP gateway interface name\n"
-       "Null interface\n")
+       "Null interface\n"
+       "Specify label(s) for this route\n"
+       "One or more labels separated by '/'\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], NULL, NULL,
-                            NULL);
+                            NULL, argv[3]);
 }
 
 DEFUN (ip_route_mask_flags,
@@ -528,7 +557,7 @@ DEFUN (ip_route_mask_flags,
        "Silently discard pkts when matched\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], argv[3], NULL,
-                            NULL);
+                            NULL, NULL);
 }
 
 DEFUN (ip_route_mask_flags2,
@@ -542,28 +571,30 @@ DEFUN (ip_route_mask_flags2,
        "Silently discard pkts when matched\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], NULL, argv[2], NULL,
-                            NULL);
+                            NULL, NULL);
 }
 
 /* Distance option value.  */
 DEFUN (ip_route_distance,
        ip_route_distance_cmd,
-       "ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0) <1-255>",
+       "ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0) <1-255> {label WORD}",
        IP_STR
        "Establish static routes\n"
        "IP destination prefix (e.g. 10.0.0.0/8)\n"
        "IP gateway address\n"
        "IP gateway interface name\n"
        "Null interface\n"
-       "Distance value for this route\n")
+       "Distance value for this route\n"
+       "Specify label(s) for this route\n"
+       "One or more labels separated by '/'\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], NULL, argv[2],
-                            NULL);
+                            NULL, argv[3]);
 }
 
 DEFUN (ip_route_flags_distance,
        ip_route_flags_distance_cmd,
-       "ip route A.B.C.D/M (A.B.C.D|INTERFACE) (reject|blackhole) <1-255>",
+       "ip route A.B.C.D/M (A.B.C.D|INTERFACE) (reject|blackhole) <1-255> {label WORD}",
        IP_STR
        "Establish static routes\n"
        "IP destination prefix (e.g. 10.0.0.0/8)\n"
@@ -571,10 +602,12 @@ DEFUN (ip_route_flags_distance,
        "IP gateway interface name\n"
        "Emit an ICMP unreachable when matched\n"
        "Silently discard pkts when matched\n"
-       "Distance value for this route\n")
+       "Distance value for this route\n"
+       "Specify label(s) for this route\n"
+       "One or more labels separated by '/'\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], argv[2], argv[3],
-                            NULL);
+                            NULL, argv[4]);
 }
 
 DEFUN (ip_route_flags_distance2,
@@ -588,12 +621,12 @@ DEFUN (ip_route_flags_distance2,
        "Distance value for this route\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, NULL, argv[1], argv[2],
-                            NULL);
+                            NULL, NULL);
 }
 
 DEFUN (ip_route_mask_distance,
        ip_route_mask_distance_cmd,
-       "ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0) <1-255>",
+       "ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0) <1-255> {label WORD}",
        IP_STR
        "Establish static routes\n"
        "IP destination prefix\n"
@@ -601,10 +634,12 @@ DEFUN (ip_route_mask_distance,
        "IP gateway address\n"
        "IP gateway interface name\n"
        "Null interface\n"
-       "Distance value for this route\n")
+       "Distance value for this route\n"
+       "Specify label(s) for this route\n"
+       "One or more labels separated by '/'\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], NULL, argv[3],
-                            NULL);
+                            NULL, argv[4]);
 }
 
 DEFUN (ip_route_mask_flags_distance,
@@ -621,7 +656,7 @@ DEFUN (ip_route_mask_flags_distance,
        "Distance value for this route\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], argv[3], argv[4],
-                            NULL);
+                            NULL, NULL);
 }
 
 DEFUN (ip_route_mask_flags_distance2,
@@ -636,22 +671,24 @@ DEFUN (ip_route_mask_flags_distance2,
        "Distance value for this route\n")
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], NULL, argv[2], argv[3],
-                            NULL);
+                            NULL, NULL);
 }
 
 DEFUN (no_ip_route, 
        no_ip_route_cmd,
-       "no ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0)",
+       "no ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0) {label WORD}",
        NO_STR
        IP_STR
        "Establish static routes\n"
        "IP destination prefix (e.g. 10.0.0.0/8)\n"
        "IP gateway address\n"
        "IP gateway interface name\n"
-       "Null interface\n")
+       "Null interface\n"
+       "Specify label(s) for this route\n"
+       "One or more labels separated by '/'\n")
 {
   return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], NULL, NULL,
-                            NULL);
+                            NULL, argv[2]);
 }
 
 ALIAS (no_ip_route,
@@ -677,12 +714,12 @@ DEFUN (no_ip_route_flags2,
        "Silently discard pkts when matched\n")
 {
   return zebra_static_ipv4 (vty, 0, argv[0], NULL, NULL, NULL, NULL,
-                            NULL);
+                            NULL, NULL);
 }
 
 DEFUN (no_ip_route_mask,
        no_ip_route_mask_cmd,
-       "no ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0)",
+       "no ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0) {label WORD}",
        NO_STR
        IP_STR
        "Establish static routes\n"
@@ -690,10 +727,12 @@ DEFUN (no_ip_route_mask,
        "IP destination prefix mask\n"
        "IP gateway address\n"
        "IP gateway interface name\n"
-       "Null interface\n")
+       "Null interface\n"
+       "Specify label(s) for this route\n"
+       "One or more labels separated by '/'\n")
 {
   return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], NULL, NULL,
-                            NULL);
+                            NULL, argv[3]);
 }
 
 ALIAS (no_ip_route_mask,
@@ -721,12 +760,12 @@ DEFUN (no_ip_route_mask_flags2,
        "Silently discard pkts when matched\n")
 {
   return zebra_static_ipv4 (vty, 0, argv[0], argv[1], NULL, NULL, NULL,
-                            NULL);
+                            NULL, NULL);
 }
 
 DEFUN (no_ip_route_distance,
        no_ip_route_distance_cmd,
-       "no ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0) <1-255>",
+       "no ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0) <1-255> {label WORD}",
        NO_STR
        IP_STR
        "Establish static routes\n"
@@ -734,10 +773,12 @@ DEFUN (no_ip_route_distance,
        "IP gateway address\n"
        "IP gateway interface name\n"
        "Null interface\n"
-       "Distance value for this route\n")
+       "Distance value for this route\n"
+       "Specify label(s) for this route\n"
+       "One or more labels separated by '/'\n")
 {
   return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], NULL, argv[2],
-                            NULL);
+                            NULL, argv[3]);
 }
 
 DEFUN (no_ip_route_flags_distance,
@@ -754,7 +795,7 @@ DEFUN (no_ip_route_flags_distance,
        "Distance value for this route\n")
 {
   return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], argv[2], argv[3],
-                            NULL);
+                            NULL, NULL);
 }
 
 DEFUN (no_ip_route_flags_distance2,
@@ -769,12 +810,12 @@ DEFUN (no_ip_route_flags_distance2,
        "Distance value for this route\n")
 {
   return zebra_static_ipv4 (vty, 0, argv[0], NULL, NULL, argv[1], argv[2],
-                            NULL);
+                            NULL, NULL);
 }
 
 DEFUN (no_ip_route_mask_distance,
        no_ip_route_mask_distance_cmd,
-       "no ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0) <1-255>",
+       "no ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0) <1-255> {label WORD}",
        NO_STR
        IP_STR
        "Establish static routes\n"
@@ -783,10 +824,12 @@ DEFUN (no_ip_route_mask_distance,
        "IP gateway address\n"
        "IP gateway interface name\n"
        "Null interface\n"
-       "Distance value for this route\n")
+       "Distance value for this route\n"
+       "Specify label(s) for this route\n"
+       "One or more labels separated by '/'\n")
 {
   return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], NULL, argv[3],
-                            NULL);
+                            NULL, argv[4]);
 }
 
 DEFUN (no_ip_route_mask_flags_distance,
@@ -804,7 +847,7 @@ DEFUN (no_ip_route_mask_flags_distance,
        "Distance value for this route\n")
 {
   return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], argv[3], argv[4],
-                            NULL);
+                            NULL, NULL);
 }
 
 DEFUN (no_ip_route_mask_flags_distance2,
@@ -820,7 +863,7 @@ DEFUN (no_ip_route_mask_flags_distance2,
        "Distance value for this route\n")
 {
   return zebra_static_ipv4 (vty, 0, argv[0], argv[1], NULL, argv[2], argv[3],
-                            NULL);
+                            NULL, NULL);
 }
 
 DEFUN (ip_route_vrf,
@@ -835,7 +878,7 @@ DEFUN (ip_route_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], NULL, NULL,
-                            argv[2]);
+                            argv[2], NULL);
 }
 
 DEFUN (ip_route_flags_vrf,
@@ -851,7 +894,7 @@ DEFUN (ip_route_flags_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], argv[2], NULL,
-                            argv[3]);
+                            argv[3], NULL);
 }
 
 DEFUN (ip_route_flags2_vrf,
@@ -865,7 +908,7 @@ DEFUN (ip_route_flags2_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, NULL, argv[1], NULL,
-                            argv[2]);
+                            argv[2], NULL);
 }
 
 /* Mask as A.B.C.D format.  */
@@ -882,7 +925,7 @@ DEFUN (ip_route_mask_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], NULL, NULL,
-                            argv[3]);
+                            argv[3], NULL);
 }
 
 DEFUN (ip_route_mask_flags_vrf,
@@ -899,7 +942,7 @@ DEFUN (ip_route_mask_flags_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], argv[3], NULL,
-                            argv[4]);
+                            argv[4], NULL);
 }
 
 DEFUN (ip_route_mask_flags2_vrf,
@@ -914,7 +957,7 @@ DEFUN (ip_route_mask_flags2_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], NULL, argv[2], NULL,
-                            argv[3]);
+                            argv[3], NULL);
 }
 
 /* Distance option value.  */
@@ -931,7 +974,7 @@ DEFUN (ip_route_distance_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], NULL, argv[2],
-                            argv[3]);
+                            argv[3], NULL);
 }
 
 DEFUN (ip_route_flags_distance_vrf,
@@ -948,7 +991,7 @@ DEFUN (ip_route_flags_distance_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], argv[2], argv[3],
-                            argv[4]);
+                            argv[4], NULL);
 }
 
 DEFUN (ip_route_flags_distance2_vrf,
@@ -963,7 +1006,7 @@ DEFUN (ip_route_flags_distance2_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], NULL, NULL, argv[1], argv[2],
-                            argv[3]);
+                            argv[3], NULL);
 }
 
 DEFUN (ip_route_mask_distance_vrf,
@@ -980,7 +1023,7 @@ DEFUN (ip_route_mask_distance_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], NULL, argv[3],
-                            argv[4]);
+                            argv[4], NULL);
 }
 
 DEFUN (ip_route_mask_flags_distance_vrf,
@@ -998,7 +1041,7 @@ DEFUN (ip_route_mask_flags_distance_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], argv[3], argv[4],
-                            argv[5]);
+                            argv[5], NULL);
 }
 
 DEFUN (ip_route_mask_flags_distance2_vrf,
@@ -1014,7 +1057,7 @@ DEFUN (ip_route_mask_flags_distance2_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 1, argv[0], argv[1], NULL, argv[2], argv[3],
-                            argv[4]);
+                            argv[4], NULL);
 }
 
 DEFUN (no_ip_route_vrf,
@@ -1030,7 +1073,7 @@ DEFUN (no_ip_route_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], NULL, NULL,
-                            (argc > 3) ? argv[3] : argv[2]);
+                            (argc > 3) ? argv[3] : argv[2], NULL);
 }
 
 ALIAS (no_ip_route_vrf,
@@ -1058,7 +1101,7 @@ DEFUN (no_ip_route_flags2_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 0, argv[0], NULL, NULL, NULL, NULL,
-                            argv[2]);
+                            argv[2], NULL);
 }
 
 DEFUN (no_ip_route_mask_vrf,
@@ -1075,7 +1118,7 @@ DEFUN (no_ip_route_mask_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], NULL, NULL,
-                            (argc > 4) ? argv[4] : argv[3]);
+                            (argc > 4) ? argv[4] : argv[3], NULL);
 }
 
 ALIAS (no_ip_route_mask_vrf,
@@ -1105,7 +1148,7 @@ DEFUN (no_ip_route_mask_flags2_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 0, argv[0], argv[1], NULL, NULL, NULL,
-                            argv[2]);
+                            argv[2], NULL);
 }
 
 DEFUN (no_ip_route_distance_vrf,
@@ -1122,7 +1165,7 @@ DEFUN (no_ip_route_distance_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], NULL, argv[2],
-                            argv[3]);
+                            argv[3], NULL);
 }
 
 DEFUN (no_ip_route_flags_distance_vrf,
@@ -1140,7 +1183,7 @@ DEFUN (no_ip_route_flags_distance_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], argv[2], argv[3],
-                            argv[4]);
+                            argv[4], NULL);
 }
 
 DEFUN (no_ip_route_flags_distance2_vrf,
@@ -1156,7 +1199,7 @@ DEFUN (no_ip_route_flags_distance2_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 0, argv[0], NULL, NULL, argv[1], argv[2],
-                            argv[3]);
+                            argv[3], NULL);
 }
 
 DEFUN (no_ip_route_mask_distance_vrf,
@@ -1174,7 +1217,7 @@ DEFUN (no_ip_route_mask_distance_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], NULL, argv[3],
-                            argv[4]);
+                            argv[4], NULL);
 }
 
 DEFUN (no_ip_route_mask_flags_distance_vrf,
@@ -1193,7 +1236,7 @@ DEFUN (no_ip_route_mask_flags_distance_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], argv[3], argv[4],
-                            argv[5]);
+                            argv[5], NULL);
 }
 
 DEFUN (no_ip_route_mask_flags_distance2_vrf,
@@ -1210,7 +1253,7 @@ DEFUN (no_ip_route_mask_flags_distance2_vrf,
        VRF_CMD_HELP_STR)
 {
   return zebra_static_ipv4 (vty, 0, argv[0], argv[1], NULL, argv[2], argv[3],
-                            argv[4]);
+                            argv[4], NULL);
 }
 
 char *proto_rm[AFI_MAX][ZEBRA_ROUTE_MAX+1];	/* "any" == ZEBRA_ROUTE_MAX */
@@ -1266,6 +1309,162 @@ DEFUN (no_ip_protocol,
   return CMD_SUCCESS;
 }
 
+#if 1
+static int
+zebra_mpls_transit_lsp (struct vty *vty, int add_cmd, const char *inlabel_str,
+		        const char *gate_str, const char *outlabel_str,
+                        const char *flag_str)
+{
+  struct zebra_vrf *zvrf;
+  int ret;
+  enum nexthop_types_t gtype;
+  union g_addr gate;
+  mpls_label_t label;
+  mpls_label_t in_label, out_label;
+
+  zvrf = vrf_info_lookup(VRF_DEFAULT);
+  if (!zvrf)
+    {
+      vty_out (vty, "%% Default VRF does not exist%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  if (!inlabel_str)
+    {
+      vty_out (vty, "%% No Label Information%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  out_label = MPLS_IMP_NULL_LABEL; /* as initialization */
+  label = atoi(inlabel_str);
+  if (!IS_MPLS_UNRESERVED_LABEL(label))
+    {
+      vty_out (vty, "%% Invalid label%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  if (add_cmd)
+    {
+      if (!gate_str)
+        {
+          vty_out (vty, "%% No Nexthop Information%s", VTY_NEWLINE);
+          return CMD_WARNING;
+        }
+      if (!outlabel_str)
+        {
+          vty_out (vty, "%% No Outgoing label Information%s", VTY_NEWLINE);
+          return CMD_WARNING;
+        }
+    }
+
+  in_label = label;
+  gtype = NEXTHOP_TYPE_BLACKHOLE; /* as initialization */
+
+  if (gate_str)
+    {
+      /* Gateway is a IPv4 or IPv6 nexthop. */
+      ret = inet_pton (AF_INET6, gate_str, &gate.ipv6);
+      if (ret)
+        gtype = NEXTHOP_TYPE_IPV6;
+      else
+        {
+          ret = inet_pton (AF_INET, gate_str, &gate.ipv4);
+          if (ret)
+            gtype = NEXTHOP_TYPE_IPV4;
+          else
+            {
+              vty_out (vty, "%% Invalid nexthop%s", VTY_NEWLINE);
+              return CMD_WARNING;
+            }
+        }
+    }
+
+  if (outlabel_str)
+    {
+      if (outlabel_str[0] == 'i')
+        out_label = MPLS_IMP_NULL_LABEL;
+      else
+        out_label = atoi(outlabel_str);
+    }
+
+  if (add_cmd)
+    {
+      /* Check that label value is consistent. */
+      if (!zebra_mpls_lsp_label_consistent (zvrf, in_label, out_label, gtype,
+                                            &gate, NULL, 0))
+        {
+          vty_out (vty, "%% Label value not consistent%s",
+                   VTY_NEWLINE);
+          return CMD_WARNING;
+        }
+
+      ret = zebra_mpls_static_lsp_add (zvrf, in_label, out_label, gtype,
+                                       &gate, NULL, 0);
+    }
+  else
+    ret = zebra_mpls_static_lsp_del (zvrf, in_label, gtype, &gate, NULL, 0);
+
+  if (ret)
+    {
+      vty_out (vty, "%% LSP cannot be %s%s",
+               add_cmd ? "added" : "deleted", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  return CMD_SUCCESS;
+}
+
+DEFUN (mpls_transit_lsp,
+       mpls_transit_lsp_cmd,
+       "mpls lsp <16-1048575> (A.B.C.D|X:X::X:X) (<16-1048575>|implicit-null)",
+       MPLS_STR
+       "Establish label switched path\n"
+       "Incoming MPLS label\n"
+       "IPv4 gateway address\n"
+       "IPv6 gateway address\n"
+       "Outgoing MPLS label\n"
+       "Use Implicit-Null label\n")
+{
+  return zebra_mpls_transit_lsp (vty, 1, argv[0], argv[1], argv[2], NULL);
+}
+
+DEFUN (no_mpls_transit_lsp,
+       no_mpls_transit_lsp_cmd,
+       "no mpls lsp <16-1048575> (A.B.C.D|X:X::X:X)",
+       NO_STR
+       MPLS_STR
+       "Establish label switched path\n"
+       "Incoming MPLS label\n"
+       "IPv4 gateway address\n"
+       "IPv6 gateway address\n")
+{
+  return zebra_mpls_transit_lsp (vty, 0, argv[0], argv[1], NULL, NULL);
+}
+
+ALIAS (no_mpls_transit_lsp,
+       no_mpls_transit_lsp_out_label_cmd,
+       "no mpls lsp <16-1048575> (A.B.C.D|X:X::X:X) (<16-1048575>|implicit-null)",
+       NO_STR
+       MPLS_STR
+       "Establish label switched path\n"
+       "Incoming MPLS label\n"
+       "IPv4 gateway address\n"
+       "IPv6 gateway address\n"
+       "Outgoing MPLS label\n"
+       "Use Implicit-Null label\n")
+ 
+DEFUN (no_mpls_transit_lsp_all,
+       no_mpls_transit_lsp_all_cmd,
+       "no mpls lsp <16-1048575>",
+       NO_STR
+       MPLS_STR
+       "Establish label switched path\n"
+       "Incoming MPLS label\n")
+{
+  return zebra_mpls_transit_lsp (vty, 0, argv[0], NULL, NULL, NULL);
+}
+#endif /* HAVE_MPLS */
+
 /* New RIB.  Detailed information for IPv4 route. */
 static void
 vty_show_ip_route_detail (struct vty *vty, struct route_node *rn, int mcast)
@@ -1412,6 +1611,15 @@ vty_show_ip_route_detail (struct vty *vty, struct route_node *rn, int mcast)
             default:
                break;
             }
+
+          /* Label information */
+          if (nexthop->nh_label && nexthop->nh_label->num_labels)
+            {
+              vty_out (vty, " label %s",
+                       mpls_label2str (nexthop->nh_label->num_labels,
+                                   nexthop->nh_label->label,  buf, BUFSIZ));
+            }
+
           vty_out (vty, "%s", VTY_NEWLINE);
         }
       vty_out (vty, "%s", VTY_NEWLINE);
@@ -1523,6 +1731,14 @@ vty_show_ip_route (struct vty *vty, struct route_node *rn, struct rib *rib)
             break;
         }
 
+        /* Label information */
+        if (nexthop->nh_label && nexthop->nh_label->num_labels)
+          {
+            vty_out (vty, " label %s",
+                     mpls_label2str (nexthop->nh_label->num_labels,
+                                 nexthop->nh_label->label,  buf, BUFSIZ));
+          }
+
       if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_BLACKHOLE))
                vty_out (vty, ", bh");
       if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_REJECT))
@@ -2405,6 +2621,7 @@ static_config_ipv4 (struct vty *vty, safi_t safi, const char *cmd)
   struct zebra_vrf *zvrf;
   vrf_iter_t iter;
   int write;
+  char buf[BUFSIZ];
 
   write = 0;
 
@@ -2449,6 +2666,12 @@ static_config_ipv4 (struct vty *vty, safi_t safi, const char *cmd)
             if (si->vrf_id != VRF_DEFAULT)
               vty_out (vty, " vrf %u", si->vrf_id);
 
+            /* Label information */
+            if (si->snh_label.num_labels)
+              vty_out (vty, " label %s",
+                       mpls_label2str (si->snh_label.num_labels,
+                                       si->snh_label.label,  buf, BUFSIZ));
+
             vty_out (vty, "%s", VTY_NEWLINE);
 
             write = 1;
@@ -2502,6 +2725,7 @@ static_ipv6_func (struct vty *vty, int add_cmd, const char *dest_str,
   u_char type = 0;
   vrf_id_t vrf_id = VRF_DEFAULT;
   u_char flag = 0;
+  struct static_nh_label snh_label;
   
   ret = str2prefix (dest_str, &p);
   if (ret <= 0)
@@ -2536,6 +2760,9 @@ static_ipv6_func (struct vty *vty, int add_cmd, const char *dest_str,
   else
     distance = ZEBRA_STATIC_DISTANCE_DEFAULT;
 
+  /* Labels -- not supported for IPv6 for now. */
+  memset (&snh_label, 0, sizeof (struct static_nh_label));
+
   /* When gateway is valid IPv6 addrees, then gate is treated as
      nexthop address other case gate is treated as interface name. */
   ret = inet_pton (AF_INET6, gate_str, &gate_addr);
@@ -2571,9 +2798,9 @@ static_ipv6_func (struct vty *vty, int add_cmd, const char *dest_str,
     VTY_GET_INTEGER ("VRF ID", vrf_id, vrf_id_str);
 
   if (add_cmd)
-    static_add_ipv6 (&p, type, gate, ifname, flag, distance, vrf_id);
+    static_add_ipv6 (&p, type, gate, ifname, flag, distance, vrf_id, &snh_label);
   else
-    static_delete_ipv6 (&p, type, gate, ifname, distance, vrf_id);
+    static_delete_ipv6 (&p, type, gate, ifname, distance, vrf_id, &snh_label);
 
   return CMD_SUCCESS;
 }
@@ -3803,6 +4030,54 @@ zebra_ip_config (struct vty *vty)
   return write;
 }
 
+#if 1
+/* MPLS LSP configuration write function. */
+static int
+zebra_mpls_config (struct vty *vty)
+{
+  int write = 0;
+  struct zebra_vrf *zvrf;
+
+  zvrf = vrf_info_lookup(VRF_DEFAULT);
+  if (!zvrf)
+    return 0;
+
+  write += zebra_mpls_write_lsp_config(vty, zvrf);
+  return write;
+}
+
+DEFUN (show_mpls_table,
+       show_mpls_table_cmd,
+       "show mpls table",
+       SHOW_STR
+       MPLS_STR
+       "MPLS table\n")
+{
+  struct zebra_vrf *zvrf;
+
+  zvrf = vrf_info_lookup(VRF_DEFAULT);
+  zebra_mpls_print_lsp_table(vty, zvrf);
+  return CMD_SUCCESS;
+}
+
+DEFUN (show_mpls_table_lsp,
+       show_mpls_table_lsp_cmd,
+       "show mpls table <16-1048575>",
+       SHOW_STR
+       MPLS_STR
+       "MPLS table\n"
+       "LSP to display information about\n")
+{
+  u_int32_t label;
+  struct zebra_vrf *zvrf;
+
+  zvrf = vrf_info_lookup(VRF_DEFAULT);
+  label = atoi(argv[0]);
+  zebra_mpls_print_lsp (vty, zvrf, label);
+  return CMD_SUCCESS;
+}
+#endif /* HAVE_MPLS */
+
 static int config_write_vty(struct vty *vty)
 {
   int i;
@@ -3836,12 +4111,21 @@ static struct cmd_node protocol_node = { PROTOCOL_NODE, "", 1 };
 /* IP node for static routes. */
 static struct cmd_node ip_node = { IP_NODE,  "",  1 };
 
+#if 1
+/* MPLS node for MPLS LSP. */
+static struct cmd_node mpls_node = { MPLS_NODE,  "",  1 };
+#endif
+
 /* Route VTY.  */
 void
 zebra_vty_init (void)
 {
   install_node (&ip_node, zebra_ip_config);
   install_node (&protocol_node, config_write_vty);
+#if 1
+  install_node (&mpls_node, zebra_mpls_config);
+#endif
+
 
   install_element (CONFIG_NODE, &ip_mroute_cmd);
   install_element (CONFIG_NODE, &ip_mroute_dist_cmd);
@@ -4064,4 +4348,16 @@ zebra_vty_init (void)
   install_element (VIEW_NODE, &show_ipv6_mroute_vrf_all_cmd);
   install_element (ENABLE_NODE, &show_ipv6_mroute_vrf_all_cmd);
 #endif /* HAVE_IPV6 */
+
+#if 1
+  install_element (CONFIG_NODE, &mpls_transit_lsp_cmd);
+  install_element (CONFIG_NODE, &no_mpls_transit_lsp_cmd);
+  install_element (CONFIG_NODE, &no_mpls_transit_lsp_out_label_cmd);
+  install_element (CONFIG_NODE, &no_mpls_transit_lsp_all_cmd);
+
+  install_element (VIEW_NODE, &show_mpls_table_cmd);
+  install_element (ENABLE_NODE, &show_mpls_table_cmd);
+  install_element (VIEW_NODE, &show_mpls_table_lsp_cmd);
+  install_element (ENABLE_NODE, &show_mpls_table_lsp_cmd);
+#endif
 }
diff --git a/zebra/zserv.c b/zebra/zserv.c
index e624ef2..2329f21 100644
--- a/zebra/zserv.c
+++ b/zebra/zserv.c
@@ -43,6 +43,7 @@
 #include "zebra/redistribute.h"
 #include "zebra/debug.h"
 #include "zebra/ipforward.h"
+#include "zebra/zebra_mpls.h"
 
 /* Event list of zebra. */
 enum event { ZEBRA_SERV, ZEBRA_READ, ZEBRA_WRITE };
@@ -830,7 +831,8 @@ zread_ipv4_add (struct zserv *client, u_short length, vrf_id_t vrf_id)
   ifindex_t ifindex;
   u_char ifname_len;
   safi_t safi;	
-
+  struct nexthop *nh;
+  u_int32_t label;
 
   /* Get input stream.  */
   s = client->ibuf;
@@ -840,6 +842,12 @@ zread_ipv4_add (struct zserv *client, u_short length, vrf_id_t vrf_id)
   
   /* Type, flags, message. */
   rib->type = stream_getc (s);
+/*
+#if !defined(HAVE_MPLS)
+  if (rib->type == ZEBRA_ROUTE_LDP)
+    return 0;
+#endif
+*/
   rib->flags = stream_getc (s);
   message = stream_getc (s); 
   safi = stream_getw (s);
@@ -854,6 +862,10 @@ zread_ipv4_add (struct zserv *client, u_short length, vrf_id_t vrf_id)
   /* VRF ID */
   rib->vrf_id = vrf_id;
 
+  /* MPLS label. */
+  if (CHECK_FLAG (message, ZAPI_MESSAGE_LABEL))
+    label = stream_getl (s);
+
   /* Nexthop parse. */
   if (CHECK_FLAG (message, ZAPI_MESSAGE_NEXTHOP))
     {
@@ -875,7 +887,9 @@ zread_ipv4_add (struct zserv *client, u_short length, vrf_id_t vrf_id)
 	      break;
 	    case ZEBRA_NEXTHOP_IPV4:
 	      nexthop.s_addr = stream_get_ipv4 (s);
-	      nexthop_ipv4_add (rib, &nexthop, NULL);
+	      nh = nexthop_ipv4_add (rib, &nexthop, NULL);
+	      if (CHECK_FLAG (message, ZAPI_MESSAGE_LABEL))
+		nexthop_add_labels (nh, 1, &label);
 	      break;
 	    case ZEBRA_NEXTHOP_IPV4_IFINDEX:
 	      nexthop.s_addr = stream_get_ipv4 (s);
@@ -1044,6 +1058,7 @@ zread_ipv6_add (struct zserv *client, u_short length, vrf_id_t vrf_id)
   struct in6_addr nexthop;
   unsigned long ifindex;
   struct prefix_ipv6 p;
+  u_int32_t label = MPLS_NO_LABEL;
   
   s = client->ibuf;
   ifindex = 0;
@@ -1051,6 +1066,12 @@ zread_ipv6_add (struct zserv *client, u_short length, vrf_id_t vrf_id)
 
   /* Type, flags, message. */
   api.type = stream_getc (s);
+/*
+#if !defined(HAVE_MPLS)
+  if (api.type == ZEBRA_ROUTE_LDP)
+    return 0;
+#endif
+*/
   api.flags = stream_getc (s);
   api.message = stream_getc (s);
   api.safi = stream_getw (s);
@@ -1061,6 +1082,10 @@ zread_ipv6_add (struct zserv *client, u_short length, vrf_id_t vrf_id)
   p.prefixlen = stream_getc (s);
   stream_get (&p.prefix, s, PSIZE (p.prefixlen));
 
+  /* MPLS label. */
+  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_LABEL))
+    label = stream_getl (s);
+
   /* Nexthop, ifindex, distance, metric. */
   if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
     {
@@ -1099,11 +1124,11 @@ zread_ipv6_add (struct zserv *client, u_short length, vrf_id_t vrf_id)
     api.mtu = 0;
     
   if (IN6_IS_ADDR_UNSPECIFIED (&nexthop))
-    rib_add_ipv6 (api.type, api.flags, &p, NULL, ifindex,
+    rib_add_ipv6 (api.type, api.flags, &p, NULL, ifindex, label,
                   vrf_id, zebrad.rtm_table_default, api.metric,
                   api.mtu, api.distance, api.safi);
   else
-    rib_add_ipv6 (api.type, api.flags, &p, &nexthop, ifindex,
+    rib_add_ipv6 (api.type, api.flags, &p, &nexthop, ifindex, label,
                   vrf_id, zebrad.rtm_table_default, api.metric,
                   api.mtu, api.distance, api.safi);
   return 0;
@@ -1254,20 +1279,77 @@ zread_vrf_unregister (struct zserv *client, u_short length, vrf_id_t vrf_id)
   return 0;
 }
 
+static int
+zread_mpls_lsp (int command, struct zserv *client, u_short length,
+		vrf_id_t vrf_id)
+{
+#if 1
+  struct stream *s;
+  enum lsp_types_t type;
+  int af;
+  enum nexthop_types_t gtype;
+  union g_addr gate;
+  u_int32_t in_label, out_label;
+  struct zebra_vrf *zvrf;
+  int ret;
+
+  /* Get input stream.  */
+  s = client->ibuf;
+
+  /* Get data. */
+  type = stream_getc (s);
+  af = stream_getl (s);
+  switch (af)
+    {
+    case AF_INET:
+      gtype = NEXTHOP_TYPE_IPV4;
+      gate.ipv4.s_addr = stream_get_ipv4 (s);
+      break;
+    case AF_INET6:
+      gtype = NEXTHOP_TYPE_IPV6;
+      stream_get (&gate.ipv6, s, 16);
+      break;
+    default:
+      return (-1);
+    }
+  in_label = stream_getl (s);
+  out_label = stream_getl (s);
+
+  zvrf = vrf_info_lookup (vrf_id);
+  if (!zvrf)
+    return -1;
+
+  if (command == ZEBRA_MPLS_LSP_ADD)
+    ret = mpls_lsp_install (zvrf, type, in_label, out_label, gtype, &gate,
+			    NULL, 0);
+  else if (command == ZEBRA_MPLS_LSP_DELETE)
+    ret = mpls_lsp_uninstall (zvrf, type, in_label, gtype, &gate, NULL, 0);
+
+  return ret;
+#else
+  return 0;
+#endif
+}
+
 /* If client sent routes of specific type, zebra removes it
  * and returns number of deleted routes.
  */
 static void
 zebra_score_rib (int client_sock)
 {
+  struct zebra_vrf *zvrf;
   int i;
 
+  zvrf = vrf_info_lookup (VRF_DEFAULT);
+
   for (i = ZEBRA_ROUTE_RIP; i < ZEBRA_ROUTE_MAX; i++)
     if (client_sock == route_type_oaths[i])
       {
         zlog_notice ("client %d disconnected. %lu %s routes removed from the rib",
                       client_sock, rib_score_proto (i), zebra_route_string (i));
         route_type_oaths[i] = 0;
+        if (i == ZEBRA_ROUTE_LDP)
+	  hash_iterate(zvrf->lsp_table, mpls_ldp_lsp_uninstall_all, zvrf);
         break;
       }
 }
@@ -1504,6 +1586,10 @@ zebra_client_read (struct thread *thread)
     case ZEBRA_VRF_UNREGISTER:
       zread_vrf_unregister (client, length, vrf_id);
       break;
+    case ZEBRA_MPLS_LSP_ADD:
+    case ZEBRA_MPLS_LSP_DELETE:
+      zread_mpls_lsp(command, client, length, vrf_id);
+      break;
     default:
       zlog_info ("Zebra received unknown command %d", command);
       break;
diff --git a/zebra/zserv.h b/zebra/zserv.h
index fc01f96..8ad5b3b 100644
--- a/zebra/zserv.h
+++ b/zebra/zserv.h
@@ -82,6 +82,9 @@ struct zebra_t
   /* rib work queue */
   struct work_queue *ribq;
   struct meta_queue *mq;
+
+  /* LSP work queue */
+  struct work_queue *lsp_process_q;
 };
 
 /* Count prefix size from mask length */
